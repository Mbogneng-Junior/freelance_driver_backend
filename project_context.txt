Project Context From: /home/mbogneng-junior/freelance-driver_Sylladb/backend
Generated On: lun. 29 déc. 2025 20:12:25 WAT
===============================================
Ignored Directory Patterns: .* node_modules vendor build dist target __pycache__ .next cache target storage
Ignored File Patterns: *.log *.jar *.pdf *.class *.sqlite project_context.txt package-lock.json yarn.lock composer.lock *.ico pnpm-lock.yaml
===============================================

//---> PATH: /home/mbogneng-junior/freelance-driver_Sylladb/backend/aws/install

#!/bin/sh
# Copyright 2012-2019 Amazon.com, Inc. or its affiliates. All Rights Reserved.
#
# Licensed under the Apache License, Version 2.0 (the "License"). You
# may not use this file except in compliance with the License. A copy of
# the License is located at
#
#     http://aws.amazon.com/apache2.0/
#
# or in the "license" file accompanying this file. This file is
# distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF
# ANY KIND, either express or implied. See the License for the specific
# language governing permissions and limitations under the License.

usage() {
  cat 1>&2 <<EOF
Installs the AWS CLI v2

USAGE:
    install [FLAGS] [OPTIONS]

FLAGS:
    -u, --update              Updates the AWS CLI v2 if a different version
                              is previously installed. By default, this script
                              will not update the AWS CLI if a previous
                              installation is detected.

    -h, --help                Prints help information

OPTIONS:
    -i, --install-dir <path>  The directory to install the AWS CLI v2. By
                              default, this directory is: /usr/local/aws-cli

    -b, --bin-dir <path>      The directory to store symlinks to executables
                              for the AWS CLI v2. By default, the directory
                              used is: /usr/local/bin
EOF
}

parse_commandline() {
  while test $# -gt 0
  do
    key="$1"
	case "$key" in
	  -i|--install-dir)
	    PARSED_INSTALL_DIR="$2"
		shift
	   ;;
	  -b|--bin-dir)
	    PARSED_BIN_DIR="$2"
		shift
	   ;;
	  -u|--update)
	    PARSED_UPGRADE="yes"
	  ;;
	  -h|--help)
	    usage
        exit 0
	  ;;
	  *)
	   die "Got an unexpected argument: $1"
	  ;;
    esac
	shift
  done
}

set_global_vars() {
  ROOT_INSTALL_DIR=${PARSED_INSTALL_DIR:-/usr/local/aws-cli}
  BIN_DIR=${PARSED_BIN_DIR:-/usr/local/bin}
  UPGRADE=${PARSED_UPGRADE:-no}

  EXE_NAME="aws"
  COMPLETER_EXE_NAME="aws_completer"
  INSTALLER_DIR="$( cd "$( dirname "$0" )" >/dev/null 2>&1 && pwd )"
  INSTALLER_DIST_DIR="$INSTALLER_DIR/dist"
  INSTALLER_EXE="$INSTALLER_DIST_DIR/$EXE_NAME"
  AWS_EXE_VERSION=$($INSTALLER_EXE --version | cut -d ' ' -f 1 | cut -d '/' -f 2)

  INSTALL_DIR="$ROOT_INSTALL_DIR/v2/$AWS_EXE_VERSION"
  INSTALL_DIR="$INSTALL_DIR"
  INSTALL_DIST_DIR="$INSTALL_DIR/dist"
  INSTALL_BIN_DIR="$INSTALL_DIR/bin"
  INSTALL_AWS_EXE="$INSTALL_BIN_DIR/$EXE_NAME"
  INSTALL_AWS_COMPLETER_EXE="$INSTALL_BIN_DIR/$COMPLETER_EXE_NAME"

  CURRENT_INSTALL_DIR="$ROOT_INSTALL_DIR/v2/current"
  CURRENT_AWS_EXE="$CURRENT_INSTALL_DIR/bin/$EXE_NAME"
  CURRENT_AWS_COMPLETER_EXE="$CURRENT_INSTALL_DIR/bin/$COMPLETER_EXE_NAME"

  BIN_AWS_EXE="$BIN_DIR/$EXE_NAME"
  BIN_AWS_COMPLETER_EXE="$BIN_DIR/$COMPLETER_EXE_NAME"
}

create_install_dir() {
  mkdir -p "$INSTALL_DIR" || exit 1
  {
    setup_install_dist &&
    setup_install_bin &&
    create_current_symlink
  } || {
    rm -rf "$INSTALL_DIR"
    exit 1
  }
}

check_preexisting_install() {
  if [ -L "$CURRENT_INSTALL_DIR" ] && [ "$UPGRADE" = "no" ]
  then
    die "Found preexisting AWS CLI installation: $CURRENT_INSTALL_DIR. Please rerun install script with --update flag."
  fi
  if [ -d "$INSTALL_DIR" ]
  then
    echo "Found same AWS CLI version: $INSTALL_DIR. Skipping install."
    exit 0
  fi
}

setup_install_dist() {
  cp -r "$INSTALLER_DIST_DIR" "$INSTALL_DIST_DIR"
}

setup_install_bin() {
  mkdir -p "$INSTALL_BIN_DIR"
  ln -s "../dist/$EXE_NAME" "$INSTALL_AWS_EXE"
  ln -s "../dist/$COMPLETER_EXE_NAME" "$INSTALL_AWS_COMPLETER_EXE"
}

create_current_symlink() {
  ln -snf "$INSTALL_DIR" "$CURRENT_INSTALL_DIR"
}

create_bin_symlinks() {
  mkdir -p "$BIN_DIR"
  ln -sf "$CURRENT_AWS_EXE" "$BIN_AWS_EXE"
  ln -sf "$CURRENT_AWS_COMPLETER_EXE" "$BIN_AWS_COMPLETER_EXE"
}

die() {
	err_msg="$1"
	echo "$err_msg" >&2
	exit 1
}

main() {
  parse_commandline "$@"
  set_global_vars
  check_preexisting_install
  create_install_dir
  create_bin_symlinks
  echo "You can now run: $BIN_AWS_EXE --version"
  exit 0
}

main "$@" || exit 1
// END OF FILE: aws/install

//---> PATH: /home/mbogneng-junior/freelance-driver_Sylladb/backend/aws/README.md

# AWS CLI v2

This bundle contains a built executable of the AWS CLI v2.

## Installation

To install the AWS CLI v2, run the `install` script:
```
$ sudo ./install 
You can now run: /usr/local/bin/aws --version
```
This will install the AWS CLI v2 at `/usr/local/bin/aws`.  Assuming
`/usr/local/bin` is on your `PATH`, you can now run:
```
$ aws --version
```


### Installing without sudo

If you don't have ``sudo`` permissions or want to install the AWS
CLI v2 only for the current user, run the `install` script with the `-b`
and `-i` options:
```
$ ./install -i ~/.local/aws-cli -b ~/.local/bin
``` 
This will install the AWS CLI v2 in `~/.local/aws-cli` and create
symlinks for `aws` and `aws_completer` in `~/.local/bin`. For more
information about these options, run the `install` script with `-h`:
```
$ ./install -h
```

### Updating

If you run the `install` script and there is a previously installed version
of the AWS CLI v2, the script will error out. To update to the version included
in this bundle, run the `install` script with `--update`:
```
$ sudo ./install --update
```


### Removing the installation

To remove the AWS CLI v2, delete the its installation and symlinks:
```
$ sudo rm -rf /usr/local/aws-cli
$ sudo rm /usr/local/bin/aws
$ sudo rm /usr/local/bin/aws_completer
```
Note if you installed the AWS CLI v2 using the `-b` or `-i` options, you will
need to remove the installation and the symlinks in the directories you
specified.
// END OF FILE: aws/README.md

//---> PATH: /home/mbogneng-junior/freelance-driver_Sylladb/backend/aws/THIRD_PARTY_LICENSES

** botocore; version 2 -- https://github.com/boto/botocore/tree/v2
Botocore
Copyright 2012-2017 Amazon.com, Inc. or its affiliates. All Rights Reserved.

----

Botocore includes a vendorized copy of the requests python library to ease
installation.

Requests License
================

Copyright 2013 Kenneth Reitz

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.


The requests library also includes some vendorized python libraries to ease
installation.

Urllib3 License
===============

This is the MIT license: http://www.opensource.org/licenses/mit-license.php

Copyright 2008-2011 Andrey Petrov and contributors (see CONTRIBUTORS.txt),
Modifications copyright 2012 Kenneth Reitz.

Permission is hereby granted, free of charge, to any person obtaining a copy of
this
software and associated documentation files (the "Software"), to deal in the
Software
without restriction, including without limitation the rights to use, copy,
modify, merge,
publish, distribute, sublicense, and/or sell copies of the Software, and to
permit persons
to whom the Software is furnished to do so, subject to the following
conditions:

The above copyright notice and this permission notice shall be included in all
copies or
substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED,
INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
PARTICULAR
PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
BE LIABLE
FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
TORT OR
OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE
OR OTHER
DEALINGS IN THE SOFTWARE.

Chardet License
===============

This library is free software; you can redistribute it and/or
modify it under the terms of the GNU Lesser General Public
License as published by the Free Software Foundation; either
version 2.1 of the License, or (at your option) any later version.

This library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public
License along with this library; if not, write to the Free Software
Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
02110-1301  USA

Bundle of CA Root Certificates
==============================

This library is free software; you can redistribute it and/or
modify it under the terms of the GNU Lesser General Public
License as published by the Free Software Foundation; either
version 2.1 of the License, or (at your option) any later version.

This library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public
License along with this library; if not, write to the Free Software
Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
02110-1301
** s3transfer; version 0 -- https://github.com/boto/s3transfer
s3transfer
Copyright 2016 Amazon.com, Inc. or its affiliates. All Rights Reserved.

Apache License

Version 2.0, January 2004

http://www.apache.org/licenses/ TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND
DISTRIBUTION

   1. Definitions.

      "License" shall mean the terms and conditions for use, reproduction, and
      distribution as defined by Sections 1 through 9 of this document.

      "Licensor" shall mean the copyright owner or entity authorized by the
      copyright owner that is granting the License.

      "Legal Entity" shall mean the union of the acting entity and all other
      entities that control, are controlled by, or are under common control
      with that entity. For the purposes of this definition, "control" means
      (i) the power, direct or indirect, to cause the direction or management
      of such entity, whether by contract or otherwise, or (ii) ownership of
      fifty percent (50%) or more of the outstanding shares, or (iii)
      beneficial ownership of such entity.

      "You" (or "Your") shall mean an individual or Legal Entity exercising
      permissions granted by this License.

      "Source" form shall mean the preferred form for making modifications,
      including but not limited to software source code, documentation source,
      and configuration files.

      "Object" form shall mean any form resulting from mechanical
      transformation or translation of a Source form, including but not limited
      to compiled object code, generated documentation, and conversions to
      other media types.

      "Work" shall mean the work of authorship, whether in Source or Object
      form, made available under the License, as indicated by a copyright
      notice that is included in or attached to the work (an example is
      provided in the Appendix below).

      "Derivative Works" shall mean any work, whether in Source or Object form,
      that is based on (or derived from) the Work and for which the editorial
      revisions, annotations, elaborations, or other modifications represent,
      as a whole, an original work of authorship. For the purposes of this
      License, Derivative Works shall not include works that remain separable
      from, or merely link (or bind by name) to the interfaces of, the Work and
      Derivative Works thereof.

      "Contribution" shall mean any work of authorship, including the original
      version of the Work and any modifications or additions to that Work or
      Derivative Works thereof, that is intentionally submitted to Licensor for
      inclusion in the Work by the copyright owner or by an individual or Legal
      Entity authorized to submit on behalf of the copyright owner. For the
      purposes of this definition, "submitted" means any form of electronic,
      verbal, or written communication sent to the Licensor or its
      representatives, including but not limited to communication on electronic
      mailing lists, source code control systems, and issue tracking systems
      that are managed by, or on behalf of, the Licensor for the purpose of
      discussing and improving the Work, but excluding communication that is
      conspicuously marked or otherwise designated in writing by the copyright
      owner as "Not a Contribution."

      "Contributor" shall mean Licensor and any individual or Legal Entity on
      behalf of whom a Contribution has been received by Licensor and
      subsequently incorporated within the Work.

   2. Grant of Copyright License. Subject to the terms and conditions of this
   License, each Contributor hereby grants to You a perpetual, worldwide,
   non-exclusive, no-charge, royalty-free, irrevocable copyright license to
   reproduce, prepare Derivative Works of, publicly display, publicly perform,
   sublicense, and distribute the Work and such Derivative Works in Source or
   Object form.

   3. Grant of Patent License. Subject to the terms and conditions of this
   License, each Contributor hereby grants to You a perpetual, worldwide,
   non-exclusive, no-charge, royalty-free, irrevocable (except as stated in
   this section) patent license to make, have made, use, offer to sell, sell,
   import, and otherwise transfer the Work, where such license applies only to
   those patent claims licensable by such Contributor that are necessarily
   infringed by their Contribution(s) alone or by combination of their
   Contribution(s) with the Work to which such Contribution(s) was submitted.
   If You institute patent litigation against any entity (including a
   cross-claim or counterclaim in a lawsuit) alleging that the Work or a
   Contribution incorporated within the Work constitutes direct or contributory
   patent infringement, then any patent licenses granted to You under this
   License for that Work shall terminate as of the date such litigation is
   filed.

   4. Redistribution. You may reproduce and distribute copies of the Work or
   Derivative Works thereof in any medium, with or without modifications, and
   in Source or Object form, provided that You meet the following conditions:

      (a) You must give any other recipients of the Work or Derivative Works a
      copy of this License; and

      (b) You must cause any modified files to carry prominent notices stating
      that You changed the files; and

      (c) You must retain, in the Source form of any Derivative Works that You
      distribute, all copyright, patent, trademark, and attribution notices
      from the Source form of the Work, excluding those notices that do not
      pertain to any part of the Derivative Works; and

      (d) If the Work includes a "NOTICE" text file as part of its
      distribution, then any Derivative Works that You distribute must include
      a readable copy of the attribution notices contained within such NOTICE
      file, excluding those notices that do not pertain to any part of the
      Derivative Works, in at least one of the following places: within a
      NOTICE text file distributed as part of the Derivative Works; within the
      Source form or documentation, if provided along with the Derivative
      Works; or, within a display generated by the Derivative Works, if and
      wherever such third-party notices normally appear. The contents of the
      NOTICE file are for informational purposes only and do not modify the
      License. You may add Your own attribution notices within Derivative Works
      that You distribute, alongside or as an addendum to the NOTICE text from
      the Work, provided that such additional attribution notices cannot be
      construed as modifying the License.

      You may add Your own copyright statement to Your modifications and may
      provide additional or different license terms and conditions for use,
      reproduction, or distribution of Your modifications, or for any such
      Derivative Works as a whole, provided Your use, reproduction, and
      distribution of the Work otherwise complies with the conditions stated in
      this License.

   5. Submission of Contributions. Unless You explicitly state otherwise, any
   Contribution intentionally submitted for inclusion in the Work by You to the
   Licensor shall be under the terms and conditions of this License, without
   any additional terms or conditions. Notwithstanding the above, nothing
   herein shall supersede or modify the terms of any separate license agreement
   you may have executed with Licensor regarding such Contributions.

   6. Trademarks. This License does not grant permission to use the trade
   names, trademarks, service marks, or product names of the Licensor, except
   as required for reasonable and customary use in describing the origin of the
   Work and reproducing the content of the NOTICE file.

   7. Disclaimer of Warranty. Unless required by applicable law or agreed to in
   writing, Licensor provides the Work (and each Contributor provides its
   Contributions) on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
   KIND, either express or implied, including, without limitation, any
   warranties or conditions of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or
   FITNESS FOR A PARTICULAR PURPOSE. You are solely responsible for determining
   the appropriateness of using or redistributing the Work and assume any risks
   associated with Your exercise of permissions under this License.

   8. Limitation of Liability. In no event and under no legal theory, whether
   in tort (including negligence), contract, or otherwise, unless required by
   applicable law (such as deliberate and grossly negligent acts) or agreed to
   in writing, shall any Contributor be liable to You for damages, including
   any direct, indirect, special, incidental, or consequential damages of any
   character arising as a result of this License or out of the use or inability
   to use the Work (including but not limited to damages for loss of goodwill,
   work stoppage, computer failure or malfunction, or any and all other
   commercial damages or losses), even if such Contributor has been advised of
   the possibility of such damages.

   9. Accepting Warranty or Additional Liability. While redistributing the Work
   or Derivative Works thereof, You may choose to offer, and charge a fee for,
   acceptance of support, warranty, indemnity, or other liability obligations
   and/or rights consistent with this License. However, in accepting such
   obligations, You may act only on Your own behalf and on Your sole
   responsibility, not on behalf of any other Contributor, and only if You
   agree to indemnify, defend, and hold each Contributor harmless for any
   liability incurred by, or claims asserted against, such Contributor by
   reason of your accepting any such warranty or additional liability. END OF
   TERMS AND CONDITIONS

APPENDIX: How to apply the Apache License to your work.

To apply the Apache License to your work, attach the following boilerplate
notice, with the fields enclosed by brackets "[]" replaced with your own
identifying information. (Don't include the brackets!) The text should be
enclosed in the appropriate comment syntax for the file format. We also
recommend that a file or class name and description of purpose be included on
the same "printed page" as the copyright notice for easier identification
within third-party archives.

Copyright [yyyy] [name of copyright owner]

Licensed under the Apache License, Version 2.0 (the "License");

you may not use this file except in compliance with the License.

You may obtain a copy of the License at

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software

distributed under the License is distributed on an "AS IS" BASIS,

WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.

See the License for the specific language governing permissions and

limitations under the License.

* For botocore see also this required NOTICE:
    Botocore
    Copyright 2012-2017 Amazon.com, Inc. or its affiliates. All Rights
    Reserved.

    ----

    Botocore includes a vendorized copy of the requests python library to ease
    installation.

    Requests License
    ================

    Copyright 2013 Kenneth Reitz

       Licensed under the Apache License, Version 2.0 (the "License");
       you may not use this file except in compliance with the License.
       You may obtain a copy of the License at

           http://www.apache.org/licenses/LICENSE-2.0

       Unless required by applicable law or agreed to in writing, software
       distributed under the License is distributed on an "AS IS" BASIS,
       WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       See the License for the specific language governing permissions and
       limitations under the License.


    The requests library also includes some vendorized python libraries to ease
    installation.

    Urllib3 License
    ===============

    This is the MIT license: http://www.opensource.org/licenses/mit-license.php

    Copyright 2008-2011 Andrey Petrov and contributors (see CONTRIBUTORS.txt),
    Modifications copyright 2012 Kenneth Reitz.

    Permission is hereby granted, free of charge, to any person obtaining a
    copy of this
    software and associated documentation files (the "Software"), to deal in
    the Software
    without restriction, including without limitation the rights to use, copy,
    modify, merge,
    publish, distribute, sublicense, and/or sell copies of the Software, and to
    permit persons
    to whom the Software is furnished to do so, subject to the following
    conditions:

    The above copyright notice and this permission notice shall be included in
    all copies or
    substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
    IMPLIED,
    INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR
    A PARTICULAR
    PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
    HOLDERS BE LIABLE
    FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF
    CONTRACT, TORT OR
    OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
    USE OR OTHER
    DEALINGS IN THE SOFTWARE.

    Chardet License
    ===============

    This library is free software; you can redistribute it and/or
    modify it under the terms of the GNU Lesser General Public
    License as published by the Free Software Foundation; either
    version 2.1 of the License, or (at your option) any later version.

    This library is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
    Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public
    License along with this library; if not, write to the Free Software
    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
    02110-1301  USA

    Bundle of CA Root Certificates
    ==============================

    This library is free software; you can redistribute it and/or
    modify it under the terms of the GNU Lesser General Public
    License as published by the Free Software Foundation; either
    version 2.1 of the License, or (at your option) any later version.

    This library is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
    Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public
    License along with this library; if not, write to the Free Software
    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
    02110-1301
* For s3transfer see also this required NOTICE:
    s3transfer
    Copyright 2016 Amazon.com, Inc. or its affiliates. All Rights Reserved.

------

** colorama; version 0.4.2 -- https://pypi.org/project/colorama/
Copyright (c) 2010 Jonathan Hartley
All rights reserved.

Copyright (c) 2010 Jonathan Hartley
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

* Redistributions of source code must retain the above copyright notice, this
  list of conditions and the following disclaimer.

* Redistributions in binary form must reproduce the above copyright notice,
  this list of conditions and the following disclaimer in the documentation
  and/or other materials provided with the distribution.

* Neither the name of the copyright holders, nor those of its contributors
  may be used to endorse or promote products derived from this software without
  specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

------

** prompt-toolkit; version 2.0.10 --
https://github.com/prompt-toolkit/python-prompt-toolkit/tree/2.0.10
Copyright (c) 2014, Jonathan Slenders
All rights reserved.

Copyright (c) 2014, Jonathan Slenders
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification,
are permitted provided that the following conditions are met:

* Redistributions of source code must retain the above copyright notice, this
  list of conditions and the following disclaimer.

* Redistributions in binary form must reproduce the above copyright notice,
this
  list of conditions and the following disclaimer in the documentation and/or
  other materials provided with the distribution.

* Neither the name of the {organization} nor the names of its
  contributors may be used to endorse or promote products derived from
  this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

------

** dateutil; version 2.8.0 -- https://github.com/dateutil/dateutil/tree/2.8.0
Copyright 2017- Paul Ganssle <paul@ganssle.io>
Copyright 2017- dateutil contributors (see AUTHORS file)

Copyright 2017- Paul Ganssle <paul@ganssle.io>
Copyright 2017- dateutil contributors (see AUTHORS file)

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.

The above license applies to all contributions after 2017-12-01, as well as
all contributions that have been re-licensed (see AUTHORS file for the list of
contributors who have re-licensed their code).
--------------------------------------------------------------------------------
dateutil - Extensions to the standard Python datetime module.

Copyright (c) 2003-2011 - Gustavo Niemeyer <gustavo@niemeyer.net>
Copyright (c) 2012-2014 - Tomi Pieviläinen <tomi.pievilainen@iki.fi>
Copyright (c) 2014-2016 - Yaron de Leeuw <me@jarondl.net>
Copyright (c) 2015-     - Paul Ganssle <paul@ganssle.io>
Copyright (c) 2015-     - dateutil contributors (see AUTHORS file)

All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

    * Redistributions of source code must retain the above copyright notice,
      this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright notice,
      this list of conditions and the following disclaimer in the documentation
      and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the names of its
      contributors may be used to endorse or promote products derived from
      this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

The above BSD License Applies to all code, even that also covered by Apache
2.0.

------

** Pyintaller 3.5; version 3.5 --
https://github.com/pyinstaller/pyinstaller/tree/v3.5
Copyright (c) 2010-2020, PyInstaller Development Team
Copyright (c) 2005-2009, Giovanni Bajo
Based on previous work under copyright (c) 2002 McMillan Enterprises, Inc.

    * Package Pyintaller 3.5's source code may be found at:
      https://files.pythonhosted.org/packages/e2/c9/0b44b2ea87ba36395483a672fddd07e6a9cb2b8d3c4a28d7ae76c7e7e1e5/PyInstaller-3.5.tar.gz

================================
 The PyInstaller licensing terms
================================


Copyright (c) 2010-2020, PyInstaller Development Team
Copyright (c) 2005-2009, Giovanni Bajo
Based on previous work under copyright (c) 2002 McMillan Enterprises, Inc.


PyInstaller is licensed under the terms of the GNU General Public License
as published by the Free Software Foundation; either version 2 of the License,
or (at your option) any later version.


Bootloader Exception
--------------------

In addition to the permissions in the GNU General Public License, the
authors give you unlimited permission to link or embed compiled bootloader
and related files into combinations with other programs, and to distribute
those combinations without any restriction coming from the use of those
files. (The General Public License restrictions do apply in other respects;
for example, they cover modification of the files, and distribution when
not linked into a combined executable.)


Bootloader and Related Files
----------------------------

Bootloader and related files are files which are embedded within the
final executable. This includes files in directories:

./bootloader/
./PyInstaller/loader


About the PyInstaller Development Team
--------------------------------------

The PyInstaller Development Team is the set of contributors
to the PyInstaller project. A full list with details is kept
in the documentation directory, in the file
``doc/CREDITS.rst``.

The core team that coordinates development on GitHub can be found here:
https://github.com/pyinstaller/pyinstaller.  As of 2015, it consists of:

* Hartmut Goebel
* Martin Zibricky
* David Vierra
* David Cortesi


Our Copyright Policy
--------------------

PyInstaller uses a shared copyright model. Each contributor maintains copyright
over their contributions to PyInstaller. But, it is important to note that
these
contributions are typically only changes to the repositories. Thus,
the PyInstaller source code, in its entirety is not the copyright of any single
person or institution.  Instead, it is the collective copyright of the entire
PyInstaller Development Team.  If individual contributors want to maintain
a record of what changes/contributions they have specific copyright on, they
should indicate their copyright in the commit message of the change, when they
commit the change to the PyInstaller repository.

With this in mind, the following banner should be used in any source code file
to indicate the copyright and license terms:


#-----------------------------------------------------------------------------
# Copyright (c) 2005-2020, PyInstaller Development Team.
#
# Distributed under the terms of the GNU General Public License (version 2
# or later) with exception for distributing the bootloader.
#
# The full license is in the file COPYING.txt, distributed with this software.
#
# SPDX-License-Identifier: (GPL-2.0-or-later WITH Bootloader-exception)
#-----------------------------------------------------------------------------



GNU General Public License
--------------------------

https://gnu.org/licenses/gpl-2.0.html


		    GNU GENERAL PUBLIC LICENSE
		       Version 2, June 1991

 Copyright (C) 1989, 1991 Free Software Foundation, Inc.
 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA
 Everyone is permitted to copy and distribute verbatim copies
 of this license document, but changing it is not allowed.

			    Preamble

  The licenses for most software are designed to take away your
freedom to share and change it.  By contrast, the GNU General Public
License is intended to guarantee your freedom to share and change free
software--to make sure the software is free for all its users.  This
General Public License applies to most of the Free Software
Foundation's software and to any other program whose authors commit to
using it.  (Some other Free Software Foundation software is covered by
the GNU Library General Public License instead.)  You can apply it to
your programs, too.

  When we speak of free software, we are referring to freedom, not
price.  Our General Public Licenses are designed to make sure that you
have the freedom to distribute copies of free software (and charge for
this service if you wish), that you receive source code or can get it
if you want it, that you can change the software or use pieces of it
in new free programs; and that you know you can do these things.

  To protect your rights, we need to make restrictions that forbid
anyone to deny you these rights or to ask you to surrender the rights.
These restrictions translate to certain responsibilities for you if you
distribute copies of the software, or if you modify it.

  For example, if you distribute copies of such a program, whether
gratis or for a fee, you must give the recipients all the rights that
you have.  You must make sure that they, too, receive or can get the
source code.  And you must show them these terms so they know their
rights.

  We protect your rights with two steps: (1) copyright the software, and
(2) offer you this license which gives you legal permission to copy,
distribute and/or modify the software.

  Also, for each author's protection and ours, we want to make certain
that everyone understands that there is no warranty for this free
software.  If the software is modified by someone else and passed on, we
want its recipients to know that what they have is not the original, so
that any problems introduced by others will not reflect on the original
authors' reputations.

  Finally, any free program is threatened constantly by software
patents.  We wish to avoid the danger that redistributors of a free
program will individually obtain patent licenses, in effect making the
program proprietary.  To prevent this, we have made it clear that any
patent must be licensed for everyone's free use or not licensed at all.

  The precise terms and conditions for copying, distribution and
modification follow.

		    GNU GENERAL PUBLIC LICENSE
   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION

  0. This License applies to any program or other work which contains
a notice placed by the copyright holder saying it may be distributed
under the terms of this General Public License.  The "Program", below,
refers to any such program or work, and a "work based on the Program"
means either the Program or any derivative work under copyright law:
that is to say, a work containing the Program or a portion of it,
either verbatim or with modifications and/or translated into another
language.  (Hereinafter, translation is included without limitation in
the term "modification".)  Each licensee is addressed as "you".

Activities other than copying, distribution and modification are not
covered by this License; they are outside its scope.  The act of
running the Program is not restricted, and the output from the Program
is covered only if its contents constitute a work based on the
Program (independent of having been made by running the Program).
Whether that is true depends on what the Program does.

  1. You may copy and distribute verbatim copies of the Program's
source code as you receive it, in any medium, provided that you
conspicuously and appropriately publish on each copy an appropriate
copyright notice and disclaimer of warranty; keep intact all the
notices that refer to this License and to the absence of any warranty;
and give any other recipients of the Program a copy of this License
along with the Program.

You may charge a fee for the physical act of transferring a copy, and
you may at your option offer warranty protection in exchange for a fee.

  2. You may modify your copy or copies of the Program or any portion
of it, thus forming a work based on the Program, and copy and
distribute such modifications or work under the terms of Section 1
above, provided that you also meet all of these conditions:

    a) You must cause the modified files to carry prominent notices
    stating that you changed the files and the date of any change.

    b) You must cause any work that you distribute or publish, that in
    whole or in part contains or is derived from the Program or any
    part thereof, to be licensed as a whole at no charge to all third
    parties under the terms of this License.

    c) If the modified program normally reads commands interactively
    when run, you must cause it, when started running for such
    interactive use in the most ordinary way, to print or display an
    announcement including an appropriate copyright notice and a
    notice that there is no warranty (or else, saying that you provide
    a warranty) and that users may redistribute the program under
    these conditions, and telling the user how to view a copy of this
    License.  (Exception: if the Program itself is interactive but
    does not normally print such an announcement, your work based on
    the Program is not required to print an announcement.)

These requirements apply to the modified work as a whole.  If
identifiable sections of that work are not derived from the Program,
and can be reasonably considered independent and separate works in
themselves, then this License, and its terms, do not apply to those
sections when you distribute them as separate works.  But when you
distribute the same sections as part of a whole which is a work based
on the Program, the distribution of the whole must be on the terms of
this License, whose permissions for other licensees extend to the
entire whole, and thus to each and every part regardless of who wrote it.

Thus, it is not the intent of this section to claim rights or contest
your rights to work written entirely by you; rather, the intent is to
exercise the right to control the distribution of derivative or
collective works based on the Program.

In addition, mere aggregation of another work not based on the Program
with the Program (or with a work based on the Program) on a volume of
a storage or distribution medium does not bring the other work under
the scope of this License.

  3. You may copy and distribute the Program (or a work based on it,
under Section 2) in object code or executable form under the terms of
Sections 1 and 2 above provided that you also do one of the following:

    a) Accompany it with the complete corresponding machine-readable
    source code, which must be distributed under the terms of Sections
    1 and 2 above on a medium customarily used for software interchange; or,

    b) Accompany it with a written offer, valid for at least three
    years, to give any third party, for a charge no more than your
    cost of physically performing source distribution, a complete
    machine-readable copy of the corresponding source code, to be
    distributed under the terms of Sections 1 and 2 above on a medium
    customarily used for software interchange; or,

    c) Accompany it with the information you received as to the offer
    to distribute corresponding source code.  (This alternative is
    allowed only for noncommercial distribution and only if you
    received the program in object code or executable form with such
    an offer, in accord with Subsection b above.)

The source code for a work means the preferred form of the work for
making modifications to it.  For an executable work, complete source
code means all the source code for all modules it contains, plus any
associated interface definition files, plus the scripts used to
control compilation and installation of the executable.  However, as a
special exception, the source code distributed need not include
anything that is normally distributed (in either source or binary
form) with the major components (compiler, kernel, and so on) of the
operating system on which the executable runs, unless that component
itself accompanies the executable.

If distribution of executable or object code is made by offering
access to copy from a designated place, then offering equivalent
access to copy the source code from the same place counts as
distribution of the source code, even though third parties are not
compelled to copy the source along with the object code.

  4. You may not copy, modify, sublicense, or distribute the Program
except as expressly provided under this License.  Any attempt
otherwise to copy, modify, sublicense or distribute the Program is
void, and will automatically terminate your rights under this License.
However, parties who have received copies, or rights, from you under
this License will not have their licenses terminated so long as such
parties remain in full compliance.

  5. You are not required to accept this License, since you have not
signed it.  However, nothing else grants you permission to modify or
distribute the Program or its derivative works.  These actions are
prohibited by law if you do not accept this License.  Therefore, by
modifying or distributing the Program (or any work based on the
Program), you indicate your acceptance of this License to do so, and
all its terms and conditions for copying, distributing or modifying
the Program or works based on it.

  6. Each time you redistribute the Program (or any work based on the
Program), the recipient automatically receives a license from the
original licensor to copy, distribute or modify the Program subject to
these terms and conditions.  You may not impose any further
restrictions on the recipients' exercise of the rights granted herein.
You are not responsible for enforcing compliance by third parties to
this License.

  7. If, as a consequence of a court judgment or allegation of patent
infringement or for any other reason (not limited to patent issues),
conditions are imposed on you (whether by court order, agreement or
otherwise) that contradict the conditions of this License, they do not
excuse you from the conditions of this License.  If you cannot
distribute so as to satisfy simultaneously your obligations under this
License and any other pertinent obligations, then as a consequence you
may not distribute the Program at all.  For example, if a patent
license would not permit royalty-free redistribution of the Program by
all those who receive copies directly or indirectly through you, then
the only way you could satisfy both it and this License would be to
refrain entirely from distribution of the Program.

If any portion of this section is held invalid or unenforceable under
any particular circumstance, the balance of the section is intended to
apply and the section as a whole is intended to apply in other
circumstances.

It is not the purpose of this section to induce you to infringe any
patents or other property right claims or to contest validity of any
such claims; this section has the sole purpose of protecting the
integrity of the free software distribution system, which is
implemented by public license practices.  Many people have made
generous contributions to the wide range of software distributed
through that system in reliance on consistent application of that
system; it is up to the author/donor to decide if he or she is willing
to distribute software through any other system and a licensee cannot
impose that choice.

This section is intended to make thoroughly clear what is believed to
be a consequence of the rest of this License.

  8. If the distribution and/or use of the Program is restricted in
certain countries either by patents or by copyrighted interfaces, the
original copyright holder who places the Program under this License
may add an explicit geographical distribution limitation excluding
those countries, so that distribution is permitted only in or among
countries not thus excluded.  In such case, this License incorporates
the limitation as if written in the body of this License.

  9. The Free Software Foundation may publish revised and/or new versions
of the General Public License from time to time.  Such new versions will
be similar in spirit to the present version, but may differ in detail to
address new problems or concerns.

Each version is given a distinguishing version number.  If the Program
specifies a version number of this License which applies to it and "any
later version", you have the option of following the terms and conditions
either of that version or of any later version published by the Free
Software Foundation.  If the Program does not specify a version number of
this License, you may choose any version ever published by the Free Software
Foundation.

  10. If you wish to incorporate parts of the Program into other free
programs whose distribution conditions are different, write to the author
to ask for permission.  For software which is copyrighted by the Free
Software Foundation, write to the Free Software Foundation; we sometimes
make exceptions for this.  Our decision will be guided by the two goals
of preserving the free status of all derivatives of our free software and
of promoting the sharing and reuse of software generally.

			    NO WARRANTY

  11. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY
FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW.  EXCEPT WHEN
OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES
PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED
OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS
TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE
PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING,
REPAIR OR CORRECTION.

  12. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR
REDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES,
INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING
OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED
TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY
YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER
PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE
POSSIBILITY OF SUCH DAMAGES.

		     END OF TERMS AND CONDITIONS

------

** six; version 1.14.0 -- https://github.com/benjaminp/six/tree/1.14.0
Copyright (c) 2010-2020 Benjamin Peterson

Copyright (c) 2010-2020 Benjamin Peterson

Permission is hereby granted, free of charge, to any person obtaining a copy of
this software and associated documentation files (the "Software"), to deal in
the Software without restriction, including without limitation the rights to
use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
of
the Software, and to permit persons to whom the Software is furnished to do so,
subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS
FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

------

** urllib3; version 1.25.8 -- https://github.com/urllib3/urllib3/tree/1.25.8
Copyright (c) 2008-2019 Andrey Petrov and contributors (see CONTRIBUTORS.txt)

MIT License

Copyright (c) 2008-2019 Andrey Petrov and contributors (see CONTRIBUTORS.txt)

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

------

** setuptools; version 45.2.0 --
https://github.com/pypa/setuptools/tree/v45.2.0
Copyright (C) 2016 Jason R Coombs <jaraco@jaraco.com>

Permission is hereby granted, free of charge, to any person obtaining a copy of
this software and associated documentation files (the "Software"), to deal in
the Software without restriction, including without limitation the rights to
use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
of the Software, and to permit persons to whom the Software is furnished to do
so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

------

** wcwidth; version 0.1.8 -- https://github.com/jquast/wcwidth/tree/0.1.8
Copyright (c) 2014 Jeff Quast <contact@jeffquast.com>

The MIT License (MIT)

Copyright (c) 2014 Jeff Quast <contact@jeffquast.com>

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

------

** jmespath; version 0.9.4 --
https://github.com/jmespath/jmespath.py/tree/0.9.4
Copyright (c) 2013 Amazon.com, Inc. or its affiliates.  All Rights Reserved

Copyright (c) 2013 Amazon.com, Inc. or its affiliates.  All Rights Reserved

Permission is hereby granted, free of charge, to any person obtaining a
copy of this software and associated documentation files (the
"Software"), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish, dis-
tribute, sublicense, and/or sell copies of the Software, and to permit
persons to whom the Software is furnished to do so, subject to the fol-
lowing conditions:

The above copyright notice and this permission notice shall be included
in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABIL-
ITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT
SHALL THE AUTHOR BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
IN THE SOFTWARE.

------

** ruamel.yaml; version 0.15.100 --
https://sourceforge.net/p/ruamel-yaml/code/ci/default/tree/
Copyright (c) 2014-2019 Anthon van der Neut, Ruamel bvba

 The MIT License (MIT)

 Copyright (c) 2014-2020 Anthon van der Neut, Ruamel bvba

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in
 all copies or substantial portions of the Software.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 SOFTWARE.

------

** OpenSSL; version 1.0.2s --
https://github.com/openssl/openssl/tree/OpenSSL_1_0_1s
Copyright (c) 1998-2011 The OpenSSL Project.  All rights reserved.
Copyright (C) 1995-1998 Eric Young (eay@cryptsoft.com)

LICENSE ISSUES
  ==============

  The OpenSSL toolkit stays under a double license, i.e. both the conditions of
  the OpenSSL License and the original SSLeay license apply to the toolkit.
  See below for the actual license texts.

  OpenSSL License
  ---------------

/* ====================================================================
 * Copyright (c) 1998-2017 The OpenSSL Project.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. All advertising materials mentioning features or use of this
 *    software must display the following acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit. (http://www.openssl.org/)"
 *
 * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
 *    endorse or promote products derived from this software without
 *    prior written permission. For written permission, please contact
 *    openssl-core@openssl.org.
 *
 * 5. Products derived from this software may not be called "OpenSSL"
 *    nor may "OpenSSL" appear in their names without prior written
 *    permission of the OpenSSL Project.
 *
 * 6. Redistributions of any form whatsoever must retain the following
 *    acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit (http://www.openssl.org/)"
 *
 * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
 * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE.
 * ====================================================================
 *
 * This product includes cryptographic software written by Eric Young
 * (eay@cryptsoft.com).  This product includes software written by Tim
 * Hudson (tjh@cryptsoft.com).
 *
 */

 Original SSLeay License
 -----------------------

/* Copyright (C) 1995-1998 Eric Young (eay@cryptsoft.com)
 * All rights reserved.
 *
 * This package is an SSL implementation written
 * by Eric Young (eay@cryptsoft.com).
 * The implementation was written so as to conform with Netscapes SSL.
 *
 * This library is free for commercial and non-commercial use as long as
 * the following conditions are aheared to.  The following conditions
 * apply to all code found in this distribution, be it the RC4, RSA,
 * lhash, DES, etc., code; not just the SSL code.  The SSL documentation
 * included with this distribution is covered by the same copyright terms
 * except that the holder is Tim Hudson (tjh@cryptsoft.com).
 *
 * Copyright remains Eric Young's, and as such any Copyright notices in
 * the code are not to be removed.
 * If this package is used in a product, Eric Young should be given attribution
 * as the author of the parts of the library used.
 * This can be in the form of a textual message at program startup or
 * in documentation (online or textual) provided with the package.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *    "This product includes cryptographic software written by
 *     Eric Young (eay@cryptsoft.com)"
 *    The word 'cryptographic' can be left out if the rouines from the library
 *    being used are not cryptographic related :-).
 * 4. If you include any Windows specific code (or a derivative thereof) from
 * the apps directory (application code) you must include an acknowledgement:
 * "This product includes software written by Tim Hudson (tjh@cryptsoft.com)"
 *
 * THIS SOFTWARE IS PROVIDED BY ERIC YOUNG ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * The licence and distribution terms for any publically available version or
 * derivative of this code cannot be changed.  i.e. this code cannot simply be
 * copied and put under another distribution licence
 * [including the GNU Public Licence.]
 */

------

** Python 3.9.11; version 3.9.11 -- https://github.com/python/cpython/tree/v3.9.11
Copyright © 2001-2020 Python Software Foundation. All rights reserved.

PYTHON SOFTWARE FOUNDATION LICENSE VERSION 2
--------------------------------------------

1. This LICENSE AGREEMENT is between the Python Software Foundation
("PSF"), and the Individual or Organization ("Licensee") accessing and
otherwise using this software ("Python") in source or binary form and
its associated documentation.

2. Subject to the terms and conditions of this License Agreement, PSF hereby
grants Licensee a nonexclusive, royalty-free, world-wide license to reproduce,
analyze, test, perform and/or display publicly, prepare derivative works,
distribute, and otherwise use Python alone or in any derivative version,
provided, however, that PSF's License Agreement and PSF's notice of copyright,
i.e., "Copyright (c) 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009,
2010,
2011, 2012, 2013, 2014, 2015, 2016, 2017, 2018, 2019, 2020 Python Software
Foundation;
All Rights Reserved" are retained in Python alone or in any derivative version
prepared by Licensee.

3. In the event Licensee prepares a derivative work that is based on
or incorporates Python or any part thereof, and wants to make
the derivative work available to others as provided herein, then
Licensee hereby agrees to include in any such work a brief summary of
the changes made to Python.

4. PSF is making Python available to Licensee on an "AS IS"
basis.  PSF MAKES NO REPRESENTATIONS OR WARRANTIES, EXPRESS OR
IMPLIED.  BY WAY OF EXAMPLE, BUT NOT LIMITATION, PSF MAKES NO AND
DISCLAIMS ANY REPRESENTATION OR WARRANTY OF MERCHANTABILITY OR FITNESS
FOR ANY PARTICULAR PURPOSE OR THAT THE USE OF PYTHON WILL NOT
INFRINGE ANY THIRD PARTY RIGHTS.

5. PSF SHALL NOT BE LIABLE TO LICENSEE OR ANY OTHER USERS OF PYTHON
FOR ANY INCIDENTAL, SPECIAL, OR CONSEQUENTIAL DAMAGES OR LOSS AS
A RESULT OF MODIFYING, DISTRIBUTING, OR OTHERWISE USING PYTHON,
OR ANY DERIVATIVE THEREOF, EVEN IF ADVISED OF THE POSSIBILITY THEREOF.

6. This License Agreement will automatically terminate upon a material
breach of its terms and conditions.

7. Nothing in this License Agreement shall be deemed to create any
relationship of agency, partnership, or joint venture between PSF and
Licensee.  This License Agreement does not grant permission to use PSF
trademarks or trade name in a trademark sense to endorse or promote
products or services of Licensee, or any third party.

8. By copying, installing or otherwise using Python, Licensee
agrees to be bound by the terms and conditions of this License
Agreement.



------

** docutils; version 0.15.2 --
https://sourceforge.net/p/docutils/code/HEAD/tree/trunk/docutils/
:Author: David Goodger
:Contact: goodger@python.org
:Date: $Date: 2015-05-08 15:56:32 +0000 (Fri, 08 May 2015) $
:Web site: http://docutils.sourceforge.net/
:Copyright: This document has been placed in the public domain.

==================
 Copying Docutils
==================

:Author: David Goodger
:Contact: goodger@python.org
:Date: $Date: 2015-05-08 15:56:32 +0000 (Fri, 08 May 2015) $
:Web site: http://docutils.sourceforge.net/
:Copyright: This document has been placed in the public domain.

Most of the files included in this project have been placed in the
public domain, and therefore have no license requirements and no
restrictions on copying or usage; see the `Public Domain Dedication`_
below.  There are a few exceptions_, listed below.
Files in the Sandbox_ are not distributed with Docutils releases and
may have different license terms.


Public Domain Dedication
========================

The persons who have associated their work with this project (the
"Dedicator": David Goodger and the many contributors to the Docutils
project) hereby dedicate the entire copyright, less the exceptions_
listed below, in the work of authorship known as "Docutils" identified
below (the "Work") to the public domain.

The primary repository for the Work is the Internet World Wide Web
site <http://docutils.sourceforge.net/>.  The Work consists of the
files within the "docutils" module of the Docutils project Subversion
repository (Internet host docutils.svn.sourceforge.net, filesystem path
/svnroot/docutils), whose Internet web interface is located at
<http://docutils.svn.sourceforge.net/viewvc/docutils/>.  Files dedicated to the
public domain may be identified by the inclusion, near the beginning
of each file, of a declaration of the form::

    Copyright: This document/module/DTD/stylesheet/file/etc. has been
               placed in the public domain.

Dedicator makes this dedication for the benefit of the public at large
and to the detriment of Dedicator's heirs and successors.  Dedicator
intends this dedication to be an overt act of relinquishment in
perpetuity of all present and future rights under copyright law,
whether vested or contingent, in the Work.  Dedicator understands that
such relinquishment of all rights includes the relinquishment of all
rights to enforce (by lawsuit or otherwise) those copyrights in the
Work.

Dedicator recognizes that, once placed in the public domain, the Work
may be freely reproduced, distributed, transmitted, used, modified,
built upon, or otherwise exploited by anyone for any purpose,
commercial or non-commercial, and in any way, including by methods
that have not yet been invented or conceived.

(This dedication is derived from the text of the `Creative Commons
Public Domain Dedication`. [#]_)

.. [#] Creative Commons has `retired this legal tool`__ and does not
   recommend that it be applied to works: This tool is based on United
   States law and may not be applicable outside the US. For dedicating new
   works to the public domain, Creative Commons recommend the replacement
   Public Domain Dedication CC0_ (CC zero, "No Rights Reserved"). So does
   the Free Software Foundation in its license-list_.

   __  http://creativecommons.org/retiredlicenses
   .. _CC0: http://creativecommons.org/about/cc0

Exceptions
==========

The exceptions to the `Public Domain Dedication`_ above are:

* docutils/writers/s5_html/themes/default/iepngfix.htc:

      IE5.5+ PNG Alpha Fix v1.0 by Angus Turnbull
      <http://www.twinhelix.com>.  Free usage permitted as long as
      this notice remains intact.

* docutils/utils/math/__init__.py,
  docutils/utils/math/latex2mathml.py,
  docutils/writers/xetex/__init__.py,
  docutils/writers/latex2e/docutils-05-compat.sty,
  docs/user/docutils-05-compat.sty.txt,
  docutils/utils/error_reporting.py,
  docutils/test/transforms/test_smartquotes.py:

  Copyright © Günter Milde.
  Released under the terms of the `2-Clause BSD license`_
  (`local copy <licenses/BSD-2-Clause.txt>`__).

* docutils/utils/smartquotes.py

  Copyright © 2011 Günter Milde,
  based on `SmartyPants`_ © 2003 John Gruber
  (released under a 3-Clause BSD license included in the file)
  and smartypants.py © 2004, 2007 Chad Miller.
  Released under the terms of the `2-Clause BSD license`_
  (`local copy <licenses/BSD-2-Clause.txt>`__).

  .. _SmartyPants: http://daringfireball.net/projects/smartypants/

* docutils/utils/math/math2html.py,
  docutils/writers/html4css1/math.css

  Copyright © Alex Fernández
  These files are part of eLyXer_, released under the `GNU
  General Public License`_ version 3 or later. The author relicensed
  them for Docutils under the terms of the `2-Clause BSD license`_
  (`local copy <licenses/BSD-2-Clause.txt>`__).

  .. _eLyXer: http://www.nongnu.org/elyxer/

* docutils/utils/roman.py, copyright by Mark Pilgrim, released under the
  `Python 2.1.1 license`_ (`local copy`__).

  __ licenses/python-2-1-1.txt

* tools/editors/emacs/rst.el, copyright by Free Software Foundation,
  Inc., released under the `GNU General Public License`_ version 3 or
  later (`local copy`__).

  __ licenses/gpl-3-0.txt

The `2-Clause BSD license`_ and the Python licenses are OSI-approved_
and GPL-compatible_.

Plaintext versions of all the linked-to licenses are provided in the
licenses_ directory.

.. _sandbox: http://docutils.sourceforge.net/sandbox/README.html
.. _licenses: licenses/
.. _Python 2.1.1 license: http://www.python.org/2.1.1/license.html
.. _GNU General Public License: http://www.gnu.org/copyleft/gpl.html
.. _2-Clause BSD license: http://www.spdx.org/licenses/BSD-2-Clause
.. _OSI-approved: http://opensource.org/licenses/
.. _license-list:
.. _GPL-compatible: http://www.gnu.org/licenses/license-list.html// END OF FILE: aws/THIRD_PARTY_LICENSES

//---> PATH: /home/mbogneng-junior/freelance-driver_Sylladb/backend/cors.xml

<CORSConfiguration>
  <CORSRule>
    <AllowedOrigin>*</AllowedOrigin>
    <AllowedMethod>GET</AllowedMethod>
    <AllowedMethod>PUT</AllowedMethod>
    <AllowedMethod>POST</AllowedMethod>
    <AllowedMethod>DELETE</AllowedMethod>
    <AllowedHeader>*</AllowedHeader>
  </CORSRule>
</CORSConfiguration>
// END OF FILE: cors.xml

//---> PATH: /home/mbogneng-junior/freelance-driver_Sylladb/backend/docker-compose.yml

# Ce fichier ne gère QUE la base de données.
services:
  scylla-db:
    image: scylladb/scylla:latest
    container_name: scylla-node-dev
    # Expose le port 9042 du conteneur sur le port 9042 de votre machine (localhost)
    ports:
      - "9042:9042"
    command: --smp 1 --memory 1G --developer-mode 1
    volumes:
      - scylla_data:/var/lib/scylla
  minio:
    image: minio/minio:latest
    container_name: minio-dev
    ports:
      - "9000:9000"
      - "9001:9001"
    volumes:
      - minio_data:/data
    environment:
      MINIO_ROOT_USER: junioradmin 
      MINIO_ROOT_PASSWORD: YourStrongPassword2025
      # ==============================================================================
    command: server /data --console-address ":9001"

volumes:
  scylla_data:
  minio_data:// END OF FILE: docker-compose.yml

//---> PATH: /home/mbogneng-junior/freelance-driver_Sylladb/backend/docker/docker-compose-stack.yml

services:
  # SERVER: CONFIG SERVER -----------------------------------------------------------
  freelance-driver-service:
    image: ${IMAGE_TAG}
    environment:
      - SPRING_PROFILES_ACTIVE=dev-resource-mock
      - MICROSERVICES_AUTH_SERVICE_URL=https://gateway.yowyob.com/auth-service
      - MICROSERVICES_ORGANISATION_SERVICE_URL=https://gateway.yowyob.com/organization-service
      - MICROSERVICES_CHAT_SERVICE_URL=http://88.198.150.195:8613
      - MICROSERVICES_NOTIFICATION_SERVICE_URL=https://gateway.yowyob.com/notification-service
      - MICROSERVICES_RESOURCE_SERVICE_URL=https://gateway.yowyob.com/resource-service
      - MICROSERVICES_MEDIA_SERVICE_URL=https://gateway.yowyob.com/media-service
      - FREELANCE_DRIVER_API_PUBLIC_KEY=api_1752647119025_8d6e5340.ieGsWPxnE9eY0xBQ7n8htlTiQP3n4009
      - FREELANCE_DRIVER_CHAT_PROJECT_ID=25cf4dfd-e847-4b59-91c7-034aa5afc200
      - FREELANCE_DRIVER_OAUTH2_CLIENT_ID=test-client
      - FREELANCE_DRIVER_OAUTH2_CLIENT_SECRET=secret
      - FREELANCE_DRIVER_OAUTH2_TOKEN_URL=https://gateway.yowyob.com/auth-service/oauth/token
      - SPRING_SECURITY_OAUTH2_RESOURCESERVER_JWK_URI=https://gateway.yowyob.com/auth-service/openid/.well-known/jwks.json
      - SPRING_DEVTOOLS_RESTART_ENABLED=true
      - SPRING_DATA_CASSANDRA_REQUEST_TIMEOUT=20s
      - SPRING_DATA_CASSANDRA_CONNECTION_CONNECT_TIMEOUT=20s
      - SPRING_DATA_CASSANDRA_CONNECTION_INIT_QUERY_TIMEOUT=20s
      - SPRING_MAIL_HOST=smtp.gmail.com
      - SPRING_MAIL_PORT=587
      - SPRING_MAIL_USERNAME=mbognengj@gmail.com
      - SPRING_MAIL_PASSWORD=fmpjyadvpepfvcws
      - SPRING_MAIL_PROPERTIES_MAIL_SMTP_AUTH=true
      - SPRING_MAIL_PROPERTIES_MAIL_SMTP_STARTTLS_ENABLE=true
      - SPRING_MAIL_PROPERTIES_MAIL_DEBUG=true
      - MINIO_ENDPOINT=http://192.168.43.204:9000
      - MINIO_ACCESS_KEY=junioradmin
      - MINIO_SECRET_KEY=YourStrongPassword2025
      - MINIO_BUCKET_NAME=freelance-driver
      - SOCKETIO_SERVER_HOST=0.0.0.0
      - SOCKETIO_SERVER_PORT=8081
      - SPRING_DATA_CASSANDRA_DATACENTER=DC1
      - SPRING_DATA_CASSANDRA_KEYSPACE=${FREELANCE_DRIVER_KEYSPACE}
      - SPRING_DATA_CASSANDRA_CONTACT_POINTS=${SCYLLA_DB_CONTACT_POINTS}
      - SPRING_DATA_CASSANDRA_PORT=9042
    ports:
      - target: 8080
        published: ${FREELANCE_DRIVER_SERVICE_PORT}
        protocol: tcp
        mode: host
      - target: 8081
        published: ${FREELANCE_DRIVER_WS_PORT}
        protocol: tcp
        mode: host
    networks:
      - openia-main-network

networks:
  openia-main-network:
    external: true
// END OF FILE: docker/docker-compose-stack.yml

//---> PATH: /home/mbogneng-junior/freelance-driver_Sylladb/backend/docker/docker-compose.yml

services:
  organization-service:
    image: yowyob/organization-service
    container_name: yowyob-organization-service
    build:
      context: ../
      dockerfile: docker/Dockerfile
    environment:
      - CONFIG_SERVER_URL=${CONFIG_SERVER_URL}
    networks:
      - openia-main-network
    ports:
      - 8089:8080
# NETWORKS ------------------------------------------------------------------------
networks:
  openia-main-network:
    external: true// END OF FILE: docker/docker-compose.yml

//---> PATH: /home/mbogneng-junior/freelance-driver_Sylladb/backend/docker/Dockerfile

FROM openjdk:21-slim

ARG JAVA_OPTS
ARG SPRING_PROFILES_ACTIVE=development

ENV JAVA_OPTS=$JAVA_OPTS
ENV SPRING_PROFILES_ACTIVE=$SPRING_PROFILES_ACTIVE
ENV SERVICE_NAME=freelance-driver-service
ARG JAR_FILE=target/*.jar
ADD ${JAR_FILE} ${SERVICE_NAME}.jar

EXPOSE 8080 8081

ENTRYPOINT ["sh", "-c", "java $JAVA_OPTS -DSPRING_PROFILES_ACTIVE=$SPRING_PROFILES_ACTIVE -jar $SERVICE_NAME.jar"]
// END OF FILE: docker/Dockerfile

//---> PATH: /home/mbogneng-junior/freelance-driver_Sylladb/backend/.env

# Ce fichier est auto-généré par init_application.sh
SYSTEM_ORGANIZATION_ID=73ba467d-9b2e-481a-827e-edbddc4f775d
SMTP_SETTING_ID=bf1cc922-3e8c-4dd5-b6fb-7a69c0ba0250
FIREBASE_SETTING_ID=c3389947-110e-4f79-925c-ce19072a6e2a
DESIGN_EMAIL_OTP_ID=d11ef854-3b00-44aa-b4ad-c889806664c4
TEMPLATE_EMAIL_OTP_ID=99f0fa9f-80bd-4e54-8385-a3e0dee99770
TEMPLATE_PUSH_NEW_PLANNING_ID=c4af6e04-2dd8-4e58-9895-140cf3f6fa96
TEMPLATE_PUSH_NEW_ANNOUNCEMENT_ID=d77bd848-e94c-4a6d-985c-e1d7688928d6
TEMPLATE_PUSH_ANNOUNCEMENT_ACCEPTED_ID=1a7b8f5c-2d3e-4f6a-8b9c-0a1b2c3d4e5f
TEMPLATE_PUSH_ANNOUNCEMENT_CONFIRMED_ID=4a1b2c3d-4e5f-6a7b-8c9d-0e1f2a3b4c5d
TEMPLATE_PUSH_POSTULATION_CANCELLED_ID=b1c2d3e4-f5a6-7b8c-9d0e-1f2a3b4c5d6e
TEMPLATE_PUSH_PLANNING_BOOKING_REQUESTED_TO_DRIVER_ID=0a1b2c3d-4e5f-6a7b-8c9d-0e1f2a3b4c5d
TEMPLATE_PUSH_PLANNING_BOOKING_ACCEPTED_TO_CLIENT_ID=f1e2d3c4-b5a6-7890-1234-567890abcde0
TEMPLATE_PUSH_PLANNING_RESERVATION_CANCELLED_ID=1b2c3d4e-5f6a-7b8c-9d0e-1f2a3b4c5d6e// END OF FILE: .env

//---> PATH: /home/mbogneng-junior/freelance-driver_Sylladb/backend/.gitattributes

/mvnw text eol=lf
*.cmd text eol=crlf
// END OF FILE: .gitattributes

//---> PATH: /home/mbogneng-junior/freelance-driver_Sylladb/backend/.gitignore

HELP.md
target/
build/
.mvn/wrapper/maven-wrapper.jar
!**/src/main/**/target/
!**/src/test/**/target/
!**/src/main/**/build/
!**/src/test/**/build/
aws/

### STS ###
.apt_generated
.classpath
.factorypath
.project
.settings
.springBeans
.sts4-cache

### IntelliJ IDEA ###
.idea/
*.iws
*.iml
*.ipr

### NetBeans ###
/nbproject/private/
/nbbuild/
/dist/
/nbdist/
/.nb-gradle/

### VS Code ###
.vscode/

# OS files
.DS_Store
Thumbs.db

# Logs
*.log

# Gradle
.gradle/

# Maven
.mvn/

# Firebase/Secrets
/src/main/resources/firebase-service-account-key.json

// END OF FILE: .gitignore

//---> PATH: /home/mbogneng-junior/freelance-driver_Sylladb/backend/gitlab-ci/build.gitlab-ci.yml

build:
  stage: build
  tags: [yowyob]
  script:
    - cp src/main/resources/firebase-service-account-key.example src/main/resources/firebase-service-account-key.json
    - mvn $MAVEN_CLI_OPTS compile// END OF FILE: gitlab-ci/build.gitlab-ci.yml

//---> PATH: /home/mbogneng-junior/freelance-driver_Sylladb/backend/gitlab-ci/ci_settings.xml

<settings xmlns="http://maven.apache.org/SETTINGS/1.1.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://maven.apache.org/SETTINGS/1.1.0 http://maven.apache.org/xsd/settings-1.1.0.xsd">
  <servers>
    <server>
      <id>gitlab-maven</id>
      <username>${CI_INC_GROUP_DEPLOY_USER}</username>
      <password>${CI_INC_GROUP_DEPLOY_TOKEN}</password>
      <configuration>
        <authenticationInfo>
          <userName>${CI_INC_GROUP_DEPLOY_USER}</userName>
          <password>${CI_INC_GROUP_DEPLOY_TOKEN}</password>
        </authenticationInfo>
        <httpHeaders>
          <property>
            <name>${CI_INC_GROUP_DEPLOY_USER}</name>
            <value>${CI_INC_GROUP_DEPLOY_TOKEN}</value>
          </property>
        </httpHeaders>
      </configuration>
    </server>
  </servers>
</settings>// END OF FILE: gitlab-ci/ci_settings.xml

//---> PATH: /home/mbogneng-junior/freelance-driver_Sylladb/backend/gitlab-ci/deploy.gitlab-ci.yml

deploy:
  stage: deploy
  tags: [yowyob-cmd]
  dependencies:
    - docker-build
  before_script:
    - echo "$CI_REGISTRY_PASSWORD" | docker login "$CI_REGISTRY" -u "$CI_REGISTRY_USER" --password-stdin
  script:
    - docker pull "$IMAGE_TAG" || true
    - docker service rm "${SERVICE_STACK_NAME}_freelance-driver" || true
    - docker stack deploy -c docker/docker-compose-stack.yml "$SERVICE_STACK_NAME" --with-registry-auth
  rules:
    - if: '$CI_COMMIT_REF_NAME == "master"'
      variables:
        DEPLOYMENT_ENVIRONMENT: "production"
        ENVIRONMENT: "production"
    - when: always

// END OF FILE: gitlab-ci/deploy.gitlab-ci.yml

//---> PATH: /home/mbogneng-junior/freelance-driver_Sylladb/backend/gitlab-ci/docker-build.gitlab-ci.yml

docker-build:
  stage: docker-build
  tags: [yowyob-cmd]
  dependencies:
    - package
  script:
    - echo "Deploying to $SPRING_PROFILES_ACTIVE environment..."
    - echo "$CI_REGISTRY_PASSWORD" | docker login $CI_REGISTRY -u "$CI_REGISTRY_USER" --password-stdin
    - docker rmi "$IMAGE_TAG" || true
    - >-
      docker buildx build .
      --file docker/Dockerfile
      --no-cache
      --build-arg JAVA_OPTS="$JAVA_OPTS"
      --build-arg SPRING_PROFILES_ACTIVE="$SPRING_PROFILES_ACTIVE"
      --tag $IMAGE_TAG
      --push
    - docker image prune --force
    - echo "Deployment complete"
  rules:
    - if: '$CI_COMMIT_REF_NAME == "master"'
      variables:
        SPRING_PROFILES_ACTIVE: "production"// END OF FILE: gitlab-ci/docker-build.gitlab-ci.yml

//---> PATH: /home/mbogneng-junior/freelance-driver_Sylladb/backend/gitlab-ci/general.gitlab-ci.yml

variables:
  ENV_NAME: $CI_COMMIT_BRANCH
  GIT_STRATEGY: clone
  GIT_SUBMODULE_STRATEGY: recursive
  SPRING_PROFILES_ACTIVE: production
  MAVEN_OPTS: >-
    -Dmaven.repo.local=.m2/repository
  MAVEN_CLI_OPTS: >-
    -DskipTests
    -s gitlab-ci/ci_settings.xml

before_script:
  - |
    echo "Attempting to remove packages with groupId $REMOVE_GROUP_ID from Maven cache"
    if [ -d ".m2/repository/${REMOVE_GROUP_ID//./\/}" ]; then
      find .m2/repository/${REMOVE_GROUP_ID//./\/} -type d -exec rm -rf {} + 2>/dev/null || true
      echo "Packages removed successfully"
    else
      echo "Directory .m2/repository/${REMOVE_GROUP_ID//./\/} not found. Nothing to remove."
    fi
 

image: maven:latest
cache:
  paths:
    - .m2/repository

stages:
  - build
  - package
  - docker-build
  - deploy// END OF FILE: gitlab-ci/general.gitlab-ci.yml

//---> PATH: /home/mbogneng-junior/freelance-driver_Sylladb/backend/gitlab-ci/package.gitlab-ci.yml

package:
  stage: package
  tags: [yowyob]
  dependencies:
    - build
  script:
    - cp src/main/resources/firebase-service-account-key.example src/main/resources/firebase-service-account-key.json
    - mvn $MAVEN_CLI_OPTS clean compile install
    - mvn $MAVEN_CLI_OPTS deploy -DretryFailedDeploymentCount=3
  artifacts:
    paths:
      - target/*.jar
  only:
    - master
    - dev// END OF FILE: gitlab-ci/package.gitlab-ci.yml

//---> PATH: /home/mbogneng-junior/freelance-driver_Sylladb/backend/.gitlab-ci.yml

include:
  - local: "/gitlab-ci/general.gitlab-ci.yml"
  - local: "/gitlab-ci/build.gitlab-ci.yml"
  - local: "/gitlab-ci/docker-build.gitlab-ci.yml"
  - local: "/gitlab-ci/package.gitlab-ci.yml"
  - local: "/gitlab-ci/deploy.gitlab-ci.yml"
// END OF FILE: .gitlab-ci.yml

//---> PATH: /home/mbogneng-junior/freelance-driver_Sylladb/backend/init_application.sh

#!/bin/bash

# ==============================================================================
#           SCRIPT D'INITIALISATION DE L'ENVIRONNEMENT FREELANCE DRIVER
# Ce script configure une organisation système par défaut et tous les templates
# de notification nécessaires au fonctionnement de l'application.
#
# USAGE :
# 1. Assurez-vous que vos conteneurs Docker (ScyllaDB, MinIO) sont en cours d'exécution.
# 2. Assurez-vous que votre backend Spring Boot est en cours d'exécution sur le port 8080.
# 3. Rendez ce script exécutable une fois avec : chmod +x init_application.sh
# 4. Exécutez ce script depuis la racine de votre projet : ./init_application.sh
# ==============================================================================

echo "🚀 Démarrage du script d'initialisation de l'application..."

# --- CONFIGURATION PRINCIPALE ---
# On utilise des UUIDs constants et prédéfinis.
# Ces IDs DOIVENT correspondre à ceux définis dans le code Java (ex: NotificationTriggerService).
SYS_ORG_ID="73ba467d-9b2e-481a-827e-edbddc4f775d"
SMTP_SETTING_ID="bf1cc922-3e8c-4dd5-b6fb-7a69c0ba0250"
FIREBASE_SETTING_ID="c3389947-110e-4f79-925c-ce19072a6e2a"

DESIGN_EMAIL_OTP_ID="d11ef854-3b00-44aa-b4ad-c889806664c4"
TEMPLATE_EMAIL_OTP_ID="99f0fa9f-80bd-4e54-8385-a3e0dee99770"

TEMPLATE_PUSH_NEW_PLANNING_ID="c4af6e04-2dd8-4e58-9895-140cf3f6fa96"
TEMPLATE_PUSH_NEW_ANNOUNCEMENT_ID="d77bd848-e94c-4a6d-985c-e1d7688928d6"
TEMPLATE_PUSH_ANNOUNCEMENT_ACCEPTED_ID="1a7b8f5c-2d3e-4f6a-8b9c-0a1b2c3d4e5f"

API_BASE_URL="http://localhost:8080"
ENV_FILE=".env"

# --- FONCTIONS UTILITAIRES ---
log_step() { echo -e "\n🔷 --- ÉTAPE $1: $2 ---"; }
# Fonction pour afficher la réponse JSON de manière lisible (nécessite l'outil 'jq')
log_response() { 
    if command -v jq &> /dev/null; then
        echo -e "  ➡️  Réponse:\n$(echo "$1" | jq .)\n"
    else
        echo -e "  ➡️  Réponse (brute):\n$1\n"
    fi
}
log_success() { echo -e "✅ $1"; }
log_error() { echo -e "❌ ERREUR: $1"; exit 1; }

# ==============================================================================
#                         DÉBUT DU SCRIPT
# ==============================================================================

log_step 1 "Création du fichier de configuration .env..."
rm -f $ENV_FILE
touch $ENV_FILE
{
    echo "# Ce fichier est auto-généré par init_application.sh"
    echo "SYSTEM_ORGANIZATION_ID=$SYS_ORG_ID"
    echo "SMTP_SETTING_ID=$SMTP_SETTING_ID"
    echo "FIREBASE_SETTING_ID=$FIREBASE_SETTING_ID"
    echo "DESIGN_EMAIL_OTP_ID=$DESIGN_EMAIL_OTP_ID"
    echo "TEMPLATE_EMAIL_OTP_ID=$TEMPLATE_EMAIL_OTP_ID"
    echo "TEMPLATE_PUSH_NEW_PLANNING_ID=$TEMPLATE_PUSH_NEW_PLANNING_ID"
    echo "TEMPLATE_PUSH_NEW_ANNOUNCEMENT_ID=$TEMPLATE_PUSH_NEW_ANNOUNCEMENT_ID"
    echo "TEMPLATE_PUSH_ANNOUNCEMENT_ACCEPTED_ID=$TEMPLATE_PUSH_ANNOUNCEMENT_ACCEPTED_ID"
} >> $ENV_FILE
log_success "Fichier .env créé avec toutes les IDs de configuration."

# --- INSERTION DIRECTE EN BASE DE DONNÉES ---
log_step 2 "Insertion de l'organisation 'Système' dans la base de données..."
docker exec -it scylla-node-dev cqlsh -e "INSERT INTO freelancebd.mock_organisations (organization_id, long_name, description) VALUES ($SYS_ORG_ID, 'System Default', 'Organisation par défaut pour les templates globaux');"
if [ $? -ne 0 ]; then log_error "Échec de l'insertion de l'organisation système dans ScyllaDB."; fi
log_success "Organisation 'Système' insérée/mise à jour dans la base de données."

# --- CRÉATION DES TEMPLATES VIA L'API ---
log_step 3 "Configuration des templates de notification via l'API..."

# 3.1 Création du Setting SMTP
SMTP_PAYLOAD="{ \"id\": \"$SMTP_SETTING_ID\", \"host\": \"smtp.gmail.com\", \"port\": 587, \"encryption\": \"TLS\", \"username\": \"mbognengj@gmail.com\", \"password\": \"VOTRE_MOT_DE_PASSE_APPLICATION_GMAIL\", \"sender_email\": \"no-reply@freelancedriver.com\", \"sender_name\": \"Freelance Driver App\" }"
echo "  Requête POST vers /smtp-settings"
SMTP_RESPONSE=$(curl -s -X POST "${API_BASE_URL}/api/mock-notifications/${SYS_ORG_ID}/smtp-settings" -H "Content-Type: application/json" -d "$SMTP_PAYLOAD")
log_response "$SMTP_RESPONSE"
log_success "Template SMTP créé/mis à jour."

# 3.2 Création du Setting Firebase
FIREBASE_KEY_JSON=$(cat src/main/resources/firebase-service-account-key.json | tr -d '\n\r' | sed 's/"/\\"/g')
FIREBASE_PAYLOAD="{ \"id\": \"$FIREBASE_SETTING_ID\", \"projectId\": \"freelance-driver-app\", \"privateKey\": \"$FIREBASE_KEY_JSON\" }"
echo "  Requête POST vers /firebase-settings"
FIREBASE_RESPONSE=$(curl -s -X POST "${API_BASE_URL}/api/mock-notifications/${SYS_ORG_ID}/firebase-settings" -H "Content-Type: application/json" -d "$FIREBASE_PAYLOAD")
log_response "$FIREBASE_RESPONSE"
log_success "Template Firebase créé/mis à jour."

# 3.3 Création du Design de l'email OTP
DESIGN_OTP_PAYLOAD="{ \"id\": \"$DESIGN_EMAIL_OTP_ID\", \"title\": \"Email OTP\", \"subject\": \"Votre code de vérification : [[\${otpCode}]]\", \"html\": \"<!DOCTYPE html><html xmlns:th=\\\"http://www.thymeleaf.org\\\"><body><h1>Bonjour <span th:text=\\\"\${firstName}\\\"></span>,</h1><p>Votre code de vérification est :</p><h2 style='color: #007AFF;' th:text=\\\"\${otpCode}\\\"></h2></body></html>\" }"
echo "  Requête POST vers /design-templates (OTP)"
DESIGN_OTP_RESPONSE=$(curl -s -X POST "${API_BASE_URL}/api/mock-notifications/${SYS_ORG_ID}/design-templates" -H "Content-Type: application/json" -d "$DESIGN_OTP_PAYLOAD")
log_response "$DESIGN_OTP_RESPONSE"
log_success "DesignTemplate (OTP) créé/mis à jour."

# 3.4 Création de l'EmailTemplate (Règle d'envoi OTP)
EMAIL_OTP_PAYLOAD="{ \"id\": \"$TEMPLATE_EMAIL_OTP_ID\", \"setting_id\": \"$SMTP_SETTING_ID\", \"design_template_id\": \"$DESIGN_EMAIL_OTP_ID\", \"title\": \"Règle envoi OTP\" }"
echo "  Requête POST vers /email-templates (OTP)"
EMAIL_OTP_RESPONSE=$(curl -s -X POST "${API_BASE_URL}/api/mock-notifications/${SYS_ORG_ID}/email-templates" -H "Content-Type: application/json" -d "$EMAIL_OTP_PAYLOAD")
log_response "$EMAIL_OTP_RESPONSE"
log_success "EmailTemplate (OTP) créé/mis à jour."

# 3.5 Création des PushTemplates
PUSH_NEW_PLANNING_PAYLOAD="{ \"id\": \"$TEMPLATE_PUSH_NEW_PLANNING_ID\", \"settingId\": \"$FIREBASE_SETTING_ID\", \"title\": \"Nouveau planning disponible !\", \"body\": \"Le chauffeur {{driverName}} propose un trajet vers {{destination}} à {{cost}} FCFA.\" }"
echo "  Requête POST vers /push-templates (New Planning)"
PUSH_NEW_PLANNING_RESPONSE=$(curl -s -X POST "${API_BASE_URL}/api/mock-notifications/${SYS_ORG_ID}/push-templates" -H "Content-Type: application/json" -d "$PUSH_NEW_PLANNING_PAYLOAD")
log_response "$PUSH_NEW_PLANNING_RESPONSE"
log_success "PushTemplate (New Planning) créé/mis à jour."

PUSH_NEW_ANNOUNCEMENT_PAYLOAD="{ \"id\": \"$TEMPLATE_PUSH_NEW_ANNOUNCEMENT_ID\", \"settingId\": \"$FIREBASE_SETTING_ID\", \"title\": \"Nouvelle course client !\", \"body\": \"Un client a posté un nouveau trajet : {{tripTitle}}\" }"
echo "  Requête POST vers /push-templates (New Announcement)"
PUSH_NEW_ANNOUNCEMENT_RESPONSE=$(curl -s -X POST "${API_BASE_URL}/api/mock-notifications/${SYS_ORG_ID}/push-templates" -H "Content-Type: application/json" -d "$PUSH_NEW_ANNOUNCEMENT_PAYLOAD")
log_response "$PUSH_NEW_ANNOUNCEMENT_RESPONSE"
log_success "PushTemplate (New Announcement) créé/mis à jour."

PUSH_ACCEPTED_PAYLOAD="{ \"id\": \"$TEMPLATE_PUSH_ANNOUNCEMENT_ACCEPTED_ID\", \"settingId\": \"$FIREBASE_SETTING_ID\", \"title\": \"Votre course a un chauffeur !\", \"body\": \"Le chauffeur {{driverName}} a accepté votre trajet \\\"{{tripTitle}}\\\". Appuyez pour voir son profil.\" }"
echo "  Requête POST vers /push-templates (Announcement Accepted)"
PUSH_ACCEPTED_RESPONSE=$(curl -s -X POST "${API_BASE_URL}/api/mock-notifications/${SYS_ORG_ID}/push-templates" -H "Content-Type: application/json" -d "$PUSH_ACCEPTED_PAYLOAD")
log_response "$PUSH_ACCEPTED_RESPONSE"
log_success "PushTemplate (Announcement Accepted) créé/mis à jour."


echo -e "\n🎉 --- INITIALISATION TERMINÉE ---"
echo "Le fichier '$ENV_FILE' a été créé/mis à jour avec succès."
echo "Veuillez REDÉMARRER votre backend Java pour qu'il prenne en compte les nouvelles variables d'environnement."// END OF FILE: init_application.sh

//---> PATH: /home/mbogneng-junior/freelance-driver_Sylladb/backend/mvnw

#!/bin/sh
# ----------------------------------------------------------------------------
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.
# ----------------------------------------------------------------------------

# ----------------------------------------------------------------------------
# Apache Maven Wrapper startup batch script, version 3.3.2
#
# Optional ENV vars
# -----------------
#   JAVA_HOME - location of a JDK home dir, required when download maven via java source
#   MVNW_REPOURL - repo url base for downloading maven distribution
#   MVNW_USERNAME/MVNW_PASSWORD - user and password for downloading maven
#   MVNW_VERBOSE - true: enable verbose log; debug: trace the mvnw script; others: silence the output
# ----------------------------------------------------------------------------

set -euf
[ "${MVNW_VERBOSE-}" != debug ] || set -x

# OS specific support.
native_path() { printf %s\\n "$1"; }
case "$(uname)" in
CYGWIN* | MINGW*)
  [ -z "${JAVA_HOME-}" ] || JAVA_HOME="$(cygpath --unix "$JAVA_HOME")"
  native_path() { cygpath --path --windows "$1"; }
  ;;
esac

# set JAVACMD and JAVACCMD
set_java_home() {
  # For Cygwin and MinGW, ensure paths are in Unix format before anything is touched
  if [ -n "${JAVA_HOME-}" ]; then
    if [ -x "$JAVA_HOME/jre/sh/java" ]; then
      # IBM's JDK on AIX uses strange locations for the executables
      JAVACMD="$JAVA_HOME/jre/sh/java"
      JAVACCMD="$JAVA_HOME/jre/sh/javac"
    else
      JAVACMD="$JAVA_HOME/bin/java"
      JAVACCMD="$JAVA_HOME/bin/javac"

      if [ ! -x "$JAVACMD" ] || [ ! -x "$JAVACCMD" ]; then
        echo "The JAVA_HOME environment variable is not defined correctly, so mvnw cannot run." >&2
        echo "JAVA_HOME is set to \"$JAVA_HOME\", but \"\$JAVA_HOME/bin/java\" or \"\$JAVA_HOME/bin/javac\" does not exist." >&2
        return 1
      fi
    fi
  else
    JAVACMD="$(
      'set' +e
      'unset' -f command 2>/dev/null
      'command' -v java
    )" || :
    JAVACCMD="$(
      'set' +e
      'unset' -f command 2>/dev/null
      'command' -v javac
    )" || :

    if [ ! -x "${JAVACMD-}" ] || [ ! -x "${JAVACCMD-}" ]; then
      echo "The java/javac command does not exist in PATH nor is JAVA_HOME set, so mvnw cannot run." >&2
      return 1
    fi
  fi
}

# hash string like Java String::hashCode
hash_string() {
  str="${1:-}" h=0
  while [ -n "$str" ]; do
    char="${str%"${str#?}"}"
    h=$(((h * 31 + $(LC_CTYPE=C printf %d "'$char")) % 4294967296))
    str="${str#?}"
  done
  printf %x\\n $h
}

verbose() { :; }
[ "${MVNW_VERBOSE-}" != true ] || verbose() { printf %s\\n "${1-}"; }

die() {
  printf %s\\n "$1" >&2
  exit 1
}

trim() {
  # MWRAPPER-139:
  #   Trims trailing and leading whitespace, carriage returns, tabs, and linefeeds.
  #   Needed for removing poorly interpreted newline sequences when running in more
  #   exotic environments such as mingw bash on Windows.
  printf "%s" "${1}" | tr -d '[:space:]'
}

# parse distributionUrl and optional distributionSha256Sum, requires .mvn/wrapper/maven-wrapper.properties
while IFS="=" read -r key value; do
  case "${key-}" in
  distributionUrl) distributionUrl=$(trim "${value-}") ;;
  distributionSha256Sum) distributionSha256Sum=$(trim "${value-}") ;;
  esac
done <"${0%/*}/.mvn/wrapper/maven-wrapper.properties"
[ -n "${distributionUrl-}" ] || die "cannot read distributionUrl property in ${0%/*}/.mvn/wrapper/maven-wrapper.properties"

case "${distributionUrl##*/}" in
maven-mvnd-*bin.*)
  MVN_CMD=mvnd.sh _MVNW_REPO_PATTERN=/maven/mvnd/
  case "${PROCESSOR_ARCHITECTURE-}${PROCESSOR_ARCHITEW6432-}:$(uname -a)" in
  *AMD64:CYGWIN* | *AMD64:MINGW*) distributionPlatform=windows-amd64 ;;
  :Darwin*x86_64) distributionPlatform=darwin-amd64 ;;
  :Darwin*arm64) distributionPlatform=darwin-aarch64 ;;
  :Linux*x86_64*) distributionPlatform=linux-amd64 ;;
  *)
    echo "Cannot detect native platform for mvnd on $(uname)-$(uname -m), use pure java version" >&2
    distributionPlatform=linux-amd64
    ;;
  esac
  distributionUrl="${distributionUrl%-bin.*}-$distributionPlatform.zip"
  ;;
maven-mvnd-*) MVN_CMD=mvnd.sh _MVNW_REPO_PATTERN=/maven/mvnd/ ;;
*) MVN_CMD="mvn${0##*/mvnw}" _MVNW_REPO_PATTERN=/org/apache/maven/ ;;
esac

# apply MVNW_REPOURL and calculate MAVEN_HOME
# maven home pattern: ~/.m2/wrapper/dists/{apache-maven-<version>,maven-mvnd-<version>-<platform>}/<hash>
[ -z "${MVNW_REPOURL-}" ] || distributionUrl="$MVNW_REPOURL$_MVNW_REPO_PATTERN${distributionUrl#*"$_MVNW_REPO_PATTERN"}"
distributionUrlName="${distributionUrl##*/}"
distributionUrlNameMain="${distributionUrlName%.*}"
distributionUrlNameMain="${distributionUrlNameMain%-bin}"
MAVEN_USER_HOME="${MAVEN_USER_HOME:-${HOME}/.m2}"
MAVEN_HOME="${MAVEN_USER_HOME}/wrapper/dists/${distributionUrlNameMain-}/$(hash_string "$distributionUrl")"

exec_maven() {
  unset MVNW_VERBOSE MVNW_USERNAME MVNW_PASSWORD MVNW_REPOURL || :
  exec "$MAVEN_HOME/bin/$MVN_CMD" "$@" || die "cannot exec $MAVEN_HOME/bin/$MVN_CMD"
}

if [ -d "$MAVEN_HOME" ]; then
  verbose "found existing MAVEN_HOME at $MAVEN_HOME"
  exec_maven "$@"
fi

case "${distributionUrl-}" in
*?-bin.zip | *?maven-mvnd-?*-?*.zip) ;;
*) die "distributionUrl is not valid, must match *-bin.zip or maven-mvnd-*.zip, but found '${distributionUrl-}'" ;;
esac

# prepare tmp dir
if TMP_DOWNLOAD_DIR="$(mktemp -d)" && [ -d "$TMP_DOWNLOAD_DIR" ]; then
  clean() { rm -rf -- "$TMP_DOWNLOAD_DIR"; }
  trap clean HUP INT TERM EXIT
else
  die "cannot create temp dir"
fi

mkdir -p -- "${MAVEN_HOME%/*}"

# Download and Install Apache Maven
verbose "Couldn't find MAVEN_HOME, downloading and installing it ..."
verbose "Downloading from: $distributionUrl"
verbose "Downloading to: $TMP_DOWNLOAD_DIR/$distributionUrlName"

# select .zip or .tar.gz
if ! command -v unzip >/dev/null; then
  distributionUrl="${distributionUrl%.zip}.tar.gz"
  distributionUrlName="${distributionUrl##*/}"
fi

# verbose opt
__MVNW_QUIET_WGET=--quiet __MVNW_QUIET_CURL=--silent __MVNW_QUIET_UNZIP=-q __MVNW_QUIET_TAR=''
[ "${MVNW_VERBOSE-}" != true ] || __MVNW_QUIET_WGET='' __MVNW_QUIET_CURL='' __MVNW_QUIET_UNZIP='' __MVNW_QUIET_TAR=v

# normalize http auth
case "${MVNW_PASSWORD:+has-password}" in
'') MVNW_USERNAME='' MVNW_PASSWORD='' ;;
has-password) [ -n "${MVNW_USERNAME-}" ] || MVNW_USERNAME='' MVNW_PASSWORD='' ;;
esac

if [ -z "${MVNW_USERNAME-}" ] && command -v wget >/dev/null; then
  verbose "Found wget ... using wget"
  wget ${__MVNW_QUIET_WGET:+"$__MVNW_QUIET_WGET"} "$distributionUrl" -O "$TMP_DOWNLOAD_DIR/$distributionUrlName" || die "wget: Failed to fetch $distributionUrl"
elif [ -z "${MVNW_USERNAME-}" ] && command -v curl >/dev/null; then
  verbose "Found curl ... using curl"
  curl ${__MVNW_QUIET_CURL:+"$__MVNW_QUIET_CURL"} -f -L -o "$TMP_DOWNLOAD_DIR/$distributionUrlName" "$distributionUrl" || die "curl: Failed to fetch $distributionUrl"
elif set_java_home; then
  verbose "Falling back to use Java to download"
  javaSource="$TMP_DOWNLOAD_DIR/Downloader.java"
  targetZip="$TMP_DOWNLOAD_DIR/$distributionUrlName"
  cat >"$javaSource" <<-END
	public class Downloader extends java.net.Authenticator
	{
	  protected java.net.PasswordAuthentication getPasswordAuthentication()
	  {
	    return new java.net.PasswordAuthentication( System.getenv( "MVNW_USERNAME" ), System.getenv( "MVNW_PASSWORD" ).toCharArray() );
	  }
	  public static void main( String[] args ) throws Exception
	  {
	    setDefault( new Downloader() );
	    java.nio.file.Files.copy( java.net.URI.create( args[0] ).toURL().openStream(), java.nio.file.Paths.get( args[1] ).toAbsolutePath().normalize() );
	  }
	}
	END
  # For Cygwin/MinGW, switch paths to Windows format before running javac and java
  verbose " - Compiling Downloader.java ..."
  "$(native_path "$JAVACCMD")" "$(native_path "$javaSource")" || die "Failed to compile Downloader.java"
  verbose " - Running Downloader.java ..."
  "$(native_path "$JAVACMD")" -cp "$(native_path "$TMP_DOWNLOAD_DIR")" Downloader "$distributionUrl" "$(native_path "$targetZip")"
fi

# If specified, validate the SHA-256 sum of the Maven distribution zip file
if [ -n "${distributionSha256Sum-}" ]; then
  distributionSha256Result=false
  if [ "$MVN_CMD" = mvnd.sh ]; then
    echo "Checksum validation is not supported for maven-mvnd." >&2
    echo "Please disable validation by removing 'distributionSha256Sum' from your maven-wrapper.properties." >&2
    exit 1
  elif command -v sha256sum >/dev/null; then
    if echo "$distributionSha256Sum  $TMP_DOWNLOAD_DIR/$distributionUrlName" | sha256sum -c >/dev/null 2>&1; then
      distributionSha256Result=true
    fi
  elif command -v shasum >/dev/null; then
    if echo "$distributionSha256Sum  $TMP_DOWNLOAD_DIR/$distributionUrlName" | shasum -a 256 -c >/dev/null 2>&1; then
      distributionSha256Result=true
    fi
  else
    echo "Checksum validation was requested but neither 'sha256sum' or 'shasum' are available." >&2
    echo "Please install either command, or disable validation by removing 'distributionSha256Sum' from your maven-wrapper.properties." >&2
    exit 1
  fi
  if [ $distributionSha256Result = false ]; then
    echo "Error: Failed to validate Maven distribution SHA-256, your Maven distribution might be compromised." >&2
    echo "If you updated your Maven version, you need to update the specified distributionSha256Sum property." >&2
    exit 1
  fi
fi

# unzip and move
if command -v unzip >/dev/null; then
  unzip ${__MVNW_QUIET_UNZIP:+"$__MVNW_QUIET_UNZIP"} "$TMP_DOWNLOAD_DIR/$distributionUrlName" -d "$TMP_DOWNLOAD_DIR" || die "failed to unzip"
else
  tar xzf${__MVNW_QUIET_TAR:+"$__MVNW_QUIET_TAR"} "$TMP_DOWNLOAD_DIR/$distributionUrlName" -C "$TMP_DOWNLOAD_DIR" || die "failed to untar"
fi
printf %s\\n "$distributionUrl" >"$TMP_DOWNLOAD_DIR/$distributionUrlNameMain/mvnw.url"
mv -- "$TMP_DOWNLOAD_DIR/$distributionUrlNameMain" "$MAVEN_HOME" || [ -d "$MAVEN_HOME" ] || die "fail to move MAVEN_HOME"

clean || :
exec_maven "$@"
// END OF FILE: mvnw

//---> PATH: /home/mbogneng-junior/freelance-driver_Sylladb/backend/mvnw.cmd

<# : batch portion
@REM ----------------------------------------------------------------------------
@REM Licensed to the Apache Software Foundation (ASF) under one
@REM or more contributor license agreements.  See the NOTICE file
@REM distributed with this work for additional information
@REM regarding copyright ownership.  The ASF licenses this file
@REM to you under the Apache License, Version 2.0 (the
@REM "License"); you may not use this file except in compliance
@REM with the License.  You may obtain a copy of the License at
@REM
@REM    http://www.apache.org/licenses/LICENSE-2.0
@REM
@REM Unless required by applicable law or agreed to in writing,
@REM software distributed under the License is distributed on an
@REM "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
@REM KIND, either express or implied.  See the License for the
@REM specific language governing permissions and limitations
@REM under the License.
@REM ----------------------------------------------------------------------------

@REM ----------------------------------------------------------------------------
@REM Apache Maven Wrapper startup batch script, version 3.3.2
@REM
@REM Optional ENV vars
@REM   MVNW_REPOURL - repo url base for downloading maven distribution
@REM   MVNW_USERNAME/MVNW_PASSWORD - user and password for downloading maven
@REM   MVNW_VERBOSE - true: enable verbose log; others: silence the output
@REM ----------------------------------------------------------------------------

@IF "%__MVNW_ARG0_NAME__%"=="" (SET __MVNW_ARG0_NAME__=%~nx0)
@SET __MVNW_CMD__=
@SET __MVNW_ERROR__=
@SET __MVNW_PSMODULEP_SAVE=%PSModulePath%
@SET PSModulePath=
@FOR /F "usebackq tokens=1* delims==" %%A IN (`powershell -noprofile "& {$scriptDir='%~dp0'; $script='%__MVNW_ARG0_NAME__%'; icm -ScriptBlock ([Scriptblock]::Create((Get-Content -Raw '%~f0'))) -NoNewScope}"`) DO @(
  IF "%%A"=="MVN_CMD" (set __MVNW_CMD__=%%B) ELSE IF "%%B"=="" (echo %%A) ELSE (echo %%A=%%B)
)
@SET PSModulePath=%__MVNW_PSMODULEP_SAVE%
@SET __MVNW_PSMODULEP_SAVE=
@SET __MVNW_ARG0_NAME__=
@SET MVNW_USERNAME=
@SET MVNW_PASSWORD=
@IF NOT "%__MVNW_CMD__%"=="" (%__MVNW_CMD__% %*)
@echo Cannot start maven from wrapper >&2 && exit /b 1
@GOTO :EOF
: end batch / begin powershell #>

$ErrorActionPreference = "Stop"
if ($env:MVNW_VERBOSE -eq "true") {
  $VerbosePreference = "Continue"
}

# calculate distributionUrl, requires .mvn/wrapper/maven-wrapper.properties
$distributionUrl = (Get-Content -Raw "$scriptDir/.mvn/wrapper/maven-wrapper.properties" | ConvertFrom-StringData).distributionUrl
if (!$distributionUrl) {
  Write-Error "cannot read distributionUrl property in $scriptDir/.mvn/wrapper/maven-wrapper.properties"
}

switch -wildcard -casesensitive ( $($distributionUrl -replace '^.*/','') ) {
  "maven-mvnd-*" {
    $USE_MVND = $true
    $distributionUrl = $distributionUrl -replace '-bin\.[^.]*$',"-windows-amd64.zip"
    $MVN_CMD = "mvnd.cmd"
    break
  }
  default {
    $USE_MVND = $false
    $MVN_CMD = $script -replace '^mvnw','mvn'
    break
  }
}

# apply MVNW_REPOURL and calculate MAVEN_HOME
# maven home pattern: ~/.m2/wrapper/dists/{apache-maven-<version>,maven-mvnd-<version>-<platform>}/<hash>
if ($env:MVNW_REPOURL) {
  $MVNW_REPO_PATTERN = if ($USE_MVND) { "/org/apache/maven/" } else { "/maven/mvnd/" }
  $distributionUrl = "$env:MVNW_REPOURL$MVNW_REPO_PATTERN$($distributionUrl -replace '^.*'+$MVNW_REPO_PATTERN,'')"
}
$distributionUrlName = $distributionUrl -replace '^.*/',''
$distributionUrlNameMain = $distributionUrlName -replace '\.[^.]*$','' -replace '-bin$',''
$MAVEN_HOME_PARENT = "$HOME/.m2/wrapper/dists/$distributionUrlNameMain"
if ($env:MAVEN_USER_HOME) {
  $MAVEN_HOME_PARENT = "$env:MAVEN_USER_HOME/wrapper/dists/$distributionUrlNameMain"
}
$MAVEN_HOME_NAME = ([System.Security.Cryptography.MD5]::Create().ComputeHash([byte[]][char[]]$distributionUrl) | ForEach-Object {$_.ToString("x2")}) -join ''
$MAVEN_HOME = "$MAVEN_HOME_PARENT/$MAVEN_HOME_NAME"

if (Test-Path -Path "$MAVEN_HOME" -PathType Container) {
  Write-Verbose "found existing MAVEN_HOME at $MAVEN_HOME"
  Write-Output "MVN_CMD=$MAVEN_HOME/bin/$MVN_CMD"
  exit $?
}

if (! $distributionUrlNameMain -or ($distributionUrlName -eq $distributionUrlNameMain)) {
  Write-Error "distributionUrl is not valid, must end with *-bin.zip, but found $distributionUrl"
}

# prepare tmp dir
$TMP_DOWNLOAD_DIR_HOLDER = New-TemporaryFile
$TMP_DOWNLOAD_DIR = New-Item -Itemtype Directory -Path "$TMP_DOWNLOAD_DIR_HOLDER.dir"
$TMP_DOWNLOAD_DIR_HOLDER.Delete() | Out-Null
trap {
  if ($TMP_DOWNLOAD_DIR.Exists) {
    try { Remove-Item $TMP_DOWNLOAD_DIR -Recurse -Force | Out-Null }
    catch { Write-Warning "Cannot remove $TMP_DOWNLOAD_DIR" }
  }
}

New-Item -Itemtype Directory -Path "$MAVEN_HOME_PARENT" -Force | Out-Null

# Download and Install Apache Maven
Write-Verbose "Couldn't find MAVEN_HOME, downloading and installing it ..."
Write-Verbose "Downloading from: $distributionUrl"
Write-Verbose "Downloading to: $TMP_DOWNLOAD_DIR/$distributionUrlName"

$webclient = New-Object System.Net.WebClient
if ($env:MVNW_USERNAME -and $env:MVNW_PASSWORD) {
  $webclient.Credentials = New-Object System.Net.NetworkCredential($env:MVNW_USERNAME, $env:MVNW_PASSWORD)
}
[Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12
$webclient.DownloadFile($distributionUrl, "$TMP_DOWNLOAD_DIR/$distributionUrlName") | Out-Null

# If specified, validate the SHA-256 sum of the Maven distribution zip file
$distributionSha256Sum = (Get-Content -Raw "$scriptDir/.mvn/wrapper/maven-wrapper.properties" | ConvertFrom-StringData).distributionSha256Sum
if ($distributionSha256Sum) {
  if ($USE_MVND) {
    Write-Error "Checksum validation is not supported for maven-mvnd. `nPlease disable validation by removing 'distributionSha256Sum' from your maven-wrapper.properties."
  }
  Import-Module $PSHOME\Modules\Microsoft.PowerShell.Utility -Function Get-FileHash
  if ((Get-FileHash "$TMP_DOWNLOAD_DIR/$distributionUrlName" -Algorithm SHA256).Hash.ToLower() -ne $distributionSha256Sum) {
    Write-Error "Error: Failed to validate Maven distribution SHA-256, your Maven distribution might be compromised. If you updated your Maven version, you need to update the specified distributionSha256Sum property."
  }
}

# unzip and move
Expand-Archive "$TMP_DOWNLOAD_DIR/$distributionUrlName" -DestinationPath "$TMP_DOWNLOAD_DIR" | Out-Null
Rename-Item -Path "$TMP_DOWNLOAD_DIR/$distributionUrlNameMain" -NewName $MAVEN_HOME_NAME | Out-Null
try {
  Move-Item -Path "$TMP_DOWNLOAD_DIR/$MAVEN_HOME_NAME" -Destination $MAVEN_HOME_PARENT | Out-Null
} catch {
  if (! (Test-Path -Path "$MAVEN_HOME" -PathType Container)) {
    Write-Error "fail to move MAVEN_HOME"
  }
} finally {
  try { Remove-Item $TMP_DOWNLOAD_DIR -Recurse -Force | Out-Null }
  catch { Write-Warning "Cannot remove $TMP_DOWNLOAD_DIR" }
}

Write-Output "MVN_CMD=$MAVEN_HOME/bin/$MVN_CMD"
// END OF FILE: mvnw.cmd

//---> PATH: /home/mbogneng-junior/freelance-driver_Sylladb/backend/policy.json

{
    "Version": "2012-10-17",
    "Statement": [
        {
            "Effect": "Allow",
            "Principal": "*",
            "Action": [
                "s3:GetObject"
            ],
            "Resource": [
                "arn:aws:s3:::freelance-driver/*"
            ]
        }
    ]
}
// END OF FILE: policy.json

//---> PATH: /home/mbogneng-junior/freelance-driver_Sylladb/backend/pom.xml

<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>
    <parent>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-parent</artifactId>
        <version>3.3.0</version>
        <relativePath/> <!-- lookup parent from repository -->
    </parent>
    <groupId>inc.yowyob</groupId>
    <artifactId>freelance-driver-service</artifactId>
    <version>1.0.0</version>
    <name>freelance-driver-service</name>
    <description>Backend service for the freelance driver application</description>

    <properties>
        <java.version>21</java.version>
        <!-- Version du Bill of Materials de Spring Cloud compatible avec Spring Boot 3.3.0 -->
        <spring-cloud.version>2023.0.1</spring-cloud.version>
    </properties>

    <!-- Gestion des versions des dépendances Spring Cloud -->
    <dependencyManagement>
        <dependencies>
            <dependency>
                <groupId>org.springframework.cloud</groupId>
                <artifactId>spring-cloud-dependencies</artifactId>
                <version>${spring-cloud.version}</version>
                <type>pom</type>
                <scope>import</scope>
            </dependency>
            <dependency>
                <groupId>software.amazon.awssdk</groupId>
                <artifactId>bom</artifactId>
                <version>2.25.30</version>
                <type>pom</type>
                <scope>import</scope>
            </dependency>
        </dependencies>
    </dependencyManagement>

    <dependencies>
        <!-- Support pour la base de données ScyllaDB/Cassandra en mode réactif -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-data-cassandra-reactive</artifactId>
        </dependency>

        <!-- Framework Web réactif (remplace spring-boot-starter-web) -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-webflux</artifactId>
        </dependency>

        <!-- Sécurité Spring -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-security</artifactId>
        </dependency>

        <!-- Support pour valider les tokens JWT (très utile pour un microservice) -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-oauth2-resource-server</artifactId>
        </dependency>

        <!-- DÉPENDANCE POUR LE SERVEUR SOCKET.IO -->
        <dependency>
            <groupId>com.corundumstudio.socketio</groupId>
            <artifactId>netty-socketio</artifactId>
            <version>2.0.11</version> <!-- Version récente et stable -->
        </dependency>

              
        <!-- Support pour l'envoi d'emails -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-mail</artifactId>
        </dependency>

        <!-- Moteur de template Thymeleaf pour générer le HTML des emails -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-thymeleaf</artifactId>
        </dependency>

        <!-- Support pour Firebase Admin SDK (Notifications Push) -->
        <dependency>
            <groupId>com.google.firebase</groupId>
            <artifactId>firebase-admin</artifactId>
            <version>9.3.0</version>    
        </dependency>
              
              
        <dependency>
            <groupId>software.amazon.awssdk</groupId>
            <artifactId>s3</artifactId>
            <!-- Pas besoin de <version> ici, Maven la connaît grâce au BOM ! -->
        </dependency>

        <dependency>
        <groupId>io.minio</groupId>
            <artifactId>minio</artifactId>
            <version>8.5.2</version> <!-- Une version récente et stable -->
        </dependency>

    

    

        <!-- Outils de développement (rechargement à chaud) -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-devtools</artifactId>
            <scope>runtime</scope>
            <optional>true</optional>
        </dependency>

        <!-- Lombok pour réduire le code boilerplate -->
        <dependency>
            <groupId>org.projectlombok</groupId>
            <artifactId>lombok</artifactId>
            <optional>true</optional>
        </dependency>

        <dependency>

            <groupId>io.github.cdimascio</groupId>

            <artifactId>dotenv-java</artifactId>

            <version>3.0.0</version>

        </dependency>

        <!-- Dépendances de test -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-test</artifactId>
            <scope>test</scope>
        </dependency>
        <dependency>
            <groupId>io.projectreactor</groupId>
            <artifactId>reactor-test</artifactId>
            <scope>test</scope>
        </dependency>
        <dependency>
            <groupId>org.springframework.security</groupId>
            <artifactId>spring-security-test</artifactId>
            <scope>test</scope>
        </dependency>
    </dependencies>

    <build>
        <plugins>
            <!-- Plugin Maven pour la compilation -->
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-compiler-plugin</artifactId>
                <configuration>
                    <!-- Nécessaire pour que Lombok fonctionne avec Maven -->
                    <annotationProcessorPaths>
                        <path>
                            <groupId>org.projectlombok</groupId>
                            <artifactId>lombok</artifactId>
                            <version>${lombok.version}</version>
                        </path>
                    </annotationProcessorPaths>
                </configuration>
            </plugin>
            <!-- Plugin Spring Boot pour créer l'exécutable -->
            <plugin>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-maven-plugin</artifactId>
                <configuration>
                    <excludes>
                        <exclude>
                            <groupId>org.projectlombok</groupId>
                            <artifactId>lombok</artifactId>
                        </exclude>
                    </excludes>
                </configuration>
            </plugin>
        </plugins>
    </build>
    <repositories>
        <repository>
            <id>maven-central</id>
            <url>https://repo.maven.apache.org/maven2</url>
        </repository>
        <repository>
            <id>gitlab-maven</id>
            <url>https://gitlab.yowyob.com/api/v4/groups/3/-/packages/maven</url>
        </repository>
    </repositories>
    <distributionManagement>
        <repository>
            <id>gitlab-maven</id>
            <url>${CI_API_V4_URL}/projects/${CI_PROJECT_ID}/packages/maven</url>
        </repository>
        <snapshotRepository>
            <id>gitlab-maven</id>
            <url>${CI_API_V4_URL}/projects/${CI_PROJECT_ID}/packages/maven</url>
        </snapshotRepository>
    </distributionManagement>
</project>// END OF FILE: pom.xml

//---> PATH: /home/mbogneng-junior/freelance-driver_Sylladb/backend/prompter.sh

#!/bin/bash

# --- Configuration ---

# Default project path if none provided
DEFAULT_PROJECT_PATH="."
PROJECT_PATH=${1:-"$DEFAULT_PROJECT_PATH"}

# Output file name (relative to PROJECT_PATH)
OUTPUT_FILENAME="project_context.txt"

# Directories to completely ignore (won't be traversed)
EXCLUDE_DIRS_PATTERN=( \
    ".*"            # All hidden folders (.git, .vscode, .idea, .svn, etc.)
    "node_modules"
    "vendor"        # PHP Composer
    "build"
    "dist"
    "target"        # Java/Rust build outputs
    "__pycache__"   # Python cache
    ".next"         # Next.js build output
    "cache"         # General cache folders
    "target"
    "storage"       # Laravel storage (often contains logs, cache, etc.)
    # Add more directory names here if needed
)

# Specific file patterns to ignore within traversed directories
EXCLUDE_FILES_PATTERN=( \
    "*.log"
    "*.jar"
    "*.pdf"
    "*.class"
    "*.sqlite"
    "project_context.txt"
    # ".env*"       # Consider if you NEED .env files; uncomment if NOT needed.
    "package-lock.json"
    "yarn.lock"
    "composer.lock"
    "*.ico"
    "pnpm-lock.yaml"
    # Add more file patterns here (e.g., "*.swp", "*.bak", "*.tmp")
)

# --- Script Logic ---

# Attempt to get absolute path; exit if PROJECT_PATH is invalid early
PROJECT_PATH=$(realpath "$PROJECT_PATH" 2>/dev/null)
if [ $? -ne 0 ] || [ ! -d "$PROJECT_PATH" ]; then
    echo "Error: Invalid or non-existent project directory specified." >&2 # Error to stderr
    exit 1
fi

OUTPUT_FILE="$PROJECT_PATH/$OUTPUT_FILENAME"

# --- Safety Check: Prevent overwriting the project directory itself ---
# This is unlikely but guards against strange configurations
if [ "$PROJECT_PATH" == "$OUTPUT_FILE" ]; then
    echo "Error: Project directory path conflicts with output file name '$OUTPUT_FILENAME'." >&2
    exit 1
fi

# Delete output file silently if it exists
rm -f "$OUTPUT_FILE"

# --- Build the find command ---
# Uses arrays to construct the find command safely and avoid complex escaping issues with eval
find_args=("$PROJECT_PATH")

# Add directory prune conditions
if [ ${#EXCLUDE_DIRS_PATTERN[@]} -gt 0 ]; then
    find_args+=(\()
    first_prune=true
    for dir_pattern in "${EXCLUDE_DIRS_PATTERN[@]}"; do
        if ! $first_prune; then
            find_args+=(-o)
        fi
        find_args+=(-name "$dir_pattern" -type d)
        first_prune=false
    done
    find_args+=(\) -prune -o) # Add the prune action and the OR for the next part
fi

# Add primary find conditions (type file, exclude output file, exclude patterns)
find_args+=(\( -type f -not -path "$OUTPUT_FILE")
if [ ${#EXCLUDE_FILES_PATTERN[@]} -gt 0 ]; then
    for file_pattern in "${EXCLUDE_FILES_PATTERN[@]}"; do
        find_args+=(-not -name "$file_pattern")
    done
fi
find_args+=(-print \)) # Add the print action and close the group

# --- Execute the find command and process results ---

# Create the header in the output file
{
    echo "Project Context From: $PROJECT_PATH"
    echo "Generated On: $(date)"
    echo "==============================================="
    echo "Ignored Directory Patterns: ${EXCLUDE_DIRS_PATTERN[*]}"
    echo "Ignored File Patterns: ${EXCLUDE_FILES_PATTERN[*]}"
    echo "==============================================="
    echo ""
} > "$OUTPUT_FILE"

error_count=0
# Use find with process substitution and sorting. Avoids eval.
while IFS= read -r FILE_PATH; do
    # Calculate relative path for cleaner output
    RELATIVE_PATH="${FILE_PATH#"$PROJECT_PATH"/}"

    # Append file info and content to the output file
    {
        # echo ""
        # echo "// ==============================================="
        # echo "---> FILE: $RELATIVE_PATH"
        echo "//---> PATH: $FILE_PATH"
        # echo "// ==============================================="
        echo ""
    } >> "$OUTPUT_FILE"

    # Check if file is likely binary/non-text using 'file' command
    # -b: omit filename; check for common non-text types
    if file -b "$FILE_PATH" | grep -q -E 'binary|archive|compressed|image|font'; then
        echo "[Non-text file (e.g., binary, data, compressed) - Contents omitted]" >> "$OUTPUT_FILE"
    else
        # Append text file content, redirect cat errors to stderr
        if ! cat "$FILE_PATH" >> "$OUTPUT_FILE" 2> /dev/null; then # Hide cat errors from stdout
             # Optionally log error to the output file itself, or just count it
             echo "[Error reading file content for $RELATIVE_PATH]" >> "$OUTPUT_FILE"
             ((error_count++))
        fi
    fi

    {
        # echo ""
        echo "// END OF FILE: $RELATIVE_PATH"
        echo ""
    } >> "$OUTPUT_FILE"

done < <(find "${find_args[@]}" | sort) # Execute find command using safe array expansion

# Optionally report errors to stderr if any occurred
if [ $error_count -gt 0 ]; then
    echo "Warning: Encountered $error_count errors reading file contents during context generation." >&2
    # Exit with a non-zero status to indicate partial success/warning
    exit 1
fi

# Exit silently on success
exit 0
// END OF FILE: prompter.sh

//---> PATH: /home/mbogneng-junior/freelance-driver_Sylladb/backend/README.md

echo "🛑 Étape 1/5: Arrêt et suppression des conteneurs et volumes Docker..."
docker compose down -v
echo "✅ Conteneurs et volumes supprimés."
echo ""


# --- ÉTAPE 2: RELANCE DE L'INFRASTRUCTURE ---
echo "🚀 Étape 2/5: Démarrage des nouveaux conteneurs Docker (ScyllaDB & MinIO)..."
docker compose up -d
echo "✅ Conteneurs démarrés. Attente de 10 secondes pour leur stabilisation..."
sleep 10
echo ""


# --- ÉTAPE 3: CONFIGURATION DE SCYLLADB ---
echo "🗄️ Étape 3/5: Création du keyspace dans ScyllaDB..."
docker exec -it scylla-node-dev cqlsh -e "CREATE KEYSPACE IF NOT EXISTS freelanceBd WITH REPLICATION = { 'class' : 'SimpleStrategy', 'replication_factor' : 1 };"
echo "✅ Keyspace 'freelanceBd' créé."
echo ""




# --- ÉTAPE 5: LANCEMENT DU BACKEND SPRING BOOT ---
echo "☕ Étape 5/5: Nettoyage du projet Maven et lancement de l'application Spring Boot..."
./mvnw clean
./mvnw spring-boot:run
// END OF FILE: README.md

//---> PATH: /home/mbogneng-junior/freelance-driver_Sylladb/backend/restart-dev.sh

Telecharger aws et configurer

curl "https://awscli.amazonaws.com/awscli-exe-linux-x86_64.zip" -o "awscliv2.zip"

unzip awscliv2.zip
sudo ./aws/install

aws --version

profile
aws configure --profile minio

docker-compose.yml :

AWS Access Key ID [None]:

    Tapez : junioradmin et appuyez sur Entrée.

    (Source : la variable MINIO_ROOT_USER de votre docker-compose.yml)

AWS Secret Access Key [None]:

    Tapez : YourStrongPassword2025 et appuyez sur Entrée.

    (Source : la variable MINIO_ROOT_PASSWORD de votre docker-compose.yml)

Default region name [None]:

    Tapez : us-east-1 et appuyez sur Entrée.

    (MinIO n'utilise pas de région, mais le CLI exige une valeur. us-east-1 est une valeur par défaut standard et sans danger.)

Default output format [None]:

    Tapez : json et appuyez sur Entrée.

    (C'est le format de sortie le plus lisible et le plus facile à utiliser dans des scripts.)



# --- ÉTAPE 4: CONFIGURATION DE MINIO ---
echo "🪣 Étape 4/5: Création du bucket MinIO et application de la politique d'accès..."

# Créer le bucket
aws --endpoint-url http://localhost:9000 s3 mb s3://freelance-driver --profile minio
echo "✅ Bucket 'freelance-driver' créé."

# Préparer le fichier de politique (au cas où il aurait été supprimé)
cat <<EOF > policy.json
{
    "Version": "2012-10-17",
    "Statement": [
        {
            "Effect": "Allow",
            "Principal": "*",
            "Action": [
                "s3:GetObject"
            ],
            "Resource": [
                "arn:aws:s3:::freelance-driver/*"
            ]
        }
    ]
}
EOF

# Appliquer la politique

echo "✅ Politique d'accès public en lecture appliquée au bucket."
echo ""


#!/bin/bash
# Un script simple pour réinitialiser complètement l'environnement de développement.
# Exécutez-le depuis la racine de votre projet driver-backend.

# --- ÉTAPE 1: ARRÊT ET NETTOYAGE COMPLET ---
echo "🛑 Étape 1/5: Arrêt et suppression des conteneurs et volumes Docker..."
docker compose down -v
echo "✅ Conteneurs et volumes supprimés."
echo ""


# --- ÉTAPE 2: RELANCE DE L'INFRASTRUCTURE ---
echo "🚀 Étape 2/5: Démarrage des nouveaux conteneurs Docker (ScyllaDB & MinIO)..."
docker compose up -d
echo "✅ Conteneurs démarrés. Attente de 10 secondes pour leur stabilisation..."
sleep 10
echo ""


# --- ÉTAPE 3: CONFIGURATION DE SCYLLADB ---
echo "🗄️ Étape 3/5: Création du keyspace dans ScyllaDB..."
docker exec -it scylla-node-dev cqlsh -e "CREATE KEYSPACE IF NOT EXISTS freelanceBd WITH REPLICATION = { 'class' : 'SimpleStrategy', 'replication_factor' : 1 };"
echo "✅ Keyspace 'freelanceBd' créé."
echo ""




# --- ÉTAPE 5: LANCEMENT DU BACKEND SPRING BOOT ---
echo "☕ Étape 5/5: Nettoyage du projet Maven et lancement de l'application Spring Boot..."
./mvnw clean
./mvnw spring-boot:run


// END OF FILE: restart-dev.sh

//---> PATH: /home/mbogneng-junior/freelance-driver_Sylladb/backend/src/main/java/com/freelance/driver_backend/config/CassandraConfig.java

package com.freelance.driver_backend.config;

import com.datastax.oss.driver.api.core.config.DefaultDriverOption;
import com.datastax.oss.driver.api.core.config.DriverConfigLoader;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Configuration;
import org.springframework.data.cassandra.config.AbstractCassandraConfiguration;
import org.springframework.data.cassandra.config.SchemaAction;
import org.springframework.data.cassandra.config.SessionBuilderConfigurer;
import org.springframework.data.cassandra.core.cql.keyspace.CreateKeyspaceSpecification;
import org.springframework.data.cassandra.core.cql.keyspace.DropKeyspaceSpecification;
import org.springframework.data.cassandra.core.cql.keyspace.KeyspaceOption;
import org.springframework.data.cassandra.repository.config.EnableReactiveCassandraRepositories;

import java.time.Duration;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

@Configuration
@EnableReactiveCassandraRepositories(basePackages = "com.freelance.driver_backend.repository")
public class CassandraConfig extends AbstractCassandraConfiguration {

    @Value("${spring.data.cassandra.contact-points:127.0.0.1}")
    private String hostname;

    @Value("${spring.data.cassandra.port:9042}")
    private int port;

    @Value("${spring.data.cassandra.keyspace:freelancebd}")
    private String keyspace;

    @Value("${spring.data.cassandra.datacenter:datacenter1}")
    private String datacenter;

    @Override
    protected String getKeyspaceName() {
        return keyspace;
    }

    @Override
    protected String getContactPoints() {
        return hostname;
    }

    @Override
    protected int getPort() {
        return port;
    }

    @Override
    public SchemaAction getSchemaAction() {
        return SchemaAction.CREATE_IF_NOT_EXISTS;
    }

    @Override
    protected List getStartupScripts() {
        return Collections.singletonList("CREATE KEYSPACE IF NOT EXISTS "
                + keyspace + " WITH replication = {"
                + " 'class': 'SimpleStrategy', "
                + " 'replication_factor': '2' " + "};");

    }

    @Override
    protected List<CreateKeyspaceSpecification> getKeyspaceCreations() {
        final CreateKeyspaceSpecification specification = CreateKeyspaceSpecification.createKeyspace(getKeyspaceName())
                .ifNotExists().with(KeyspaceOption.DURABLE_WRITES, true).withSimpleReplication();
        return Collections.singletonList(specification);
    }

    @Override
    protected List<DropKeyspaceSpecification> getKeyspaceDrops() {
        List<DropKeyspaceSpecification> list = new ArrayList<>();
        list.add(DropKeyspaceSpecification.dropKeyspace(getKeyspaceName()));
        return list;
    }
     /*
    @Override
    protected List<DropKeyspaceSpecification> getKeyspaceDrops() {
        // CORRECTION ICI : Retournez une liste vide pour NE PAS supprimer le keyspace.
        return Collections.emptyList(); // Ou new ArrayList<>() pour plus de clarté
    }
    */
    /**
     * Configuration avancée pour surcharger les timeouts du driver Cassandra.
     * Cette méthode est plus robuste que la configuration via application.properties.
     */
    @Override
    protected SessionBuilderConfigurer getSessionBuilderConfigurer() {
        return sessionBuilder -> {
            DriverConfigLoader configLoader = DriverConfigLoader.programmaticBuilder()
                    // Augmente le timeout pour toutes les requêtes à 20 secondes.
                    .withDuration(DefaultDriverOption.REQUEST_TIMEOUT, Duration.ofSeconds(20))
                    // Augmente le timeout pour la connexion initiale.
                    .withDuration(DefaultDriverOption.CONNECTION_CONNECT_TIMEOUT, Duration.ofSeconds(20))
                    // Augmente le timeout pour l'initialisation du schéma (création des tables/index).
                    .withDuration(DefaultDriverOption.CONTROL_CONNECTION_TIMEOUT, Duration.ofSeconds(20))
                    .build();
            
            return sessionBuilder.withConfigLoader(configLoader);
        };
    }
}// END OF FILE: src/main/java/com/freelance/driver_backend/config/CassandraConfig.java

//---> PATH: /home/mbogneng-junior/freelance-driver_Sylladb/backend/src/main/java/com/freelance/driver_backend/config/DotenvConfig.java

package com.freelance.driver_backend.config;

import io.github.cdimascio.dotenv.Dotenv;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class DotenvConfig {

    @Bean
    public Dotenv dotenv() {
        return Dotenv.configure().ignoreIfMissing().load();
    }
}
// END OF FILE: src/main/java/com/freelance/driver_backend/config/DotenvConfig.java

//---> PATH: /home/mbogneng-junior/freelance-driver_Sylladb/backend/src/main/java/com/freelance/driver_backend/config/FirebaseConfig.java

package com.freelance.driver_backend.config;

import com.google.auth.oauth2.GoogleCredentials;
import com.google.firebase.FirebaseApp;
import com.google.firebase.FirebaseOptions;
import com.google.firebase.messaging.FirebaseMessaging; 
import lombok.extern.slf4j.Slf4j;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.core.io.ClassPathResource;
import org.springframework.beans.factory.annotation.Value; 

import java.io.IOException;
import java.io.InputStream;

@Configuration
@Slf4j
public class FirebaseConfig {

    // NOUVELLE INJECTION : ID du projet Firebase pour les notifications
    @Value("${freelancedriver.firebase.project-id}") 
    private String firebaseProjectId;

    @Bean
    public FirebaseApp firebaseApp() throws IOException {
        if (FirebaseApp.getApps().isEmpty()) {
            log.info("Initialisation du SDK Admin de Firebase...");
            ClassPathResource resource = new ClassPathResource("firebase-service-account-key.json");
            if (!resource.exists()) {
                log.error("Le fichier 'firebase-service-account-key.json' est introuvable dans src/main/resources/");
                throw new IOException("Le fichier firebase-service-account-key.json est introuvable.");
            }

            try (InputStream serviceAccount = resource.getInputStream()) {
                FirebaseOptions options = FirebaseOptions.builder()
                    .setCredentials(GoogleCredentials.fromStream(serviceAccount))
                    .setProjectId(firebaseProjectId) // <-- UTILISE LE NOUVEAU NOM
                    .build();

                FirebaseApp app = FirebaseApp.initializeApp(options);
                log.info("✅ SDK Admin de Firebase initialisé avec succès pour le projet : {}", app.getName());
                return app; 
            }
        } else {
            log.warn("Le SDK Admin de Firebase est déjà initialisé. Récupération de l'instance existante.");
            return FirebaseApp.getInstance(); 
        }
    }

    @Bean
    public FirebaseMessaging firebaseMessaging(FirebaseApp firebaseApp) {
        return FirebaseMessaging.getInstance(firebaseApp);
    }
}// END OF FILE: src/main/java/com/freelance/driver_backend/config/FirebaseConfig.java

//---> PATH: /home/mbogneng-junior/freelance-driver_Sylladb/backend/src/main/java/com/freelance/driver_backend/config/JwtConfig.java

package com.freelance.driver_backend.config;

import com.nimbusds.jose.jwk.JWK;
import com.nimbusds.jose.jwk.JWKSet;
import com.nimbusds.jose.jwk.RSAKey;
import com.nimbusds.jose.jwk.source.ImmutableJWKSet;
import com.nimbusds.jose.jwk.source.JWKSource;
import com.nimbusds.jose.proc.SecurityContext;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.oauth2.jwt.JwtDecoder;
import org.springframework.security.oauth2.jwt.JwtEncoder;
import org.springframework.security.oauth2.jwt.NimbusJwtDecoder;
import org.springframework.security.oauth2.jwt.NimbusJwtEncoder;

import java.security.KeyPair;
import java.security.KeyPairGenerator;
import java.security.interfaces.RSAPrivateKey;
import java.security.interfaces.RSAPublicKey;

@Configuration
public class JwtConfig {

    @Bean
    public KeyPair keyPair() {
        try {
            KeyPairGenerator keyPairGenerator = KeyPairGenerator.getInstance("RSA");
            keyPairGenerator.initialize(2048);
            return keyPairGenerator.generateKeyPair();
        } catch (Exception e) {
            throw new RuntimeException("Erreur lors de la génération des clés RSA", e);
        }
    }

    @Bean
    public JWKSource<SecurityContext> jwkSource(KeyPair keyPair) {
        RSAPublicKey publicKey = (RSAPublicKey) keyPair.getPublic();
        RSAPrivateKey privateKey = (RSAPrivateKey) keyPair.getPrivate();
        
        JWK jwk = new RSAKey.Builder(publicKey)
                .privateKey(privateKey)
                .keyID("jwt-key-id")
                .build();
        
        JWKSet jwkSet = new JWKSet(jwk);
        return new ImmutableJWKSet<>(jwkSet);
    }

    @Bean
    public JwtEncoder jwtEncoder(JWKSource<SecurityContext> jwkSource) {
        return new NimbusJwtEncoder(jwkSource);
    }

    // RENOMMER le bean pour éviter le conflit avec SecurityConfig
    @Bean("localJwtDecoder")
    public JwtDecoder localJwtDecoder(KeyPair keyPair) {
        RSAPublicKey publicKey = (RSAPublicKey) keyPair.getPublic();
        return NimbusJwtDecoder.withPublicKey(publicKey).build();
    }
}// END OF FILE: src/main/java/com/freelance/driver_backend/config/JwtConfig.java

//---> PATH: /home/mbogneng-junior/freelance-driver_Sylladb/backend/src/main/java/com/freelance/driver_backend/config/SecurityConfig.java

package com.freelance.driver_backend.config;

import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.core.annotation.Order;
import org.springframework.http.HttpMethod;
import org.springframework.security.config.annotation.web.reactive.EnableWebFluxSecurity;
import org.springframework.security.config.web.server.ServerHttpSecurity;
import org.springframework.security.oauth2.jwt.NimbusReactiveJwtDecoder;
import org.springframework.security.oauth2.jwt.ReactiveJwtDecoder;
import org.springframework.security.web.server.SecurityWebFilterChain;
import org.springframework.security.web.server.util.matcher.PathPatternParserServerWebExchangeMatcher;
import org.springframework.web.cors.CorsConfiguration;
import org.springframework.web.cors.reactive.CorsConfigurationSource;
import org.springframework.web.cors.reactive.UrlBasedCorsConfigurationSource;

import java.security.KeyPair;
import java.security.interfaces.RSAPublicKey;
import java.util.Arrays;

@Configuration
@EnableWebFluxSecurity
public class SecurityConfig {

    @Value("${spring.security.oauth2.resourceserver.jwt.jwk-set-uri}")
    private String jwkSetUri;

    // ==============================================================================
    //                       CHAÎNE DE FILTRES DE SÉCURITÉ UNIQUE
    // Une seule chaîne de filtres pour gérer toutes les routes de l'API.
    // ==============================================================================
    
    @Bean
    @Order(0) // Priorité la plus haute
    public SecurityWebFilterChain apiFilterChain(ServerHttpSecurity http) throws Exception {
        http
            // Appliquer cette configuration à toutes les routes sous /api/
            .securityMatcher(new PathPatternParserServerWebExchangeMatcher("/api/**"))
            .csrf(ServerHttpSecurity.CsrfSpec::disable)
            .authorizeExchange(exchanges -> exchanges
                // --- Routes Publiques (permitAll) ---
                
                // POST publics (Login, Register, Onboarding)
                .pathMatchers(HttpMethod.POST, 
                    "/api/register", 
                    "/api/auth/login", 
                    "/api/onboarding/**"
                ).permitAll()
                
                // GET publics (Recherche, Profils publics, Annonces publiées)
                .pathMatchers(HttpMethod.GET,
                    "/api/announcements", 
                    "/api/planning/published", 
                    "/api/planning/user/**",
                    "/api/search/**",           // <--- AJOUTÉ ICI : Autorise la recherche de conducteurs
                    "/api/reviews/user/**", 
                    "/api/profiles/user/**", 
                    "/api/vehicles/user/**", 
                    "/api/addresses/user/**", 
                    "/api/experiences/user/**"
                ).permitAll()

                // Routes pour les mocks de développement
                .pathMatchers("/api/mock-**/**").permitAll()
                .pathMatchers("/api/mock_user/**", "/api/mock_auth/**").permitAll()

                // --- Routes Sécurisées (authenticated) ---
                // Toutes les autres requêtes nécessitent une authentification
                .anyExchange().authenticated()
            )
            // Configurer le serveur de ressources OAuth2 pour valider les tokens JWT
            .oauth2ResourceServer(oauth2 -> oauth2.jwt(jwt -> { }));

        return http.build();
    }

    // ==============================================================================
    //                       CONFIGURATION CORS ET JWT
    // ==============================================================================

    @Bean
    public CorsConfigurationSource corsConfigurationSource() {
        CorsConfiguration configuration = new CorsConfiguration();
        configuration.addAllowedOriginPattern("*"); // Autorise toutes les origines (pour DEV)
        configuration.setAllowedMethods(Arrays.asList("GET", "POST", "PUT", "DELETE", "OPTIONS"));
        configuration.setAllowedHeaders(Arrays.asList("*"));
        configuration.setAllowCredentials(true);
        UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();
        source.registerCorsConfiguration("/**", configuration);
        return source;
    }
  
   @Bean
    public ReactiveJwtDecoder jwtDecoder(KeyPair keyPair) {
        RSAPublicKey publicKey = (RSAPublicKey) keyPair.getPublic();
        return NimbusReactiveJwtDecoder.withPublicKey(publicKey).build();
    }
}// END OF FILE: src/main/java/com/freelance/driver_backend/config/SecurityConfig.java

//---> PATH: /home/mbogneng-junior/freelance-driver_Sylladb/backend/src/main/java/com/freelance/driver_backend/config/SocketIOConfig.java

// src/main/java/com/freelance/driver_backend/config/SocketIOConfig.java

package com.freelance.driver_backend.config;

import com.corundumstudio.socketio.SocketIOServer;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class SocketIOConfig {

    @Value("${socketio.server.host}")
    private String host;

    @Value("${socketio.server.port}")
    private Integer port;

    @Bean
    public SocketIOServer socketIOServer() {
        com.corundumstudio.socketio.Configuration config = new com.corundumstudio.socketio.Configuration();
        config.setHostname(host);
        config.setPort(port);

        // Cette ligne est cruciale pour autoriser les connexions depuis votre application mobile et le web.
        config.setOrigin("*");

        return new SocketIOServer(config);
    }
}// END OF FILE: src/main/java/com/freelance/driver_backend/config/SocketIOConfig.java

//---> PATH: /home/mbogneng-junior/freelance-driver_Sylladb/backend/src/main/java/com/freelance/driver_backend/config/ThymeleafConfig.java

package com.freelance.driver_backend.config;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.thymeleaf.spring6.SpringTemplateEngine;
import org.thymeleaf.templatemode.TemplateMode;
import org.thymeleaf.templateresolver.StringTemplateResolver;
import org.springframework.context.annotation.Primary;

@Configuration
public class ThymeleafConfig {

    /**
     * Configure un moteur de template Thymeleaf capable de traiter des chaînes de caractères.
     * On le marque comme @Primary pour qu'il soit choisi par défaut lors de l'injection
     * de dépendances, au lieu de celui configuré automatiquement par Spring Boot.
     * @return Une instance de SpringTemplateEngine.
     */
    @Bean
    @Primary // <-- AJOUTER CETTE ANNOTATION
    public SpringTemplateEngine springTemplateEngine() {
        SpringTemplateEngine templateEngine = new SpringTemplateEngine();
        
        // Créer un "resolver" qui sait lire des chaînes de caractères
        StringTemplateResolver stringTemplateResolver = new StringTemplateResolver();
        stringTemplateResolver.setTemplateMode(TemplateMode.HTML); // Préciser qu'on traite du HTML
        
        // Ajouter ce resolver au moteur de template
        templateEngine.addTemplateResolver(stringTemplateResolver);
        
        return templateEngine;
    }
}// END OF FILE: src/main/java/com/freelance/driver_backend/config/ThymeleafConfig.java

//---> PATH: /home/mbogneng-junior/freelance-driver_Sylladb/backend/src/main/java/com/freelance/driver_backend/config/WebClientConfig.java

package com.freelance.driver_backend.config;

import io.netty.channel.ChannelOption;
import io.netty.handler.timeout.ReadTimeoutHandler;
import io.netty.handler.timeout.WriteTimeoutHandler;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.http.HttpHeaders;
import org.springframework.http.MediaType;
import org.springframework.http.client.reactive.ReactorClientHttpConnector;
import org.springframework.web.reactive.function.client.WebClient;
import reactor.netty.http.client.HttpClient;

import java.time.Duration;
import java.util.concurrent.TimeUnit;

@Configuration
public class WebClientConfig {

    @Value("${microservices.chat-service.url}")
    private String chatServiceUrl;

    @Value("${microservices.auth-service.url}")
    private String authServiceUrl;

    @Value("${microservices.organisation-service.url}")
    private String organisationServiceUrl;

    @Value("${server.port}")
    private String localServerPort;

    @Value("${microservices.resource-service.url}")
    private String resourceServiceUrl;

    @Value("${microservices.media-service.url}") // URL du service de médias, nouvellement ajoutée
    private String mediaServiceUrl;

    /**
     * Crée un HttpClient réutilisable avec des timeouts standards.
     * 
     * @return HttpClient configuré
     */
    private HttpClient createConfiguredHttpClient() {
        return HttpClient.create()
                .option(ChannelOption.CONNECT_TIMEOUT_MILLIS, 20000) // 20 secondes
                .responseTimeout(Duration.ofSeconds(20)) // 20 secondes
                .doOnConnected(conn -> conn.addHandlerLast(new ReadTimeoutHandler(20, TimeUnit.SECONDS))
                        .addHandlerLast(new WriteTimeoutHandler(20, TimeUnit.SECONDS)));
    }

    /**
     * Crée un HttpClient configuré avec des timeouts plus longs pour les opérations
     * de média.
     * Les téléversements de fichiers peuvent prendre plus de temps.
     * 
     * @return HttpClient configuré pour les médias
     */
    private HttpClient createMediaServiceHttpClient() {
        return HttpClient.create()
                .option(ChannelOption.CONNECT_TIMEOUT_MILLIS, 30000) // 30 secondes pour la connexion
                .responseTimeout(Duration.ofSeconds(60)) // 60 secondes pour la réponse complète
                .doOnConnected(conn -> conn.addHandlerLast(new ReadTimeoutHandler(60, TimeUnit.SECONDS)) // 60s read
                                                                                                         // timeout
                        .addHandlerLast(new WriteTimeoutHandler(60, TimeUnit.SECONDS))); // 60s write timeout
    }

    @Bean
    @Qualifier("authServiceWebClient")
    public WebClient authServiceWebClient() {
        return WebClient.builder()
                .baseUrl(authServiceUrl)
                .clientConnector(new ReactorClientHttpConnector(createConfiguredHttpClient()))
                .defaultHeader(HttpHeaders.CONTENT_TYPE, MediaType.APPLICATION_JSON_VALUE)
                .build();
    }

    @Bean
    @Qualifier("organisationServiceWebClient")
    public WebClient organisationServiceWebClient() {
        return WebClient.builder()
                .baseUrl(organisationServiceUrl)
                .clientConnector(new ReactorClientHttpConnector(createConfiguredHttpClient()))
                .defaultHeader(HttpHeaders.CONTENT_TYPE, MediaType.APPLICATION_JSON_VALUE)
                .build();
    }

    @Bean
    @Qualifier("chatServiceWebClient")
    public WebClient chatServiceWebClient() {
        return WebClient.builder()
                .baseUrl(chatServiceUrl)
                .clientConnector(new ReactorClientHttpConnector(createConfiguredHttpClient()))
                .defaultHeader(HttpHeaders.CONTENT_TYPE, MediaType.APPLICATION_JSON_VALUE)
                .build();
    }

    @Bean
    @Qualifier("localApiWebClient")
    public WebClient localApiWebClient() {
        return WebClient.builder().baseUrl("http://localhost:" + localServerPort).build();
    }

    @Bean
    @Qualifier("externalResourceWebClient")
    public WebClient externalResourceWebClient() {
        return WebClient.builder().baseUrl(resourceServiceUrl).build();
    }

    /**
     * Crée un WebClient pour interagir avec le service de médias externe.
     * Utilise des timeouts plus longs pour les opérations de fichiers.
     * 
     * @return WebClient configuré pour le service de médias
     */
    @Bean
    @Qualifier("externalMediaServiceWebClient")
    public WebClient externalMediaServiceWebClient() {
        return WebClient.builder()
                .baseUrl(mediaServiceUrl)
                .clientConnector(new ReactorClientHttpConnector(createMediaServiceHttpClient()))
                // Le Content-Type est défini par BodyInserters.fromMultipartData() pour les
                // uploads de fichiers
                .build();
    }

    

    @Bean
    @Qualifier("mockWebClient")
    public WebClient mockWebClient() {
        return WebClient.builder()
                .baseUrl("http://localhost:" + localServerPort)
                .clientConnector(new ReactorClientHttpConnector(createConfiguredHttpClient()))
                .defaultHeader(HttpHeaders.CONTENT_TYPE, MediaType.APPLICATION_JSON_VALUE)
                .build();
    }

}
// END OF FILE: src/main/java/com/freelance/driver_backend/config/WebClientConfig.java

//---> PATH: /home/mbogneng-junior/freelance-driver_Sylladb/backend/src/main/java/com/freelance/driver_backend/controller/AddressController.java



// PATH: /home/mbogneng-junior/freelance-driver (Copie)/backend/src/main/java/com/freelance/driver_backend/controller/AddressController.java

package com.freelance.driver_backend.controller;

import com.freelance.driver_backend.dto.CreateProductRequest;
import com.freelance.driver_backend.dto.UserSessionContextDto; // Nouveau import
import com.freelance.driver_backend.model.Product;
import com.freelance.driver_backend.service.ProfileService;
import com.freelance.driver_backend.service.ResourceService;
import com.freelance.driver_backend.util.JwtUtil;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.core.annotation.AuthenticationPrincipal;
import org.springframework.security.oauth2.jwt.Jwt;
import org.springframework.web.bind.annotation.*;
import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;

import java.util.Optional;
import java.util.UUID;

@RestController
@RequestMapping("/api/addresses")
@RequiredArgsConstructor
@Slf4j
public class AddressController {

    private final ProfileService profileService;
    private final ResourceService resourceService;

    // Un UUID fixe et unique pour identifier toutes les adresses dans la table "products"
    private static final UUID ADDRESS_CATEGORY_ID = UUID.fromString("4a6f8b90-1234-5678-9abc-def012345678");

    /**
     * SECURISE: Récupère toutes les adresses de l'utilisateur actuellement connecté.
     */
    @GetMapping
    public Flux<Product> getUserAddresses(
            @AuthenticationPrincipal Mono<Jwt> jwtMono,
            @RequestHeader("Authorization") String authorizationHeader) {
        
        return jwtMono
            .flatMap(jwt -> profileService.getUserSessionContext(JwtUtil.getUserIdFromToken(jwt), authorizationHeader, null))
            .flatMapMany(userContext -> {
                // Un utilisateur devrait toujours avoir une organisation après l'onboarding initial
                if (userContext.getOrganisation() == null || userContext.getOrganisation().getOrganizationId() == null) {
                    return Flux.error(new IllegalStateException("L'utilisateur n'a pas d'organisation valide associée."));
                }
                UUID organizationId = userContext.getOrganisation().getOrganizationId();
                // Utilise le service de ressources pour obtenir les produits par catégorie et par client_id (l'utilisateur connecté)
                // NOTE: getProductsByCategory ne filtre pas par clientId, il faut le faire après ou modifier le service de ressources
                return resourceService.getProductsByCategory(organizationId, ADDRESS_CATEGORY_ID, authorizationHeader, null)
                                      .filter(product -> userContext.getUserId().equals(product.getClientId())); // Filtrer par l'ID de l'utilisateur connecté
            });
    }

    /**
     * PUBLIC: Récupère les adresses d'un utilisateur spécifique par son ID.
     */
    @GetMapping("/user/{userId}")
    public Flux<Product> getAddressesForUser(
        @PathVariable UUID userId,
        @RequestHeader(value = "Authorization", required = false) String authorizationHeader
    ) {
        log.info("▶️ [AddressController] Récupération des adresses publiques pour l'utilisateur ID: {}", userId);

        String token = Optional.ofNullable(authorizationHeader).orElse(null);

        // MODIFIÉ : Récupère l'organisation ID du userId spécifié.
        // Puis, filtre les produits de cette organisation qui appartiennent à ce userId.
        return profileService.findOrganisationIdByUserId(userId)
             .flatMapMany(orgId ->
                resourceService.getProductsByCategory(orgId, ADDRESS_CATEGORY_ID, token, null)
                               .filter(product -> userId.equals(product.getClientId())) // Filtrer par l'ID de l'utilisateur demandé
             )
             .doOnComplete(() -> log.info("✅ [addressService] Adresses publiques trouvées pour l'utilisateur {}.", userId))
             .doOnError(error -> log.error("❌ Erreur lors de la récupération des adresses pour {}: {}", userId, error.getMessage()));
    }


    /**
     * SECURISE: Crée une nouvelle adresse pour l'utilisateur connecté.
     */
    @PostMapping
    public Mono<ResponseEntity<Product>> createAddress(
            @RequestBody CreateProductRequest request,
            @AuthenticationPrincipal Mono<Jwt> jwtMono,
            @RequestHeader("Authorization") String authorizationHeader) {

        return jwtMono
            .flatMap(jwt -> profileService.getUserSessionContext(JwtUtil.getUserIdFromToken(jwt), authorizationHeader, null))
            .flatMap(userContext -> {
                if (userContext.getOrganisation() == null || userContext.getOrganisation().getOrganizationId() == null) {
                    return Mono.error(new IllegalStateException("Contexte utilisateur invalide pour créer une adresse (organisation manquante)."));
                }
                
                // On s'assure que la bonne catégorie et l'ID du propriétaire sont définis
                request.setCategoryId(ADDRESS_CATEGORY_ID);
                request.setClientId(userContext.getUserId()); // L'ID de l'utilisateur connecté est le propriétaire
                
                log.info("▶️ Controller: Création d'une nouvelle adresse '{}' pour l'utilisateur {}", request.getName(), userContext.getUserId());
                
                return resourceService.createProduct(
                    userContext.getOrganisation().getOrganizationId(), 
                    request, 
                    authorizationHeader, 
                    null
                );
            })
            .map(createdProduct -> new ResponseEntity<>(createdProduct, HttpStatus.CREATED));
    }

    /**
     * SECURISE: Met à jour une adresse existante.
     */
    @PutMapping("/{addressId}")
    public Mono<ResponseEntity<Product>> updateAddress(
            @PathVariable UUID addressId,
            @RequestBody CreateProductRequest request,
            @AuthenticationPrincipal Mono<Jwt> jwtMono,
            @RequestHeader("Authorization") String authorizationHeader) {
        
        return jwtMono
            .flatMap(jwt -> profileService.getUserSessionContext(JwtUtil.getUserIdFromToken(jwt), authorizationHeader, null))
            .flatMap(userContext -> {
                if (userContext.getOrganisation() == null || userContext.getOrganisation().getOrganizationId() == null) {
                    return Mono.error(new IllegalStateException("Contexte utilisateur invalide pour mettre à jour une adresse (organisation manquante)."));
                }
                // Vérification cruciale : l'utilisateur connecté est-il le propriétaire de l'adresse ?
                return resourceService.getProductsByCategory(userContext.getOrganisation().getOrganizationId(), ADDRESS_CATEGORY_ID, authorizationHeader, null)
                        .filter(product -> product.getId().equals(addressId) && userContext.getUserId().equals(product.getClientId()))
                        .next() // Prend le premier élément ou vide
                        .switchIfEmpty(Mono.error(new SecurityException("L'utilisateur n'est pas autorisé à modifier cette adresse ou elle n'existe pas.")))
                        .flatMap(existingAddress -> {
                            request.setCategoryId(ADDRESS_CATEGORY_ID);
                            request.setClientId(userContext.getUserId()); // Assure que le propriétaire reste le même
                            log.info("▶️ Controller: Mise à jour de l'adresse ID: {}", addressId);
                            
                            return resourceService.updateProduct(
                                userContext.getOrganisation().getOrganizationId(), 
                                addressId,
                                request, 
                                authorizationHeader, 
                                null
                            );
                        });
            })
            .map(ResponseEntity::ok)
            .defaultIfEmpty(ResponseEntity.notFound().build());
    }

    /**
     * SECURISE: Supprime une adresse existante.
     */
    @DeleteMapping("/{addressId}")
    public Mono<ResponseEntity<Void>> deleteAddress(
            @PathVariable UUID addressId,
            @AuthenticationPrincipal Mono<Jwt> jwtMono,
            @RequestHeader("Authorization") String authorizationHeader) {

        return jwtMono
            .flatMap(jwt -> profileService.getUserSessionContext(JwtUtil.getUserIdFromToken(jwt), authorizationHeader, null))
            .flatMap(userContext -> {
                if (userContext.getOrganisation() == null || userContext.getOrganisation().getOrganizationId() == null) {
                    return Mono.error(new IllegalStateException("Contexte utilisateur invalide pour supprimer une adresse (organisation manquante)."));
                }
                // Vérification cruciale : l'utilisateur connecté est-il le propriétaire de l'adresse ?
                return resourceService.getProductsByCategory(userContext.getOrganisation().getOrganizationId(), ADDRESS_CATEGORY_ID, authorizationHeader, null)
                        .filter(product -> product.getId().equals(addressId) && userContext.getUserId().equals(product.getClientId()))
                        .next() // Prend le premier élément ou vide
                        .switchIfEmpty(Mono.error(new SecurityException("L'utilisateur n'est pas autorisé à supprimer cette adresse ou elle n'existe pas.")))
                        .flatMap(existingAddress -> {
                            log.info("▶️ Controller: Suppression de l'adresse ID: {}", addressId);
                            return resourceService.deleteProduct(
                                userContext.getOrganisation().getOrganizationId(), 
                                addressId,
                                authorizationHeader, 
                                null
                            );
                        });
            })
            .then(Mono.just(new ResponseEntity<Void>(HttpStatus.NO_CONTENT)));
    }
}// END OF FILE: src/main/java/com/freelance/driver_backend/controller/AddressController.java

//---> PATH: /home/mbogneng-junior/freelance-driver_Sylladb/backend/src/main/java/com/freelance/driver_backend/controller/AnnouncementController.java


package com.freelance.driver_backend.controller;

import com.corundumstudio.socketio.SocketIOServer;
import com.freelance.driver_backend.dto.CreateProductRequest;
import com.freelance.driver_backend.dto.UserSessionContextDto;
import com.freelance.driver_backend.model.ClientProfile;
import com.freelance.driver_backend.model.DriverProfile;
import com.freelance.driver_backend.model.Product;
import com.freelance.driver_backend.model.ProductKey;
import com.freelance.driver_backend.repository.ProductRepository;
import com.freelance.driver_backend.service.NotificationTriggerService;
import com.freelance.driver_backend.service.ProfileService;
import com.freelance.driver_backend.service.ResourceService;
import com.freelance.driver_backend.util.JwtUtil;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.core.annotation.AuthenticationPrincipal;
import org.springframework.security.oauth2.jwt.Jwt;
import org.springframework.web.bind.annotation.*;
import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;

import java.util.UUID;

@RestController
@RequestMapping("/api/announcements")
@RequiredArgsConstructor
@Slf4j
public class AnnouncementController {

    private final ResourceService resourceService;
    private final ProfileService profileService;
    private final ProductRepository productRepository; 
    private final NotificationTriggerService notificationTriggerService;
    private final SocketIOServer socketIOServer; 

    private static final UUID ANNOUNCEMENT_CATEGORY_ID = UUID.fromString("c1a5b4e0-1234-5678-9abc-def012345678");

    /**
     * PUBLIC: Récupère toutes les annonces publiées par les clients.
     */
    @GetMapping
    public Flux<Product> getPublishedAnnouncements() {
        log.info("Controller: Requête publique pour récupérer les annonces publiées.");
        return productRepository.findByCategoryId(ANNOUNCEMENT_CATEGORY_ID)
                .filter(product -> "Published".equalsIgnoreCase(product.getStatus()))
                .flatMap(this::enrichProductWithAuthorDetails);
    }

    /**
     * SECURISE (CLIENT): Récupère les annonces du client actuellement connecté.
     */
    @GetMapping("/my-announcements")
    public Flux<Product> getMyAnnouncements(
            @AuthenticationPrincipal Mono<Jwt> jwtMono,
            @RequestHeader("Authorization") String authorizationHeader) { 
        return jwtMono
            .flatMap(jwt -> profileService.getUserSessionContext(JwtUtil.getUserIdFromToken(jwt), authorizationHeader, null))
            .flatMapMany(userContext -> {
                if (userContext.getClientProfile() == null) {
                     return Flux.error(new IllegalStateException("L'utilisateur n'est pas un client."));
                }
                return productRepository.findByClientIdAndCategoryId(userContext.getUserId(), ANNOUNCEMENT_CATEGORY_ID);
            });
    }

    /**
     * SECURISE (CLIENT): Crée une nouvelle annonce pour le client connecté.
     */
    @PostMapping
    public Mono<ResponseEntity<Product>> createAnnouncement(
            @RequestBody CreateProductRequest request,
            @AuthenticationPrincipal Mono<Jwt> jwtMono,
            @RequestHeader("Authorization") String authorizationHeader) {

        return jwtMono
            .flatMap(jwt -> profileService.getUserSessionContext(JwtUtil.getUserIdFromToken(jwt), authorizationHeader, null))
            .flatMap(userContext -> {
                if (userContext.getClientProfile() == null) {
                    return Mono.error(new IllegalStateException("Seul un client peut créer une annonce."));
                }
                if (userContext.getOrganisation() == null || userContext.getOrganisation().getOrganizationId() == null) {
                    return Mono.error(new IllegalStateException("Contexte utilisateur invalide pour créer une annonce (organisation manquante)."));
                }
                ClientProfile clientProfile = userContext.getClientProfile(); 
                
                request.setCategoryId(ANNOUNCEMENT_CATEGORY_ID);
                request.setClientId(clientProfile.getUserId());
                request.setClientName(clientProfile.getFirstName() + " " + clientProfile.getLastName());
                request.setClientPhoneNumber(clientProfile.getPhoneNumber());
                request.setClientProfileImageUrl(clientProfile.getProfileImageUrl());

                return resourceService.createProduct(userContext.getOrganisation().getOrganizationId(), request, authorizationHeader, null);
            })
            .map(createdProduct -> new ResponseEntity<>(createdProduct, HttpStatus.CREATED));
    }

    /**
     * SECURISE (CLIENT): Met à jour une annonce appartenant au client connecté.
     */
    @PutMapping("/{productId}")
    public Mono<ResponseEntity<Product>> updateAnnouncement(
            @PathVariable UUID productId,
            @RequestBody CreateProductRequest request,
            @AuthenticationPrincipal Mono<Jwt> jwtMono,
            @RequestHeader("Authorization") String authorizationHeader) {
        
        return jwtMono
            .flatMap(jwt -> profileService.getUserSessionContext(JwtUtil.getUserIdFromToken(jwt), authorizationHeader, null))
            .flatMap(userContext -> {
                if (userContext.getClientProfile() == null) {
                    return Mono.error(new IllegalStateException("Seuls les clients peuvent modifier leurs annonces."));
                }
                if (userContext.getOrganisation() == null || userContext.getOrganisation().getOrganizationId() == null) {
                    return Mono.error(new IllegalStateException("Contexte utilisateur invalide pour mettre à jour une annonce (organisation manquante)."));
                }
                ClientProfile clientProfile = userContext.getClientProfile();

                return productRepository.findById(new ProductKey(userContext.getOrganisation().getOrganizationId(), productId))
                        .filter(product -> clientProfile.getUserId().equals(product.getClientId()))
                        .switchIfEmpty(Mono.error(new SecurityException("Le client n'est pas autorisé à modifier cette annonce ou elle n'existe pas.")))
                        .flatMap(existingAnnouncement -> {
                            return resourceService.updateProduct(userContext.getOrganisation().getOrganizationId(), productId, request, authorizationHeader, null);
                        });
            })
            .doOnSuccess(updatedAnnouncement -> {
                if (updatedAnnouncement != null) {
                    socketIOServer.getBroadcastOperations().sendEvent("updated_announcement", updatedAnnouncement);
                }
            })
            .map(ResponseEntity::ok)
            .defaultIfEmpty(ResponseEntity.notFound().build());
    }
    
    /**
     * SECURISE (CLIENT): Supprime une annonce appartenant au client connecté.
     */
    @DeleteMapping("/{productId}")
    public Mono<ResponseEntity<Void>> deleteAnnouncement(
            @PathVariable UUID productId,
            @AuthenticationPrincipal Mono<Jwt> jwtMono,
            @RequestHeader("Authorization") String authorizationHeader) {

        return jwtMono
            .flatMap(jwt -> profileService.getUserSessionContext(JwtUtil.getUserIdFromToken(jwt), authorizationHeader, null))
            .flatMap(userContext -> {
                if (userContext.getClientProfile() == null) {
                    return Mono.error(new IllegalStateException("Seuls les clients peuvent supprimer leurs annonces."));
                }
                if (userContext.getOrganisation() == null || userContext.getOrganisation().getOrganizationId() == null) {
                    return Mono.error(new IllegalStateException("Contexte utilisateur invalide pour supprimer une annonce (organisation manquante)."));
                }
                ClientProfile clientProfile = userContext.getClientProfile();

                return productRepository.findById(new ProductKey(userContext.getOrganisation().getOrganizationId(), productId))
                        .filter(product -> clientProfile.getUserId().equals(product.getClientId()))
                        .switchIfEmpty(Mono.error(new SecurityException("Le client n'est pas autorisé à supprimer cette annonce ou elle n'existe pas.")))
                        .flatMap(existingAnnouncement ->
                            resourceService.deleteProduct(userContext.getOrganisation().getOrganizationId(), productId, authorizationHeader, null)
                        );
            })
            .then(Mono.just(new ResponseEntity<Void>(HttpStatus.NO_CONTENT)));
    }

    /**
     * SECURISE (CONDUCTEUR): Permet à un conducteur de POSTULER à une annonce.
     * Le statut de l'annonce passe à "PendingConfirmation". Une notification est envoyée au client.
     */
    @PostMapping("/{announcementId}/apply")
    public Mono<ResponseEntity<Product>> applyToAnnouncement(
            @PathVariable UUID announcementId,
            @AuthenticationPrincipal Mono<Jwt> jwtMono,
            @RequestHeader("Authorization") String authorizationHeader) {

        return jwtMono
            .flatMap(jwt -> profileService.getUserSessionContext(JwtUtil.getUserIdFromToken(jwt), authorizationHeader, null))
            .flatMap(driverContext -> {
                if (driverContext.getDriverProfile() == null) {
                    return Mono.error(new IllegalStateException("Seul un chauffeur peut postuler à une annonce."));
                }
                DriverProfile driverProfile = driverContext.getDriverProfile();
                
                return productRepository.findAll().filter(p -> p.getId().equals(announcementId)).next()
                    .flatMap(announcement -> {
                         ProductKey key = new ProductKey(announcement.getOrganizationId(), announcementId);
                         return productRepository.findById(key)
                            .flatMap(ann -> {
                                if (ann.getReservedByDriverId() != null) {
                                    return Mono.error(new IllegalStateException("Cette annonce a déjà été postulée/réservée."));
                                }
                                ann.setReservedByDriverId(driverProfile.getUserId());
                                ann.setReservedByDriverName(driverProfile.getFirstName() + " " + driverProfile.getLastName());
                                ann.setStatus("PendingConfirmation");
                                log.info("Chauffeur {} a postulé pour l'annonce {}. Statut mis à jour à 'PendingConfirmation'.", driverProfile.getUserId(), announcementId);
                                return productRepository.save(ann);
                            })
                            .flatMap(updatedAnnouncement -> {
                                socketIOServer.getBroadcastOperations().sendEvent("updated_announcement", updatedAnnouncement);
                                log.info("Déclenchement de la notification pour le client de l'annonce {} (postulation par chauffeur {}).", announcementId, driverProfile.getUserId());
                                return notificationTriggerService.notifyClientOfAcceptedAnnouncement(updatedAnnouncement, driverProfile)
                                    .thenReturn(updatedAnnouncement);
                            });
                    });
            })
            .map(ResponseEntity::ok)
            .defaultIfEmpty(ResponseEntity.notFound().build());
    }

    /**
     * SECURISE (CONDUCTEUR): Permet à un CONDUCTEUR d'annuler une postulation.
     * Le statut de l'annonce revient à "Published". Une notification est envoyée au client.
     */
    @PostMapping("/{announcementId}/cancel-postulation") // <-- NOUVEL ENDPOINT POUR L'ANNULATION
    public Mono<ResponseEntity<Product>> cancelPostulation(
            @PathVariable UUID announcementId,
            @AuthenticationPrincipal Mono<Jwt> jwtMono,
            @RequestHeader("Authorization") String authorizationHeader) {

        return jwtMono
            .flatMap(jwt -> profileService.getUserSessionContext(JwtUtil.getUserIdFromToken(jwt), authorizationHeader, null))
            .flatMap(driverContext -> {
                if (driverContext.getDriverProfile() == null) {
                    return Mono.error(new IllegalStateException("Seul un chauffeur peut annuler une postulation."));
                }
                DriverProfile driverProfile = driverContext.getDriverProfile();

                return productRepository.findAll().filter(p -> p.getId().equals(announcementId)).next()
                    .flatMap(announcement -> {
                        if (!driverProfile.getUserId().equals(announcement.getReservedByDriverId())) {
                            return Mono.error(new SecurityException("Vous n'avez pas postulé à cette annonce ou n'êtes pas le chauffeur concerné."));
                        }
                        if (!"PendingConfirmation".equalsIgnoreCase(announcement.getStatus()) && !"Ongoing".equalsIgnoreCase(announcement.getStatus())) {
                            return Mono.error(new IllegalStateException("L'annonce n'est pas dans un état permettant l'annulation de postulation (statut actuel: " + announcement.getStatus() + ")."));
                        }

                        ProductKey key = new ProductKey(announcement.getOrganizationId(), announcementId);
                        return productRepository.findById(key)
                            .flatMap(ann -> {
                                ann.setReservedByDriverId(null);
                                ann.setReservedByDriverName(null);
                                ann.setStatus("Published"); // Revenir au statut "Published"
                                log.info("Chauffeur {} a annulé sa postulation pour l'annonce {}. Statut remis à 'Published'.", driverProfile.getUserId(), announcementId);
                                return productRepository.save(ann);
                            })
                            .flatMap(updatedAnnouncement -> {
                                socketIOServer.getBroadcastOperations().sendEvent("updated_announcement", updatedAnnouncement);
                                log.info("Déclenchement de la notification pour le client de l'annonce {} (annulation de postulation par chauffeur {}).", announcementId, driverProfile.getUserId());
                                return notificationTriggerService.notifyClientOfCancelledPostulation(updatedAnnouncement, driverProfile)
                                    .thenReturn(updatedAnnouncement);
                            });
                    });
            })
            .map(ResponseEntity::ok)
            .defaultIfEmpty(ResponseEntity.notFound().build());
    }

    /**
     * SECURISE (CLIENT): Permet au CLIENT de confirmer (accepter) un chauffeur qui a postulé à son annonce.
     * Le statut de l'annonce passe à "Ongoing" et une notification est envoyée au chauffeur.
     */
    @PostMapping("/{announcementId}/confirm")
    public Mono<ResponseEntity<Product>> confirmDriverForAnnouncement(
            @PathVariable UUID announcementId,
            @RequestParam UUID driverId, 
            @AuthenticationPrincipal Mono<Jwt> jwtMono,
            @RequestHeader("Authorization") String authorizationHeader) {

        return jwtMono
            .flatMap(jwt -> profileService.getUserSessionContext(JwtUtil.getUserIdFromToken(jwt), authorizationHeader, null))
            .flatMap(clientContext -> {
                if (clientContext.getClientProfile() == null) {
                    return Mono.error(new IllegalStateException("Seul un client peut confirmer un chauffeur pour son annonce."));
                }
                ClientProfile clientProfile = clientContext.getClientProfile();

                return productRepository.findAll().filter(p -> p.getId().equals(announcementId)).next()
                    .flatMap(announcement -> {
                        if (!announcement.getClientId().equals(clientProfile.getUserId())) {
                            return Mono.error(new SecurityException("Le client n'est pas l'auteur de cette annonce."));
                        }
                        if (!"PendingConfirmation".equalsIgnoreCase(announcement.getStatus()) || !announcement.getReservedByDriverId().equals(driverId)) {
                             return Mono.error(new IllegalStateException("Cette annonce n'est pas en attente de confirmation pour ce chauffeur, ou le statut est incorrect."));
                        }

                        ProductKey key = new ProductKey(announcement.getOrganizationId(), announcementId);
                        return productRepository.findById(key)
                            .flatMap(ann -> {
                                ann.setStatus("Ongoing");
                                log.info("Client {} a confirmé le chauffeur {} pour l'annonce {}. Statut mis à jour à 'Ongoing'.", clientProfile.getUserId(), driverId, announcementId);
                                return productRepository.save(ann);
                            })
                            .flatMap(updatedAnnouncement -> 
                                profileService.findDriverById(driverId)
                                    .flatMap(driverProfile -> notificationTriggerService.notifyDriverOfConfirmedAnnouncement(updatedAnnouncement, driverProfile))
                                    .thenReturn(updatedAnnouncement)
                            );
                    });
            })
            .map(ResponseEntity::ok)
            .defaultIfEmpty(ResponseEntity.notFound().build());
    }

    /**
     * SECURISE (CONDUCTEUR): Récupère les courses que le conducteur connecté a acceptées.
     */
    @GetMapping("/my-rides")
    public Flux<Product> getMyAcceptedRides(@AuthenticationPrincipal Mono<Jwt> jwtMono,
                                            @RequestHeader("Authorization") String authorizationHeader) {
        return jwtMono
            .flatMap(jwt -> profileService.getUserSessionContext(JwtUtil.getUserIdFromToken(jwt), authorizationHeader, null))
            .flatMapMany(userContext -> {
                 if (userContext.getDriverProfile() == null) {
                     return Flux.error(new IllegalStateException("L'utilisateur n'est pas un chauffeur."));
                }
                UUID driverId = userContext.getUserId();
                log.info("Récupération des courses acceptées/postulées par le chauffeur {}", driverId);
                
                return productRepository.findByReservedByDriverId(driverId)
                           .flatMap(this::enrichProductWithAuthorDetails)
                           .doOnNext(product -> {
                               // Debugging log pour voir les produits enrichis avant de les envoyer
                               log.info("DEBUG_BACKEND_OFFERS: Produit complet enrichi envoyé pour driver {}: Id='{}', Title='{}', AuthorName='{}', Cost={}, ReservedByDriverName='{}'", 
                                        driverId, product.getId(), product.getName(), product.getAuthorName(), product.getDefaultSellPrice(), product.getReservedByDriverName());
                           });
            });
    }


    /**
     * Méthode privée pour enrichir une annonce avec les détails de son auteur (client).
     */
    private Mono<Product> enrichProductWithAuthorDetails(Product product) {
        UUID authorId = product.getClientId();
        if (authorId == null) {
            return Mono.just(product);
        }

        return profileService.findClientById(authorId)
            .map(clientProfile -> {
                product.setAuthorId(clientProfile.getUserId());
                product.setAuthorName(clientProfile.getFirstName() + " " + clientProfile.getLastName());
                product.setAuthorPhoneNumber(clientProfile.getPhoneNumber());
                product.setAuthorProfileImageUrl(clientProfile.getProfileImageUrl());
                return product;
            })
            .defaultIfEmpty(product); 
    }
}// END OF FILE: src/main/java/com/freelance/driver_backend/controller/AnnouncementController.java

//---> PATH: /home/mbogneng-junior/freelance-driver_Sylladb/backend/src/main/java/com/freelance/driver_backend/controller/AuthController.java

package com.freelance.driver_backend.controller;

import com.freelance.driver_backend.dto.external.LoginRequest;
import com.freelance.driver_backend.dto.external.NotificationRequest;
import com.freelance.driver_backend.dto.external.RegistrationRequest; // Garder cet import
import com.freelance.driver_backend.dto.onboarding.OnboardingResponse;
import com.freelance.driver_backend.model.OtpVerification; // Garder cet import
import com.freelance.driver_backend.repository.OtpVerificationRepository; // Garder cet import
import com.freelance.driver_backend.service.LoginService;
import com.freelance.driver_backend.service.external.AuthService; // Garder cet import
import com.freelance.driver_backend.service.external.NotificationService;
import io.github.cdimascio.dotenv.Dotenv;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Value; // Garder cet import
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;
import reactor.core.publisher.Mono;

import java.time.Instant;
import java.time.temporal.ChronoUnit;
import java.util.List;
import java.util.Map;
import java.util.Random;
import java.util.UUID;

@RestController
@RequestMapping("/api") // Le mapping doit être "/api" pour que /api/register fonctionne
@RequiredArgsConstructor
@Slf4j
public class AuthController {

    private final LoginService loginService;
    private final OtpVerificationRepository otpVerificationRepository; // Réactiver l'injection
    private final NotificationService notificationService;
    private final Dotenv dotenv;
    private final AuthService authService; // Réactiver l'injection

    @Value("${freelancedriver.oauth2.client-id}")
    private String oauthClientId;
    @Value("${freelancedriver.oauth2.client-secret}")
    private String oauthClientSecret;


    @PostMapping("/auth/login") // La route de login reste sous /api/auth/login
    public Mono<ResponseEntity<OnboardingResponse>> login(@RequestBody LoginRequest loginRequest) {
        return loginService.loginAndGetContext(loginRequest)
                .doOnNext(response -> {
                    log.info("▶️ Backend DEBUG: Réponse Login envoyée au frontend: {}", response);
                })
                .map(ResponseEntity::ok)
                .defaultIfEmpty(ResponseEntity.status(401).build());
    }

    /**
     * Gère l'inscription initiale : enregistre l'utilisateur via l'API externe,
     * puis génère et envoie l'OTP.
     * Cet endpoint est appelé par `SignUp.tsx`.
     */
    /* @PostMapping("/register") // CETTE ROUTE DOIT ÊTRE RÉACTIVÉE
    public Mono<ResponseEntity<Map<String, String>>> registerUserAndInitiateOtp(@RequestBody RegistrationRequest request) {
        String email = request.getEmail();
        String firstName = request.getFirstName();
        
        log.info("▶️ Début du processus d'inscription (API externe) et OTP pour l'email: {}", email);
        
        // 1. Obtenir le token M2M (Machine-to-Machine)
        return authService.getClientCredentialsToken(oauthClientId, oauthClientSecret)
            .flatMap(m2mTokenResponse -> {
                String m2mBearerToken = "Bearer " + m2mTokenResponse.getAccessToken();

                // 2. Enregistrer l'utilisateur auprès du service d'authentification externe réel
                return authService.registerUser(request, m2mBearerToken)
                    .flatMap(userDto -> {
                        log.info("✅ Utilisateur '{}' enregistré avec succès via l'API externe. ID: {}", userDto.getEmail(), userDto.getId());
                        
                        // 3. Générer et sauvegarder l'OTP localement
                        String otp = String.format("%06d", new Random().nextInt(999999));
                        OtpVerification newVerification = new OtpVerification();
                        newVerification.setEmail(email);
                        newVerification.setOtpCode(otp);
                        newVerification.setExpiresAt(Instant.now().plus(10, ChronoUnit.MINUTES));
                        
                        return otpVerificationRepository.save(newVerification);
                    })
                    .flatMap(savedOtp -> {
                        log.info("✅ OTP {} sauvegardé localement pour {}", savedOtp.getOtpCode(), email);

                        // 4. Envoyer l'email OTP via le service de notification (mock ou réel, selon le profil)
                        UUID otpTemplateId = UUID.fromString(dotenv.get("TEMPLATE_EMAIL_OTP_ID"));
                        UUID tempOrgId = UUID.fromString(dotenv.get("SYSTEM_ORGANIZATION_ID"));

                        NotificationRequest otpRequest = NotificationRequest.builder()
                            .templateId(otpTemplateId)
                            .recipients(List.of(email))
                            .metadata(Map.of("firstName", firstName, "otpCode", savedOtp.getOtpCode()))
                            .build();
                        
                        return notificationService.sendEmailNotification(tempOrgId, otpRequest, null, null);
                    })
                    .map(success -> {
                        if (Boolean.TRUE.equals(success)) {
                            log.info("✅ Email OTP envoyé avec succès à {}", email);
                            return ResponseEntity.status(HttpStatus.CREATED).body(Map.of("message", "Utilisateur enregistré, OTP envoyé."));
                        } else {
                            log.error("❌ Échec de l'envoi de l'email OTP à {}", email);
                            return ResponseEntity.status(HttpStatus.ACCEPTED).body(Map.of("message", "Utilisateur enregistré, mais l'email OTP n'a pas pu être envoyé."));
                        }
                    })
                    .onErrorResume(RuntimeException.class, e -> {
                        log.error("❌ Erreur lors de l'inscription ou de l'envoi de l'OTP pour {}: {}", email, e.getMessage());
                        return Mono.just(ResponseEntity.status(HttpStatus.BAD_REQUEST).body(Map.of("message", e.getMessage())));
                    });
            });
    } */

        @PostMapping("/register") // CETTE ROUTE DOIT ÊTRE RÉACTIVÉE
    public Mono<ResponseEntity<Map<String, String>>> registerUserAndInitiateOtp(@RequestBody RegistrationRequest request) {
        String email = request.getEmail();
        String firstName = request.getFirstName();
        
        log.info("▶️ Début du processus d'inscription (API externe) et OTP pour l'email: {}", email);
        
        // Le token M2M n'est plus requis pour l'enregistrement de l'utilisateur.
        // L'appel à getClientCredentialsToken est donc supprimé ici.
        String m2mBearerToken = "Bearer BQC5Zt6s9y$C&F)J@NcRfUjXn2r5u8x/";
        // 1. Enregistrer l'utilisateur auprès du service d'authentification externe.
        return authService.registerUser(request,m2mBearerToken)
            .flatMap(userDto -> {
                log.info("✅ Utilisateur '{}' enregistré avec succès via l'API externe. ID: {}", userDto.getEmail(), userDto.getId());
                
                // 2. Générer et sauvegarder l'OTP localement
                String otp = String.format("%06d", new Random().nextInt(999999));
                OtpVerification newVerification = new OtpVerification();
                newVerification.setEmail(email);
                newVerification.setOtpCode(otp);
                
                newVerification.setExpiresAt(Instant.now().plus(10, ChronoUnit.MINUTES));
                
                return otpVerificationRepository.save(newVerification);
            })
            .flatMap(savedOtp -> {
                log.info("✅ OTP {} sauvegardé localement pour {}", savedOtp.getOtpCode(), email);

                // 3. Envoyer l'email OTP via le service de notification
                UUID otpTemplateId = UUID.fromString(dotenv.get("TEMPLATE_EMAIL_OTP_ID"));
                UUID tempOrgId = UUID.fromString(dotenv.get("SYSTEM_ORGANIZATION_ID"));

                NotificationRequest otpRequest = NotificationRequest.builder()
                    .templateId(otpTemplateId)
                    .recipients(List.of(email))
                    .metadata(Map.of("firstName", firstName, "otpCode", savedOtp.getOtpCode()))
                    .build();
                
                // Note: L'envoi de notification pourrait nécessiter un token M2M.
                // Si c'est le cas, l'appel à getClientCredentialsToken devrait être replacé ici.
                return notificationService.sendEmailNotification(tempOrgId, otpRequest, null, null);
            })
            .map(success -> {
                if (Boolean.TRUE.equals(success)) {
                    log.info("✅ Email OTP envoyé avec succès à {}", email);
                    return ResponseEntity.status(HttpStatus.CREATED).body(Map.of("message", "Utilisateur enregistré, OTP envoyé."));
                } else {
                    log.error("❌ Échec de l'envoi de l'email OTP à {}", email);
                    return ResponseEntity.status(HttpStatus.ACCEPTED).body(Map.of("message", "Utilisateur enregistré, mais l'email OTP n'a pas pu être envoyé."));
                }
            })
            .onErrorResume(RuntimeException.class, e -> {
                log.error("❌ Erreur lors de l'inscription ou de l'envoi de l'OTP pour {}: {}", email, e.getMessage());
                return Mono.just(ResponseEntity.status(HttpStatus.BAD_REQUEST).body(Map.of("message", e.getMessage())));
            });
    }
}// END OF FILE: src/main/java/com/freelance/driver_backend/controller/AuthController.java

//---> PATH: /home/mbogneng-junior/freelance-driver_Sylladb/backend/src/main/java/com/freelance/driver_backend/controller/DriverSearchController.java



// PATH: /home/mbogneng-junior/freelance-driver (Copie)/backend/src/main/java/com/freelance/driver_backend/controller/DriverSearchController.java

package com.freelance.driver_backend.controller;

import com.freelance.driver_backend.model.Resource;
import com.freelance.driver_backend.service.resource.ResourceService;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;
import reactor.core.publisher.Flux;

@RestController
@RequestMapping("/api/search")
@RequiredArgsConstructor
@Slf4j
public class DriverSearchController {

    private final ResourceService resourceService;
    private static final String PLANNING_CATEGORY_ID = "ba75b2c0-30a8-11f0-a5b5-bb7d33c83c13";

    @GetMapping("/drivers")
    public Flux<Resource> findAvailableDrivers() {
        log.info("-> Requête PUBLIQUE reçue pour GET /api/search/drivers");
        return resourceService.getResourcesByCategory(PLANNING_CATEGORY_ID)
                .filter(resource -> "AVAILABLE".equalsIgnoreCase(resource.getState()))
                .doOnNext(resource -> log.info("--> Planning publié trouvé : {}", resource.getName()));
    }
}// END OF FILE: src/main/java/com/freelance/driver_backend/controller/DriverSearchController.java

//---> PATH: /home/mbogneng-junior/freelance-driver_Sylladb/backend/src/main/java/com/freelance/driver_backend/controller/ExperienceController.java


// PATH: /home/mbogneng-junior/freelance-driver (Copie)/backend/src/main/java/com/freelance/driver_backend/controller/ExperienceController.java

package com.freelance.driver_backend.controller;

import com.freelance.driver_backend.dto.CreateProductRequest; // Ajouté pour les méthodes POST/PUT
import com.freelance.driver_backend.dto.UserSessionContextDto; // Nouveau import
import com.freelance.driver_backend.model.DriverProfile; // Nouveau import
import com.freelance.driver_backend.model.Product;
import com.freelance.driver_backend.service.ProfileService;
import com.freelance.driver_backend.service.ResourceService;
import com.freelance.driver_backend.util.JwtUtil; // Ajouté pour les méthodes POST/PUT
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.http.HttpStatus; // Ajouté pour les ResponseEntity
import org.springframework.http.ResponseEntity; // Ajouté pour les ResponseEntity
import org.springframework.security.core.annotation.AuthenticationPrincipal; // Ajouté pour les méthodes POST/PUT
import org.springframework.security.oauth2.jwt.Jwt; // Ajouté pour les méthodes POST/PUT
import org.springframework.web.bind.annotation.*;
import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;

import java.util.Optional;
import java.util.UUID;

@RestController
@RequestMapping("/api/experiences")
@RequiredArgsConstructor
@Slf4j
public class ExperienceController {

    private final ProfileService profileService;
    private final ResourceService resourceService;

    // UUID fixe pour la catégorie "expériences"
    private static final UUID EXPERIENCE_CATEGORY_ID = UUID.fromString("e1f2a3b4-c5d6-7890-1234-567890abcdef");
    private static final UUID DRIVER_LICENSE_CATEGORY_ID = UUID.fromString("f1c2b3d4-e5f6-7890-1234-567890abcdef"); // Du frontend
    private static final UUID CV_CATEGORY_ID = UUID.fromString("a1b2c3d4-e5f6-7890-1234-567890fedcba"); // Du frontend


    /**
     * PUBLIC: Récupère les expériences d'un utilisateur spécifique par son ID.
     */
    @GetMapping("/user/{userId}")
    public Flux<Product> getExperiencesForUser(
            @PathVariable UUID userId,
            @RequestHeader(value = "Authorization", required = false) String authorizationHeader
    ) {
        log.info("▶️ [ExperienceController] Récupération des expériences pour l'utilisateur ID: {}", userId);

        String token = Optional.ofNullable(authorizationHeader).orElse(null);

        // MODIFIÉ : Récupère l'organisation ID du userId spécifié.
        // Puis, filtre les produits de cette organisation qui appartiennent à ce userId.
        return profileService.findOrganisationIdByUserId(userId)
                .flatMapMany(orgId -> resourceService.getProductsByCategory(orgId, EXPERIENCE_CATEGORY_ID, token, null)
                                                    .filter(product -> userId.equals(product.getClientId())));
    }
    
    /**
     * SECURISE (CONDUCTEUR): Crée une nouvelle expérience/document pour le chauffeur connecté.
     */
    @PostMapping
    public Mono<ResponseEntity<Product>> createExperienceOrDocument(
            @RequestBody CreateProductRequest request,
            @AuthenticationPrincipal Mono<Jwt> jwtMono,
            @RequestHeader("Authorization") String authorizationHeader) {

        return jwtMono
            .flatMap(jwt -> profileService.getUserSessionContext(JwtUtil.getUserIdFromToken(jwt), authorizationHeader, null))
            .flatMap(userContext -> {
                if (userContext.getDriverProfile() == null) {
                    return Mono.error(new IllegalStateException("Seuls les chauffeurs peuvent gérer leurs expériences/documents."));
                }
                if (userContext.getOrganisation() == null || userContext.getOrganisation().getOrganizationId() == null) {
                    return Mono.error(new IllegalStateException("Contexte utilisateur invalide (organisation manquante)."));
                }
                DriverProfile driverProfile = userContext.getDriverProfile();

                // Assurez-vous que la catégorie est définie dans la requête.
                if (request.getCategoryId() == null ||
                    (!request.getCategoryId().equals(EXPERIENCE_CATEGORY_ID) &&
                     !request.getCategoryId().equals(DRIVER_LICENSE_CATEGORY_ID) &&
                     !request.getCategoryId().equals(CV_CATEGORY_ID))) {
                    return Mono.error(new IllegalArgumentException("Catégorie d'expérience/document invalide ou manquante."));
                }

                request.setClientId(driverProfile.getUserId()); // L'ID du chauffeur est le propriétaire
                request.setClientName(driverProfile.getFirstName() + " " + driverProfile.getLastName());
                request.setClientPhoneNumber(driverProfile.getPhoneNumber());
                request.setClientProfileImageUrl(driverProfile.getProfileImageUrl());
                
                log.info("▶️ Controller: Création d'une expérience/document (catégorie: {}) pour le chauffeur {}", request.getCategoryId(), driverProfile.getUserId());
                
                return resourceService.createProduct(
                    userContext.getOrganisation().getOrganizationId(), 
                    request, 
                    authorizationHeader, 
                    null
                );
            })
            .map(createdProduct -> new ResponseEntity<>(createdProduct, HttpStatus.CREATED));
    }

    /**
     * SECURISE (CONDUCTEUR): Met à jour une expérience/document existant.
     */
    @PutMapping("/{productId}")
    public Mono<ResponseEntity<Product>> updateExperienceOrDocument(
            @PathVariable UUID productId,
            @RequestBody CreateProductRequest request,
            @AuthenticationPrincipal Mono<Jwt> jwtMono,
            @RequestHeader("Authorization") String authorizationHeader) {
        
        return jwtMono
            .flatMap(jwt -> profileService.getUserSessionContext(JwtUtil.getUserIdFromToken(jwt), authorizationHeader, null))
            .flatMap(userContext -> {
                if (userContext.getDriverProfile() == null) {
                    return Mono.error(new IllegalStateException("Seuls les chauffeurs peuvent modifier leurs expériences/documents."));
                }
                if (userContext.getOrganisation() == null || userContext.getOrganisation().getOrganizationId() == null) {
                    return Mono.error(new IllegalStateException("Contexte utilisateur invalide (organisation manquante)."));
                }
                DriverProfile driverProfile = userContext.getDriverProfile();

                 // Assurez-vous que la catégorie est définie dans la requête.
                if (request.getCategoryId() == null ||
                    (!request.getCategoryId().equals(EXPERIENCE_CATEGORY_ID) &&
                     !request.getCategoryId().equals(DRIVER_LICENSE_CATEGORY_ID) &&
                     !request.getCategoryId().equals(CV_CATEGORY_ID))) {
                    return Mono.error(new IllegalArgumentException("Catégorie d'expérience/document invalide ou manquante."));
                }
                
                // Vérification cruciale : l'utilisateur connecté est-il le propriétaire ?
                return resourceService.getProductsByCategory(userContext.getOrganisation().getOrganizationId(), request.getCategoryId(), authorizationHeader, null)
                        .filter(product -> product.getId().equals(productId) && driverProfile.getUserId().equals(product.getClientId()))
                        .next()
                        .switchIfEmpty(Mono.error(new SecurityException("Le chauffeur n'est pas autorisé à modifier cet élément ou il n'existe pas.")))
                        .flatMap(existingProduct -> {
                            request.setClientId(driverProfile.getUserId()); // Assure que le propriétaire reste le même
                            request.setClientName(driverProfile.getFirstName() + " " + driverProfile.getLastName());
                            request.setClientPhoneNumber(driverProfile.getPhoneNumber());
                            request.setClientProfileImageUrl(driverProfile.getProfileImageUrl());

                            log.info("▶️ Controller: Mise à jour de l'expérience/document ID: {}", productId);
                            
                            return resourceService.updateProduct(
                                userContext.getOrganisation().getOrganizationId(), 
                                productId,
                                request, 
                                authorizationHeader, 
                                null
                            );
                        });
            })
            .map(ResponseEntity::ok)
            .defaultIfEmpty(ResponseEntity.notFound().build());
    }

    /**
     * SECURISE (CONDUCTEUR): Supprime une expérience/document existant.
     */
    @DeleteMapping("/{productId}")
    public Mono<ResponseEntity<Void>> deleteExperienceOrDocument(
            @PathVariable UUID productId,
            @AuthenticationPrincipal Mono<Jwt> jwtMono,
            @RequestHeader("Authorization") String authorizationHeader) {

        return jwtMono
            .flatMap(jwt -> profileService.getUserSessionContext(JwtUtil.getUserIdFromToken(jwt), authorizationHeader, null))
            .flatMap(userContext -> {
                if (userContext.getDriverProfile() == null) {
                    return Mono.error(new IllegalStateException("Seuls les chauffeurs peuvent supprimer leurs expériences/documents."));
                }
                if (userContext.getOrganisation() == null || userContext.getOrganisation().getOrganizationId() == null) {
                    return Mono.error(new IllegalStateException("Contexte utilisateur invalide (organisation manquante)."));
                }
                DriverProfile driverProfile = userContext.getDriverProfile();

                // On ne peut pas facilement récupérer la catégorie ici sans re-fetch.
                // Une meilleure approche serait d'inclure la categoryId dans le path ou comme query param pour DELETE.
                // Pour l'instant, on fait un fetch large puis filtre. C'est moins performant.
                return resourceService.getProductsByCategory(userContext.getOrganisation().getOrganizationId(), EXPERIENCE_CATEGORY_ID, authorizationHeader, null)
                        .filter(product -> product.getId().equals(productId) && driverProfile.getUserId().equals(product.getClientId()))
                        .next()
                        .switchIfEmpty(Mono.error(new SecurityException("Le chauffeur n'est pas autorisé à supprimer cet élément ou il n'existe pas.")))
                        .flatMap(existingProduct -> {
                            log.info("▶️ Controller: Suppression de l'expérience/document ID: {}", productId);
                            return resourceService.deleteProduct(
                                userContext.getOrganisation().getOrganizationId(), 
                                productId,
                                authorizationHeader, 
                                null
                            );
                        });
            })
            .then(Mono.just(new ResponseEntity<Void>(HttpStatus.NO_CONTENT)));
    }
}// END OF FILE: src/main/java/com/freelance/driver_backend/controller/ExperienceController.java

//---> PATH: /home/mbogneng-junior/freelance-driver_Sylladb/backend/src/main/java/com/freelance/driver_backend/controller/MediaController.java

package com.freelance.driver_backend.controller;

import com.freelance.driver_backend.dto.external.UploadMediaResponse;
import com.freelance.driver_backend.service.StorageService;
import com.freelance.driver_backend.util.JwtUtil;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
// Retirer cet import car publicKey n'est plus directement utilisé ici
// import org.springframework.beans.factory.annotation.Value; 
import org.springframework.http.MediaType;
import org.springframework.http.ResponseEntity;
import org.springframework.http.codec.multipart.FilePart;
import org.springframework.security.core.annotation.AuthenticationPrincipal;
import org.springframework.security.oauth2.jwt.Jwt;
import org.springframework.web.bind.annotation.*;
import reactor.core.publisher.Mono;

import java.util.Map;
import java.util.UUID;

@RestController
@RequestMapping("/api/media")
@RequiredArgsConstructor
@Slf4j
public class MediaController {

    private final StorageService storageService;

    // Retirer ceci si ce n'est plus utilisé nulle part dans le contrôleur
    // @Value("${freelancedriver.api.public-key}")
    // private String publicKey;

    @PostMapping(value = "/upload", consumes = MediaType.MULTIPART_FORM_DATA_VALUE)
    public Mono<ResponseEntity<Map<String, String>>> uploadFile(
            @AuthenticationPrincipal Mono<Jwt> jwtMono,
            @RequestHeader("Authorization") String authorizationHeader, // Nous avons toujours besoin de cet en-tête pour le contrôleur lui-même pour vérifier l'utilisateur.
            @RequestPart("file") Mono<FilePart> filePartMono,
            @RequestParam("type") String frontendType,
            @RequestParam("resourceId") String resourceId) {

        return Mono.zip(jwtMono, filePartMono)
            .flatMap(tuple -> {
                Jwt jwt = tuple.getT1();
                FilePart filePart = tuple.getT2();
                UUID userId = JwtUtil.getUserIdFromToken(jwt);
                UUID targetResourceId = UUID.fromString(resourceId);

                log.info("▶️ Téléversement d'un fichier de type logique '{}' pour la ressource '{}' par l'utilisateur '{}'", frontendType, resourceId, userId);

                // Le StorageService s'occupera d'obtenir son propre token M2M
                return storageService.saveFile(
                    "product",
                    frontendType,
                    userId,
                    targetResourceId,
                    filePart.filename(),
                    filePart
                )
                .map(uploadResponse -> {
                    log.info("✅ Fichier téléversé avec succès. URL: {}, URI: {}", uploadResponse.getUrl(), uploadResponse.getUri());
                    return ResponseEntity.ok(Map.of("url", uploadResponse.getUrl(), "uri", uploadResponse.getUri()));
                });
            });
    }
}// END OF FILE: src/main/java/com/freelance/driver_backend/controller/MediaController.java

//---> PATH: /home/mbogneng-junior/freelance-driver_Sylladb/backend/src/main/java/com/freelance/driver_backend/controller/MockProductController.java

package com.freelance.driver_backend.controller;

import com.freelance.driver_backend.dto.CreateProductRequest;
import com.freelance.driver_backend.model.Product;
import com.freelance.driver_backend.model.ProductKey;
import com.freelance.driver_backend.repository.ProductRepository;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.context.annotation.Profile;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;
import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;

import java.util.UUID;

@RestController
@RequestMapping("/api/mock-products/{organizationId}")
@RequiredArgsConstructor
@Slf4j

public class MockProductController {

    private final ProductRepository productRepository;

    /**
     * Crée un nouveau "produit" (annonce, véhicule, adresse, etc.).
     */
    @PostMapping
    public Mono<ResponseEntity<Product>> createProduct(
            @PathVariable UUID organizationId,
            @RequestBody CreateProductRequest request) {

        log.warn("[MOCK-CONTROLLER] Création d'un produit pour l'organisation {}. Request reçue: {}", organizationId,
                request);
        // AJOUT : Inclure l'ID de la requête dans les logs pour le diagnostic
        log.warn("[MOCK-CONTROLLER] Request details: clientId={}, categoryId={}, name={}, requestedId={}",
                request.getClientId(), request.getCategoryId(), request.getName(), request.getId());

        Product newProduct = new Product();
        ProductKey key;

        // --- CORRECTION : Utiliser l'ID fourni par le frontend si présent ---
        if (request.getId() != null && !request.getId().isEmpty()) {
            try {
                // Tenter de convertir l'ID fourni en UUID
                key = new ProductKey(organizationId, UUID.fromString(request.getId()));
                log.warn("[MOCK-CONTROLLER] Création de produit avec ID fourni par le frontend: {}", request.getId());
            } catch (IllegalArgumentException e) {
                // Si l'ID fourni n'est pas un UUID valide, rejeter la requête
                log.error("[MOCK-CONTROLLER] ID de produit fourni invalide par le frontend: {}", request.getId(), e);
                return Mono.error(new IllegalArgumentException("L'ID de produit fourni par le frontend est invalide."));
            }
        } else {
            // Si aucun ID n'est fourni, générer un nouvel UUID
            key = new ProductKey(organizationId, UUID.randomUUID());
            log.warn("[MOCK-CONTROLLER] Création de produit avec ID généré (aucun fourni): {}", key.getId());
        }
        newProduct.setKey(key);

        // On utilise la méthode centralisée pour remplir l'objet
        updateProductFromRequest(newProduct, request);

        log.warn(
                "[MOCK-CONTROLLER] Objet Product construit avant sauvegarde: ID={}, OrgID={}, ClientID={}, CatID={}, Nom='{}'",
                newProduct.getId(), newProduct.getOrganizationId(), newProduct.getClientId(),
                newProduct.getCategoryId(), newProduct.getName());

        return productRepository.save(newProduct)
                .map(savedProduct -> {
                    log.warn(
                            "[MOCK-CONTROLLER] Produit sauvegardé avec succès. ID: {}, OrgID: {}, ClientID: {}, CatID: {}, Nom: '{}', Statut: '{}'",
                            savedProduct.getId(), savedProduct.getOrganizationId(), savedProduct.getClientId(),
                            savedProduct.getCategoryId(), savedProduct.getName(), savedProduct.getStatus());
                    return new ResponseEntity<>(savedProduct, HttpStatus.CREATED);
                });
    }

    /**
     * Récupère les "produits" d'une organisation, filtrés par catégorie.
     */
    @GetMapping
    public Flux<Product> getProductsByCategory(
            @PathVariable UUID organizationId,
            @RequestParam UUID categoryId) {
        log.warn("[MOCK-CONTROLLER] Récupération des produits pour org {} et catégorie {}", organizationId, categoryId);
        return productRepository.findByKeyOrganizationIdAndCategoryId(organizationId, categoryId);
    }

    /**
     * Met à jour un "produit" existant.
     */
    @PutMapping("/{productId}")
    public Mono<ResponseEntity<Product>> updateProduct(
            @PathVariable UUID organizationId,
            @PathVariable UUID productId,
            @RequestBody CreateProductRequest request) {

        ProductKey key = new ProductKey(organizationId, productId);
        log.warn("[MOCK-CONTROLLER] Mise à jour du produit avec la clé {}. Données reçues : {}", key, request);

        return productRepository.findById(key)
                .flatMap(existingProduct -> {
                    log.info("Produit existant trouvé : {}", existingProduct);
                    updateProductFromRequest(existingProduct, request);
                    log.info("Produit après mise à jour (avant sauvegarde) : {}", existingProduct);
                    return productRepository.save(existingProduct);
                })
                .map(savedProduct -> {
                    log.info("Produit sauvegardé avec succès : {}", savedProduct);
                    return ResponseEntity.ok(savedProduct);
                })
                .defaultIfEmpty(ResponseEntity.notFound().build());
    }

    /**
     * Supprime un "produit".
     */
    @DeleteMapping("/{productId}")
    public Mono<ResponseEntity<Void>> deleteProduct(
            @PathVariable UUID organizationId,
            @PathVariable UUID productId) {

        ProductKey key = new ProductKey(organizationId, productId);
        log.warn("[MOCK-CONTROLLER] Suppression du produit avec la clé {}", key);

        return productRepository.deleteById(key)
                .then(Mono.just(new ResponseEntity<Void>(HttpStatus.NO_CONTENT)));
    }

    /**
     * Méthode utilitaire privée pour mapper les champs d'une CreateProductRequest
     * vers un objet Product. Centralise la logique pour éviter la répétition
     * entre les méthodes createProduct et updateProduct.
     */
    private void updateProductFromRequest(Product product, CreateProductRequest request) {
        product.setName(request.getName());
        product.setDefaultSellPrice(request.getDefaultSellPrice());
        product.setShortDescription(request.getShortDescription());

        if (request.getCategoryId() != null) {
            product.setCategoryId(request.getCategoryId());
        }

        product.setIsActive(request.getIsActive());
        product.setPickupLocation(request.getPickupLocation());
        product.setDropoffLocation(request.getDropoffLocation());
        product.setStartDate(request.getStartDate());
        product.setStartTime(request.getStartTime());
        product.setEndDate(request.getEndDate());
        product.setEndTime(request.getEndTime());
        product.setIsNegotiable(request.isNegotiable());
        product.setPaymentMethod(request.getPaymentMethod());
        product.setClientId(request.getClientId());
        product.setClientName(request.getClientName());
        product.setStatus(request.getStatus());
        product.setClientPhoneNumber(request.getClientPhoneNumber());
        product.setClientProfileImageUrl(request.getClientProfileImageUrl());
        product.setBaggageInfo(request.getBaggageInfo());
        product.setMetadata(request.getMetadata());
        // L'ID ne peut pas être mis à jour directement ici car il fait partie de la clé
        // primaire.
        // Il est géré par la logique `key = new ProductKey(...)` plus haut.
    }
}// END OF FILE: src/main/java/com/freelance/driver_backend/controller/MockProductController.java

//---> PATH: /home/mbogneng-junior/freelance-driver_Sylladb/backend/src/main/java/com/freelance/driver_backend/controller/MockUserController.java

package com.freelance.driver_backend.controller;

import com.freelance.driver_backend.dto.external.*;
import com.freelance.driver_backend.service.MockUserService;
import lombok.RequiredArgsConstructor;
import org.springframework.http.HttpStatus;
import org.springframework.web.bind.annotation.*;
import reactor.core.publisher.Mono;

@RestController
@RequestMapping("/api/mock_user")
@RequiredArgsConstructor
@CrossOrigin(origins = "*")
public class MockUserController {

    private final MockUserService mockUserService;

    @PostMapping("/register")
    @ResponseStatus(HttpStatus.CREATED)
    public Mono<UserDto> register(@RequestBody  RegistrationRequest request) {
        return mockUserService.register(request);
    }

    @PostMapping("/login")
    public Mono<LoginResponse> login(@RequestBody LoginRequest request) {
        return mockUserService.login(request);
    }
}// END OF FILE: src/main/java/com/freelance/driver_backend/controller/MockUserController.java

//---> PATH: /home/mbogneng-junior/freelance-driver_Sylladb/backend/src/main/java/com/freelance/driver_backend/controller/NotificationConfigController.java

// Dans src/main/java/com/freelance/driver_backend/controller/NotificationConfigController.java

package com.freelance.driver_backend.controller;

import java.util.UUID;

import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import com.freelance.driver_backend.dto.external.NotificationRequest;
import com.freelance.driver_backend.model.DesignTemplate;
import com.freelance.driver_backend.model.EmailTemplate;
import com.freelance.driver_backend.model.FirebaseSetting;
import com.freelance.driver_backend.model.PushTemplate;
import com.freelance.driver_backend.model.SmtpSetting;
import com.freelance.driver_backend.repository.DesignTemplateRepository;
import com.freelance.driver_backend.repository.EmailTemplateRepository;
import com.freelance.driver_backend.repository.FirebaseSettingRepository;
import com.freelance.driver_backend.repository.PushTemplateRepository;
import com.freelance.driver_backend.repository.SmtpSettingRepository;
import com.freelance.driver_backend.service.external.NotificationService;

import lombok.RequiredArgsConstructor;
import reactor.core.publisher.Mono;

@RestController
@RequestMapping("/api/mock-notifications/{organizationId}")
@RequiredArgsConstructor
public class NotificationConfigController {

    private final SmtpSettingRepository smtpSettingRepository;
    private final DesignTemplateRepository designTemplateRepository;
    private final EmailTemplateRepository emailTemplateRepository;
    private final NotificationService notificationService;
    private final FirebaseSettingRepository firebaseSettingRepository;
    private final PushTemplateRepository pushTemplateRepository;

    @PostMapping("/smtp-settings")
    public Mono<SmtpSetting> createSmtpSetting(@PathVariable UUID organizationId, @RequestBody SmtpSetting setting) {
        // Utilise l'ID fourni par le client, ou génère-en un si aucun n'est fourni
        if (setting.getId() == null) {
            setting.setId(UUID.randomUUID());
        }
        setting.setOrganizationId(organizationId);
        return smtpSettingRepository.save(setting);
    }

    @PostMapping("/design-templates")
    public Mono<DesignTemplate> createDesignTemplate(@PathVariable UUID organizationId, @RequestBody DesignTemplate template) {
        // Utilise l'ID fourni par le client, ou génère-en un si aucun n'est fourni
        if (template.getId() == null) {
            template.setId(UUID.randomUUID());
        }
        template.setOrganizationId(organizationId);
        return designTemplateRepository.save(template);
    }

    @PostMapping("/email-templates")
    public Mono<EmailTemplate> createEmailTemplate(@PathVariable UUID organizationId, @RequestBody EmailTemplate template) {
        // Utilise l'ID fourni par le client, ou génère-en un si aucun n'est fourni
        if (template.getId() == null) {
            template.setId(UUID.randomUUID());
        }
        template.setOrganizationId(organizationId);
        return emailTemplateRepository.save(template);
    }

     @PostMapping("/send-test-email")
    public Mono<ResponseEntity<String>> sendTestEmail(
            @PathVariable UUID organizationId,
            @RequestBody NotificationRequest request) {
        
        // Nous n'avons pas besoin du token ou de la clé publique ici car c'est un test local
        // qui appelle notre service "mock".
        return notificationService.sendEmailNotification(organizationId, request, "mock-token", "mock-key")
            .map(success -> {
                if (Boolean.TRUE.equals(success)) {
                    return ResponseEntity.ok("Test email sent successfully!");
                } else {
                    return ResponseEntity.status(500).body("Failed to send test email.");
                }
            })
            .onErrorResume(e -> Mono.just(ResponseEntity.status(500).body("Error: " + e.getMessage())));
    }


    @PostMapping("/firebase-settings")
    public Mono<FirebaseSetting> createFirebaseSetting(@PathVariable UUID organizationId, @RequestBody FirebaseSetting setting) {
        // Utilise l'ID fourni par le client, ou génère-en un si aucun n'est fourni
        if (setting.getId() == null) {
            setting.setId(UUID.randomUUID());
        }
        setting.setOrganizationId(organizationId);
        return firebaseSettingRepository.save(setting);
    }

    @PostMapping("/push-templates")
    public Mono<PushTemplate> createPushTemplate(@PathVariable UUID organizationId, @RequestBody PushTemplate template) {
        // Utilise l'ID fourni par le client, ou génère-en un si aucun n'est fourni
        if (template.getId() == null) {
            template.setId(UUID.randomUUID());
        }
        template.setOrganizationId(organizationId);
        return pushTemplateRepository.save(template);
    }
    
}// END OF FILE: src/main/java/com/freelance/driver_backend/controller/NotificationConfigController.java

//---> PATH: /home/mbogneng-junior/freelance-driver_Sylladb/backend/src/main/java/com/freelance/driver_backend/controller/NotificationController.java

package com.freelance.driver_backend.controller;

import com.freelance.driver_backend.model.DeviceToken;
import com.freelance.driver_backend.repository.DeviceTokenRepository;
import com.freelance.driver_backend.util.JwtUtil;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.core.annotation.AuthenticationPrincipal;
import org.springframework.security.oauth2.jwt.Jwt;
import org.springframework.web.bind.annotation.*;
import reactor.core.publisher.Mono;

import java.util.Map;

@RestController
@RequestMapping("/api/notifications")
@RequiredArgsConstructor
@Slf4j
public class NotificationController {

    private final DeviceTokenRepository deviceTokenRepository;

    @PostMapping("/register-device")
    public Mono<ResponseEntity<Void>> registerDevice(
            @AuthenticationPrincipal Mono<Jwt> jwtMono,
            @RequestBody Map<String, String> payload) {
        
        String token = payload.get("token");
        if (token == null || token.isBlank()) {
            return Mono.just(ResponseEntity.badRequest().build());
        }

        return jwtMono.flatMap(jwt -> {
            DeviceToken deviceToken = new DeviceToken();
            deviceToken.setUserId(JwtUtil.getUserIdFromToken(jwt));
            deviceToken.setToken(token);
            
            log.info("Enregistrement du token de l'appareil pour l'utilisateur {}", deviceToken.getUserId());
            
            return deviceTokenRepository.save(deviceToken)
                .thenReturn(new ResponseEntity<Void>(HttpStatus.CREATED));
        });
    }
}// END OF FILE: src/main/java/com/freelance/driver_backend/controller/NotificationController.java

//---> PATH: /home/mbogneng-junior/freelance-driver_Sylladb/backend/src/main/java/com/freelance/driver_backend/controller/OnboardingController.java

package com.freelance.driver_backend.controller;

import com.freelance.driver_backend.dto.onboarding.ClientOnboardingRequest;
import com.freelance.driver_backend.dto.onboarding.DriverOnboardingRequest;

import com.freelance.driver_backend.service.OnboardingService;
import lombok.extern.slf4j.Slf4j;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;
import reactor.core.publisher.Mono;
import com.freelance.driver_backend.dto.onboarding.OnboardingResponse;

@RestController
@RequestMapping("/api/onboarding")
@Slf4j
public class OnboardingController {

    private final OnboardingService onboardingService;

    public OnboardingController(OnboardingService onboardingService) {
        this.onboardingService = onboardingService;
    }

    @PostMapping("/driver")
    public Mono<ResponseEntity<OnboardingResponse>> onboardDriver(@RequestBody DriverOnboardingRequest request) {
        return onboardingService.createDriverAccount(request)
                .doOnNext(response -> { // AJOUT DU LOG ICI
                    log.info("▶️ Backend DEBUG: Réponse Onboarding (DRIVER) envoyée au frontend: {}", response);
                })
                .map(response -> new ResponseEntity<>(response, HttpStatus.CREATED));
    }

    @PostMapping("/client")
    public Mono<ResponseEntity<OnboardingResponse>> onboardClient(@RequestBody ClientOnboardingRequest request) {
        return onboardingService.createClientAccount(request)
                .doOnNext(response -> { // AJOUT DU LOG ICI
                    log.info("▶️ Backend DEBUG: Réponse Onboarding (CLIENT) envoyée au frontend: {}", response);
                })
                .map(response -> new ResponseEntity<>(response, HttpStatus.CREATED));
    }
}// END OF FILE: src/main/java/com/freelance/driver_backend/controller/OnboardingController.java

//---> PATH: /home/mbogneng-junior/freelance-driver_Sylladb/backend/src/main/java/com/freelance/driver_backend/controller/PlanningController.java


package com.freelance.driver_backend.controller;

import com.corundumstudio.socketio.SocketIOServer;
import com.freelance.driver_backend.dto.CreateProductRequest;
import com.freelance.driver_backend.dto.UserSessionContextDto;
import com.freelance.driver_backend.model.ClientProfile;
import com.freelance.driver_backend.model.DriverProfile;
import com.freelance.driver_backend.model.Product;
import com.freelance.driver_backend.model.ProductKey;
import com.freelance.driver_backend.repository.ProductRepository;
import com.freelance.driver_backend.service.NotificationTriggerService;
import com.freelance.driver_backend.service.ProfileService;
import com.freelance.driver_backend.service.ResourceService;
import com.freelance.driver_backend.util.JwtUtil;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.core.annotation.AuthenticationPrincipal;
import org.springframework.security.oauth2.jwt.Jwt;
import org.springframework.web.bind.annotation.*;
import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;
import java.util.UUID;

@RestController
@RequestMapping("/api/planning")
@RequiredArgsConstructor
@Slf4j
public class PlanningController {

    private final ResourceService resourceService;
    private final ProfileService profileService;
    private final ProductRepository productRepository;
    private final NotificationTriggerService notificationTriggerService;
    private final SocketIOServer socketIOServer;

    private static final UUID PLANNING_CATEGORY_ID = UUID.fromString("ba75b2c0-30a8-11f0-a5b5-bb7d33c83c13");

    /**
     * PUBLIC: Récupère tous les plannings publiés par les chauffeurs.
     */
    @GetMapping("/published")
    public Flux<Product> getPublishedPlannings() {
        log.info("Controller: Requête publique pour récupérer les plannings publiés.");
        return productRepository.findByCategoryId(PLANNING_CATEGORY_ID)
                .filter(product -> "Published".equalsIgnoreCase(product.getStatus())) // Seuls les plannings "Published"
                .flatMap(this::enrichProductWithAuthorDetails);
    }

    /**
     * PUBLIC: Récupère les plannings publiés d'un chauffeur spécifique.
     */
    @GetMapping("/user/{userId}")
    public Flux<Product> getPlanningsForUser(@PathVariable UUID userId) {
        log.info("Récupération des plannings publiés pour le chauffeur ID: {}", userId);
        return productRepository.findByClientIdAndCategoryId(userId, PLANNING_CATEGORY_ID)
                .filter(product -> "Published".equalsIgnoreCase(product.getStatus()))
                .flatMap(this::enrichProductWithAuthorDetails);
    }

    /**
     * SECURISE (CONDUCTEUR): Récupère les plannings du conducteur actuellement connecté.
     * Inclut aussi ceux en attente de confirmation ou confirmés.
     */
    @GetMapping
    public Flux<Product> getAllPlanningsForCurrentUser(@AuthenticationPrincipal Mono<Jwt> jwtMono,
                                                        @RequestHeader("Authorization") String authorizationHeader) {
        return jwtMono
            .flatMap(jwt -> profileService.getUserSessionContext(JwtUtil.getUserIdFromToken(jwt), authorizationHeader, null))
            .flatMapMany(userContext -> {
                if (userContext.getDriverProfile() == null) {
                     return Flux.error(new IllegalStateException("L'utilisateur n'est pas un chauffeur."));
                }
                // Récupère tous les plannings où ce chauffeur est le client_id (auteur)
                return productRepository.findByClientIdAndCategoryId(userContext.getUserId(), PLANNING_CATEGORY_ID);
            });
    }

    /**
     * SECURISE (CONDUCTEUR): Crée un nouveau planning pour le conducteur connecté.
     */
    @PostMapping
    public Mono<ResponseEntity<Product>> createPlanning(
            @RequestBody CreateProductRequest request,
            @AuthenticationPrincipal Mono<Jwt> jwtMono, 
            @RequestHeader("Authorization") String authorizationHeader) {
        
        return jwtMono
            .flatMap(jwt -> profileService.getUserSessionContext(JwtUtil.getUserIdFromToken(jwt), authorizationHeader, null))
            .flatMap(userContext -> {
                if (userContext.getDriverProfile() == null) {
                    return Mono.error(new IllegalStateException("Seul un chauffeur peut créer un planning."));
                }
                if (userContext.getOrganisation() == null || userContext.getOrganisation().getOrganizationId() == null) {
                    return Mono.error(new IllegalStateException("Contexte utilisateur invalide pour créer un planning (organisation manquante)."));
                }
                DriverProfile driverProfile = userContext.getDriverProfile();
                
                request.setCategoryId(PLANNING_CATEGORY_ID);
                request.setClientId(driverProfile.getUserId());
                request.setClientName(driverProfile.getFirstName() + " " + driverProfile.getLastName());
                request.setClientPhoneNumber(driverProfile.getPhoneNumber());
                request.setClientProfileImageUrl(driverProfile.getProfileImageUrl());
                
                // Le statut par défaut d'un nouveau planning est "Published"
                request.setStatus("Published");

                log.info("▶️ [PlanningController.createPlanning] Création d'un planning par le chauffeur ID: {} pour l'organisation ID: {}",
                         driverProfile.getUserId(), userContext.getOrganisation().getOrganizationId());
                log.info("▶️ [PlanningController.createPlanning] Request payload avant envoi au resourceService: {}", request);

                return resourceService.createProduct(userContext.getOrganisation().getOrganizationId(), request, authorizationHeader, null);
            })
            .map(createdProduct -> {
                log.info("✅ [PlanningController.createPlanning] Planning créé avec succès. ID: {}", createdProduct.getId());
                return new ResponseEntity<>(createdProduct, HttpStatus.CREATED);
            });
    }

    /**
     * SECURISE (CONDUCTEUR): Met à jour un planning appartenant au conducteur connecté.
     */
    @PutMapping("/{planningId}")
    public Mono<ResponseEntity<Product>> updatePlanning(
            @PathVariable UUID planningId,
            @RequestBody CreateProductRequest request,
            @AuthenticationPrincipal Mono<Jwt> jwtMono,
            @RequestHeader("Authorization") String authorizationHeader) {
        
        return jwtMono
            .flatMap(jwt -> profileService.getUserSessionContext(JwtUtil.getUserIdFromToken(jwt), authorizationHeader, null))
            .flatMap(userContext -> {
                 if (userContext.getDriverProfile() == null) {
                    return Mono.error(new IllegalStateException("Seuls les chauffeurs peuvent modifier leurs plannings."));
                }
                if (userContext.getOrganisation() == null || userContext.getOrganisation().getOrganizationId() == null) {
                    return Mono.error(new IllegalStateException("Contexte utilisateur invalide pour mettre à jour un planning (organisation manquante)."));
                }
                DriverProfile driverProfile = userContext.getDriverProfile();

                return productRepository.findById(new ProductKey(userContext.getOrganisation().getOrganizationId(), planningId))
                        .filter(product -> driverProfile.getUserId().equals(product.getClientId()))
                        .switchIfEmpty(Mono.error(new SecurityException("Le chauffeur n'est pas autorisé à modifier ce planning ou il n'existe pas.")))
                        .flatMap(existingPlanning ->
                            resourceService.updateProduct(userContext.getOrganisation().getOrganizationId(), planningId, request, authorizationHeader, null)
                        );
            })
            .doOnSuccess(updatedPlanning -> {
                if (updatedPlanning != null) {
                    socketIOServer.getBroadcastOperations().sendEvent("updated_planning", updatedPlanning);
                }
            })
            .map(ResponseEntity::ok)
            .defaultIfEmpty(ResponseEntity.notFound().build());
    }

    /**
     * SECURISE (CONDUCTEUR): Supprime un planning appartenant au conducteur connecté.
     */
    @DeleteMapping("/{planningId}")
    public Mono<ResponseEntity<Void>> deletePlanning(
            @PathVariable UUID planningId,
            @AuthenticationPrincipal Mono<Jwt> jwtMono,
            @RequestHeader("Authorization") String authorizationHeader) {

        return jwtMono
            .flatMap(jwt -> profileService.getUserSessionContext(JwtUtil.getUserIdFromToken(jwt), authorizationHeader, null))
            .flatMap(userContext -> {
                if (userContext.getDriverProfile() == null) {
                    return Mono.error(new IllegalStateException("Seuls les chauffeurs peuvent supprimer leurs plannings."));
                }
                if (userContext.getOrganisation() == null || userContext.getOrganisation().getOrganizationId() == null) {
                    return Mono.error(new IllegalStateException("Contexte utilisateur invalide pour supprimer un planning (organisation manquante)."));
                }
                DriverProfile driverProfile = userContext.getDriverProfile();

                return productRepository.findById(new ProductKey(userContext.getOrganisation().getOrganizationId(), planningId))
                        .filter(product -> driverProfile.getUserId().equals(product.getClientId()))
                        .switchIfEmpty(Mono.error(new SecurityException("Le chauffeur n'est pas autorisé à supprimer ce planning ou il n'existe pas.")))
                        .flatMap(existingPlanning ->
                            resourceService.deleteProduct(userContext.getOrganisation().getOrganizationId(), planningId, authorizationHeader, null)
                        );
            })
            .then(Mono.just(new ResponseEntity<Void>(HttpStatus.NO_CONTENT)));
    }
    
    /**
     * SECURISE (CLIENT): Permet à un client de DEMANDER à réserver un planning.
     * Le statut de l'annonce passe à "PendingDriverConfirmation". Une notification est envoyée au chauffeur.
     * (Anciennement /accept)
     */
    @PostMapping("/{planningId}/request-booking")
    public Mono<ResponseEntity<Product>> requestPlanningBooking( // RENOMMÉ
            @PathVariable UUID planningId,
            @AuthenticationPrincipal Mono<Jwt> jwtMono,
            @RequestHeader("Authorization") String authorizationHeader) {

        return jwtMono
            .flatMap(jwt -> profileService.getUserSessionContext(JwtUtil.getUserIdFromToken(jwt), authorizationHeader, null))
            .flatMap(clientContext -> {
                if (clientContext.getClientProfile() == null) {
                    return Mono.error(new IllegalStateException("Seul un client peut demander la réservation d'un planning."));
                }
                if (clientContext.getOrganisation() == null || clientContext.getOrganisation().getOrganizationId() == null) {
                    return Mono.error(new IllegalStateException("Contexte utilisateur invalide pour demander la réservation d'un planning (organisation manquante)."));
                }
                ClientProfile clientProfile = clientContext.getClientProfile();
                
                return productRepository.findById(new ProductKey(clientContext.getOrganisation().getOrganizationId(), planningId))
                    .flatMap(planning -> {
                        if (planning.getReservedByDriverId() != null) {
                            return Mono.error(new IllegalStateException("Ce planning a déjà une demande de réservation ou est déjà réservé."));
                        }
                        
                        // Met l'ID du client demandeur dans reservedByDriverId (qui représente ici le client ayant fait la demande)
                        planning.setReservedByDriverId(clientProfile.getUserId());
                        planning.setReservedByDriverName(clientProfile.getFirstName() + " " + clientProfile.getLastName());
                        planning.setStatus("PendingDriverConfirmation"); // NOUVEAU STATUT
                        log.info("Client {} demande la réservation du planning {}. Statut mis à jour à 'PendingDriverConfirmation'.", clientProfile.getUserId(), planningId);
                        
                        return productRepository.save(planning);
                    })
                    .flatMap(updatedPlanning -> 
                        profileService.findDriverById(updatedPlanning.getClientId()) // Le client_id du planning est l'ID du chauffeur
                            .flatMap(driverProfile -> notificationTriggerService.notifyDriverOfPlanningBookingRequest(updatedPlanning, clientProfile))
                            .thenReturn(updatedPlanning)
                    )
                    .doOnSuccess(updatedPlanning -> {
                        socketIOServer.getBroadcastOperations().sendEvent("updated_planning", updatedPlanning);
                    });
            })
            .map(ResponseEntity::ok)
            .defaultIfEmpty(ResponseEntity.notFound().build());
    }

    /**
     * SECURISE (CONDUCTEUR): Permet au CHAUFFEUR de confirmer (accepter) une demande de réservation d'un client.
     * Le statut du planning passe à "Ongoing". Une notification est envoyée au client.
     */
    @PostMapping("/{planningId}/confirm-booking") // NOUVEL ENDPOINT
    public Mono<ResponseEntity<Product>> confirmPlanningBooking(
            @PathVariable UUID planningId,
            @RequestParam UUID clientId, // Le client à confirmer
            @AuthenticationPrincipal Mono<Jwt> jwtMono,
            @RequestHeader("Authorization") String authorizationHeader) {
        
        return jwtMono
            .flatMap(jwt -> profileService.getUserSessionContext(JwtUtil.getUserIdFromToken(jwt), authorizationHeader, null))
            .flatMap(driverContext -> {
                if (driverContext.getDriverProfile() == null) {
                    return Mono.error(new IllegalStateException("Seul un chauffeur peut confirmer la réservation d'un planning."));
                }
                if (driverContext.getOrganisation() == null || driverContext.getOrganisation().getOrganizationId() == null) {
                    return Mono.error(new IllegalStateException("Contexte utilisateur invalide pour confirmer une réservation de planning (organisation manquante)."));
                }
                DriverProfile driverProfile = driverContext.getDriverProfile();

                return productRepository.findById(new ProductKey(driverContext.getOrganisation().getOrganizationId(), planningId))
                    .flatMap(planning -> {
                        // Vérifier que le chauffeur connecté est bien l'auteur du planning
                        if (!planning.getClientId().equals(driverContext.getUserId())) {
                            return Mono.error(new SecurityException("Vous n'êtes pas l'auteur de ce planning."));
                        }
                        // Vérifier que le statut est bien "PendingDriverConfirmation" et que le client à confirmer est celui qui a fait la demande
                        if (!"PendingDriverConfirmation".equalsIgnoreCase(planning.getStatus()) || !planning.getReservedByDriverId().equals(clientId)) {
                             return Mono.error(new IllegalStateException("Ce planning n'est pas en attente de confirmation pour ce client, ou le statut est incorrect."));
                        }

                        planning.setStatus("Ongoing"); // Statut final
                        log.info("Chauffeur {} a confirmé la réservation du client {} pour le planning {}. Statut mis à jour à 'Ongoing'.", driverProfile.getUserId(), clientId, planningId);
                        
                        return productRepository.save(planning);
                    })
                    .flatMap(updatedPlanning -> 
                        profileService.findClientById(clientId) // Retrouver le profil du client pour la notification
                            .flatMap(clientProfile -> notificationTriggerService.notifyClientOfPlanningBookingAccepted(updatedPlanning, driverProfile))
                            .thenReturn(updatedPlanning)
                    )
                    .doOnSuccess(updatedPlanning -> {
                        socketIOServer.getBroadcastOperations().sendEvent("updated_planning", updatedPlanning);
                    });
            })
            .map(ResponseEntity::ok)
            .defaultIfEmpty(ResponseEntity.notFound().build());
    }

    /**
     * SECURISE (CLIENT): Permet à un client d'ANNULER sa demande de réservation ou une réservation en cours.
     * Le statut du planning revient à "Published". Une notification est envoyée au chauffeur.
     */
    @PostMapping("/{planningId}/cancel-reservation") // NOUVEL ENDPOINT
    public Mono<ResponseEntity<Product>> cancelPlanningReservation(
            @PathVariable UUID planningId,
            @AuthenticationPrincipal Mono<Jwt> jwtMono,
            @RequestHeader("Authorization") String authorizationHeader) {

        return jwtMono
            .flatMap(jwt -> profileService.getUserSessionContext(JwtUtil.getUserIdFromToken(jwt), authorizationHeader, null))
            .flatMap(clientContext -> {
                if (clientContext.getClientProfile() == null) {
                    return Mono.error(new IllegalStateException("Seul un client peut annuler une réservation de planning."));
                }
                if (clientContext.getOrganisation() == null || clientContext.getOrganisation().getOrganizationId() == null) {
                    return Mono.error(new IllegalStateException("Contexte utilisateur invalide pour annuler une réservation de planning (organisation manquante)."));
                }
                ClientProfile clientProfile = clientContext.getClientProfile();

                return productRepository.findById(new ProductKey(clientContext.getOrganisation().getOrganizationId(), planningId))
                    .flatMap(planning -> {
                        // Vérifier que le client connecté est bien celui qui a demandé ou réservé
                        if (!clientProfile.getUserId().equals(planning.getReservedByDriverId())) {
                            return Mono.error(new SecurityException("Vous n'avez pas demandé ou réservé ce planning."));
                        }
                        // Autoriser l'annulation si le statut est "PendingDriverConfirmation" ou "Ongoing"
                        if (!"PendingDriverConfirmation".equalsIgnoreCase(planning.getStatus()) && !"Ongoing".equalsIgnoreCase(planning.getStatus())) {
                            return Mono.error(new IllegalStateException("Le planning n'est pas dans un état permettant l'annulation de réservation (statut actuel: " + planning.getStatus() + ")."));
                        }

                        planning.setReservedByDriverId(null);
                        planning.setReservedByDriverName(null);
                        planning.setStatus("Published"); // Revenir au statut "Published"
                        log.info("Client {} a annulé sa demande/réservation pour le planning {}. Statut remis à 'Published'.", clientProfile.getUserId(), planningId);
                        
                        return productRepository.save(planning);
                    })
                    .flatMap(updatedPlanning -> 
                        profileService.findDriverById(updatedPlanning.getClientId()) // L'auteur du planning est le chauffeur
                            .flatMap(driverProfile -> notificationTriggerService.notifyDriverOfCancelledPlanningReservation(updatedPlanning, clientProfile))
                            .thenReturn(updatedPlanning)
                    )
                    .doOnSuccess(updatedPlanning -> {
                        socketIOServer.getBroadcastOperations().sendEvent("updated_planning", updatedPlanning);
                    });
            })
            .map(ResponseEntity::ok)
            .defaultIfEmpty(ResponseEntity.notFound().build());
    }

    /**
     * SECURISE (CLIENT): Récupère les plannings que le client connecté a réservés ou demandés.
     */
    @GetMapping("/my-reservations")
    public Flux<Product> getMyReservedRides(@AuthenticationPrincipal Mono<Jwt> jwtMono,
                                            @RequestHeader("Authorization") String authorizationHeader) {
        return jwtMono
            .flatMap(jwt -> profileService.getUserSessionContext(JwtUtil.getUserIdFromToken(jwt), authorizationHeader, null))
            .flatMapMany(userContext -> {
                 if (userContext.getClientProfile() == null) {
                     return Flux.error(new IllegalStateException("L'utilisateur n'est pas un client."));
                }
                log.info("Récupération des courses réservées/demandées par le client {}", userContext.getUserId());
                // Filtrer les plannings où ce client est le "reservedByDriverId"
                return productRepository.findByReservedByDriverId(userContext.getUserId())
                            .flatMap(this::enrichProductWithAuthorDetails); // Enrichir avec les détails du chauffeur (auteur du planning)
            });
    }

    /**
     * Méthode privée pour enrichir un produit avec les détails de son auteur (chauffeur).
     */
    private Mono<Product> enrichProductWithAuthorDetails(Product product) {
        UUID authorId = product.getClientId();
        if (authorId == null) {
            return Mono.just(product);
        }

        return profileService.findDriverById(authorId)
            .map(driverProfile -> {
                product.setAuthorId(driverProfile.getUserId());
                product.setAuthorName(driverProfile.getFirstName() + " " + driverProfile.getLastName());
                product.setAuthorPhoneNumber(driverProfile.getPhoneNumber());
                product.setAuthorProfileImageUrl(driverProfile.getProfileImageUrl());
                return product;
            })
            .defaultIfEmpty(product);
    }
}// END OF FILE: src/main/java/com/freelance/driver_backend/controller/PlanningController.java

//---> PATH: /home/mbogneng-junior/freelance-driver_Sylladb/backend/src/main/java/com/freelance/driver_backend/controller/ProfileController.java



// PATH: /home/mbogneng-junior/freelance-driver (Copie)/backend/src/main/java/com/freelance/driver_backend/controller/ProfileController.java

package com.freelance.driver_backend.controller;

import com.freelance.driver_backend.dto.UserSessionContextDto;
import com.freelance.driver_backend.model.ClientProfile;
import com.freelance.driver_backend.model.DriverProfile;
import com.freelance.driver_backend.service.ProfileService;
import com.freelance.driver_backend.util.JwtUtil;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.http.ResponseEntity;
import org.springframework.security.core.annotation.AuthenticationPrincipal;
import org.springframework.security.oauth2.jwt.Jwt;
import org.springframework.web.bind.annotation.*;
import reactor.core.publisher.Mono;

import java.util.Map;
import java.util.UUID;

@Slf4j
@RestController
@RequestMapping("/api/profiles")
@RequiredArgsConstructor
public class ProfileController {

    private final ProfileService profileService;

    /**
     * SECURISE: Récupère le profil complet de l'utilisateur actuellement connecté.
     * Retourne la nouvelle structure UserSessionContextDto.
     */
    @GetMapping("/me")
    public Mono<ResponseEntity<UserSessionContextDto>> getMyProfile(
            @AuthenticationPrincipal Mono<Jwt> jwtMono,
            @RequestHeader("Authorization") String authorizationHeader) {
        return jwtMono
                .flatMap(jwt -> profileService.getUserSessionContext(JwtUtil.getUserIdFromToken(jwt),
                        authorizationHeader, null))
                .map(ResponseEntity::ok)
                .defaultIfEmpty(ResponseEntity.notFound().build());
    }

    /**
     * SECURISE: Met à jour le profil du conducteur actuellement connecté.
     * Vérifie que l'utilisateur a bien un profil chauffeur.
     * // --- MODIFICATION ICI : Le type de retour du Mono ---
     * 
     * @return Le UserSessionContextDto complet et mis à jour.
     */
    @PutMapping("/driver/me")
    public Mono<ResponseEntity<UserSessionContextDto>> updateDriverProfile( // <-- CHANGEMENT DU TYPE DE RETOUR
            @AuthenticationPrincipal Mono<Jwt> jwtMono,
            @RequestBody DriverProfile updatedProfileData,
            @RequestHeader("Authorization") String authorizationHeader) {
        return jwtMono
                .flatMap(jwt -> profileService.getUserSessionContext(JwtUtil.getUserIdFromToken(jwt),
                        authorizationHeader, null))
                .flatMap(userContext -> {
                    if (userContext.getDriverProfile() == null) {
                        return Mono.error(new IllegalStateException(
                                "L'utilisateur n'est pas un chauffeur. Impossible de mettre à jour le profil chauffeur."));
                    }
                    UUID userId = userContext.getUserId();
                    return profileService.updateDriverProfile(userId, updatedProfileData); // <--
                                                                                           // profileService.updateDriverProfile
                                                                                           // retourne
                                                                                           // UserSessionContextDto
                })
                .map(ResponseEntity::ok)
                .defaultIfEmpty(ResponseEntity.notFound().build());
    }

    /**
     * SECURISE: Met à jour le profil du client actuellement connecté.
     * Vérifie que l'utilisateur a bien un profil client.
     * // --- MODIFICATION ICI : Le type de retour du Mono ---
     * 
     * @return Le UserSessionContextDto complet et mis à jour.
     */
    @PutMapping("/client/me")
    public Mono<ResponseEntity<UserSessionContextDto>> updateClientProfile( // <-- CHANGEMENT DU TYPE DE RETOUR
            @AuthenticationPrincipal Mono<Jwt> jwtMono,
            @RequestBody ClientProfile updatedProfileData,
            @RequestHeader("Authorization") String authorizationHeader) {

        return jwtMono
                .flatMap(jwt -> profileService.getUserSessionContext(JwtUtil.getUserIdFromToken(jwt),
                        authorizationHeader, null))
                .flatMap(userContext -> {
                    if (userContext.getClientProfile() == null) {
                        return Mono.error(new IllegalStateException(
                                "L'utilisateur n'est pas un client. Impossible de mettre à jour le profil client."));
                    }
                    UUID userId = userContext.getUserId();
                    return profileService.updateClientProfile(userId, updatedProfileData); // <--
                                                                                           // profileService.updateClientProfile
                                                                                           // retourne
                                                                                           // UserSessionContextDto
                })
                .map(ResponseEntity::ok)
                .defaultIfEmpty(ResponseEntity.notFound().build());
    }

    /**
     * PUBLIC: Récupère le profil public d'un utilisateur par son ID.
     * Retourne la nouvelle structure UserSessionContextDto.
     */
    @GetMapping("/user/{userId}")
    public Mono<ResponseEntity<UserSessionContextDto>> getPublicUserProfile(
            @PathVariable UUID userId,
            @RequestHeader(value = "Authorization", required = false) String authorizationHeader) {
        log.info("▶️ [ProfileController] Récupération du profil public pour l'ID: {}", userId);
        return profileService.getUserSessionContext(userId, authorizationHeader, null)
                .map(ResponseEntity::ok)
                .doOnSuccess(response -> log.info("✅ [ProfileController] Profil public de {} récupéré.", userId))
                .doOnError(error -> log.error("❌ Erreur lors de la récupération du profil public pour {}: {}", userId,
                        error.getMessage()))
                .defaultIfEmpty(ResponseEntity.notFound().build());
    }

    /**
     * SECURISE: Met à jour l'URL de l'avatar pour l'utilisateur connecté.
     * Cette route déclenche la mise à jour de TOUS les profils associés
     * (Driver/Client)
     * et la suppression de l'ancien avatar du stockage.
     * 
     * @param jwtMono             Le token JWT de l'utilisateur authentifié.
     * @param requestPayload      Un Map contenant "profileImageUrl".
     * @param authorizationHeader L'en-tête Authorization.
     * @return Le UserSessionContextDto complet et mis à jour.
     */
    @PutMapping("/me/avatar")
    public Mono<ResponseEntity<UserSessionContextDto>> updateMyAvatar(
            @AuthenticationPrincipal Mono<Jwt> jwtMono,
            @RequestBody Map<String, String> requestPayload,
            @RequestHeader("Authorization") String authorizationHeader) {

        String newAvatarUrl = requestPayload.get("profileImageUrl");
        if (newAvatarUrl == null || newAvatarUrl.isEmpty()) {
            log.error("Requête de mise à jour de l'avatar avec une URL nulle ou vide.");
            return Mono.just(ResponseEntity.badRequest().body(null));
        }

        return jwtMono
                .flatMap(jwt -> {
                    UUID userId = JwtUtil.getUserIdFromToken(jwt);
                    log.info("Requête de mise à jour de l'avatar pour l'utilisateur ID: {} avec la nouvelle URL: {}",
                            userId, newAvatarUrl);
                    return profileService.updateAvatarUrl(userId, newAvatarUrl);
                })
                .map(ResponseEntity::ok)
                .defaultIfEmpty(ResponseEntity.notFound().build())
                .doOnError(e -> log.error("❌ Erreur lors de la mise à jour de l'avatar de l'utilisateur: {}",
                        e.getMessage(), e));
    }
}// END OF FILE: src/main/java/com/freelance/driver_backend/controller/ProfileController.java

//---> PATH: /home/mbogneng-junior/freelance-driver_Sylladb/backend/src/main/java/com/freelance/driver_backend/controller/ProfileRoleController.java

package com.freelance.driver_backend.controller;

import com.freelance.driver_backend.dto.onboarding.ClientOnboardingRequest;
import com.freelance.driver_backend.dto.onboarding.DriverOnboardingRequest;
import com.freelance.driver_backend.dto.UserSessionContextDto; // Importez la nouvelle structure
import com.freelance.driver_backend.model.ClientProfile;
import com.freelance.driver_backend.model.DriverProfile;
import com.freelance.driver_backend.service.OnboardingService; // Réutiliser le service Onboarding
import com.freelance.driver_backend.service.ProfileService;
import com.freelance.driver_backend.util.JwtUtil;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.core.annotation.AuthenticationPrincipal;
import org.springframework.security.oauth2.jwt.Jwt;
import org.springframework.web.bind.annotation.*;
import reactor.core.publisher.Mono;

import java.util.UUID;


@RestController
@RequestMapping("/api/profiles/roles")
@RequiredArgsConstructor
@Slf4j
public class ProfileRoleController {

    private final ProfileService profileService;
    private final OnboardingService onboardingService;

    
    @PostMapping("/become-driver")
    public Mono<ResponseEntity<UserSessionContextDto>> becomeDriver(
            @RequestBody DriverOnboardingRequest request, // Réutilise le DTO d'onboarding
            @AuthenticationPrincipal Mono<Jwt> jwtMono,
            @RequestHeader("Authorization") String authorizationHeader) {

        return jwtMono
            .flatMap(jwt -> {
                UUID userId = JwtUtil.getUserIdFromToken(jwt);
                // Vérifier d'abord si le profil chauffeur existe déjà pour cet utilisateur
                return profileService.findDriverById(userId)
                    .flatMap(existingDriver -> {
                        log.warn("L'utilisateur {} a déjà un DriverProfile. Impossible d'en créer un autre.", userId);
                        return Mono.error(new IllegalStateException("Vous êtes déjà enregistré en tant que chauffeur."));
                    })
                    .switchIfEmpty(
                        // Si aucun profil chauffeur n'existe, procéder à sa création
                        onboardingService.createDriverProfileForExistingUser(userId, request, authorizationHeader)
                    )
                    .flatMap(driverProfile -> // driverProfile est le DriverProfile nouvellement créé
                         // Puis, récupérer le contexte complet mis à jour pour l'utilisateur
                         profileService.getUserSessionContext(userId, authorizationHeader, null)
                    )
                    .map(context -> new ResponseEntity<>(context, HttpStatus.CREATED));
            });
    }

    
    @PostMapping("/become-client")
    public Mono<ResponseEntity<UserSessionContextDto>> becomeClient(
            @RequestBody ClientOnboardingRequest request, // Réutilise le DTO d'onboarding
            @AuthenticationPrincipal Mono<Jwt> jwtMono,
            @RequestHeader("Authorization") String authorizationHeader) {

        return jwtMono
            .flatMap(jwt -> {
                UUID userId = JwtUtil.getUserIdFromToken(jwt);
                // Vérifier d'abord si le profil client existe déjà pour cet utilisateur
                return profileService.findClientById(userId)
                    .flatMap(existingClient -> {
                        log.warn("L'utilisateur {} a déjà un ClientProfile. Impossible d'en créer un autre.", userId);
                        return Mono.error(new IllegalStateException("Vous êtes déjà enregistré en tant que client."));
                    })
                    .switchIfEmpty(
                        // Si aucun profil client n'existe, procéder à sa création
                        onboardingService.createClientProfileForExistingUser(userId, request, authorizationHeader)
                    )
                    .flatMap(clientProfile -> // clientProfile est le ClientProfile nouvellement créé
                         // Puis, récupérer le contexte complet mis à jour pour l'utilisateur
                         profileService.getUserSessionContext(userId, authorizationHeader, null)
                    )
                    .map(context -> new ResponseEntity<>(context, HttpStatus.CREATED));
            });
    }
}


// PATH: /home/mbogneng-junior/freelance-driver (Copie)/backend/src/main/java/com/freelance/driver_backend/controller/ProfileController.java

// END OF FILE: src/main/java/com/freelance/driver_backend/controller/ProfileRoleController.java

//---> PATH: /home/mbogneng-junior/freelance-driver_Sylladb/backend/src/main/java/com/freelance/driver_backend/controller/ReviewController.java



// PATH: /home/mbogneng-junior/freelance-driver (Copie)/backend/src/main/java/com/freelance/driver_backend/controller/ReviewController.java

package com.freelance.driver_backend.controller;

import com.freelance.driver_backend.dto.RateCriteriaRequest;
import com.freelance.driver_backend.dto.CreateReviewRequest;
import com.freelance.driver_backend.dto.UserSessionContextDto; // Importez la nouvelle structure
import com.freelance.driver_backend.model.ClientProfile; // Importez ClientProfile
import com.freelance.driver_backend.model.DriverProfile; // Importez DriverProfile
import com.freelance.driver_backend.model.Review;
import com.freelance.driver_backend.repository.ReviewRepository;
import com.freelance.driver_backend.service.ProfileService;
import com.freelance.driver_backend.util.JwtUtil;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.http.ResponseEntity;
import org.springframework.security.core.annotation.AuthenticationPrincipal;
import org.springframework.security.oauth2.jwt.Jwt;
import org.springframework.web.bind.annotation.*;
import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;

import java.time.Instant;
import java.util.UUID;

@RestController
@RequestMapping("/api/reviews")
@RequiredArgsConstructor
@Slf4j
public class ReviewController {

    private final ReviewRepository reviewRepository;
    private final ProfileService profileService;

    @PostMapping("/criteria")
    public Mono<ResponseEntity<Void>> rateByCriteria(@RequestBody RateCriteriaRequest request) {
        // Logique pour traiter la notation par critères
        log.info("Received criteria rating for entity {}: {}", request.getEntityId(), request.getRatings());
        // Ici, vous ajouteriez la logique pour sauvegarder ces évaluations.
        // Pour l'instant, nous retournons simplement un succès.
        return Mono.just(ResponseEntity.ok().build());
    }

    @PostMapping
    public Mono<ResponseEntity<Review>> createReview(
            @RequestBody CreateReviewRequest request,
            @AuthenticationPrincipal Mono<Jwt> jwtMono,
            @RequestHeader("Authorization") String authorizationHeader) { // Ajout pour getUserSessionContext

        return jwtMono
            .flatMap(jwt -> profileService.getUserSessionContext(JwtUtil.getUserIdFromToken(jwt), authorizationHeader, null))
            .flatMap(userContext -> {
                // L'auteur d'un avis peut être un client ou un chauffeur
                // On vérifie qu'il a au moins un profil
                if (userContext.getDriverProfile() == null && userContext.getClientProfile() == null) {
                    return Mono.error(new IllegalStateException("L'utilisateur n'a pas de profil actif pour laisser un avis."));
                }
                
                Review review = new Review();
                review.setId(UUID.randomUUID());
                review.setTargetUserId(request.getTargetUserId());
                review.setScore(request.getScore());
                review.setComment(request.getComment());
                review.setAuthorId(userContext.getUserId());
                
                // Détermine les infos de l'auteur en fonction du premier profil trouvé
                if (userContext.getDriverProfile() != null) {
                    review.setAuthorFirstName(userContext.getDriverProfile().getFirstName());
                    review.setAuthorLastName(userContext.getDriverProfile().getLastName());
                    review.setAuthorProfileImageUrl(userContext.getDriverProfile().getProfileImageUrl());
                } else if (userContext.getClientProfile() != null) {
                    review.setAuthorFirstName(userContext.getClientProfile().getFirstName());
                    review.setAuthorLastName(userContext.getClientProfile().getLastName());
                    review.setAuthorProfileImageUrl(userContext.getClientProfile().getProfileImageUrl());
                } else {
                    // Fallback si vraiment aucun profil n'est trouvé (ne devrait pas arriver avec la vérification ci-dessus)
                    review.setAuthorFirstName("Utilisateur");
                    review.setAuthorLastName("Anonyme");
                }
                
                review.setCreatedAt(Instant.now().toEpochMilli());
                
                return reviewRepository.save(review);
            })
            .map(ResponseEntity::ok);
    }

    @GetMapping("/user/{userId}")
    public Flux<Review> getReviewsForUser(@PathVariable UUID userId,
                                          @RequestHeader(value = "Authorization", required = false) String authorizationHeader) {
        log.info("Récupération des avis pour l'utilisateur ID: {}", userId);
        return reviewRepository.findByTargetUserId(userId)
                .flatMap(review -> enrichReviewWithAuthorDetails(review, authorizationHeader)); // Passer l'header
    }

    // MODIFIÉ : Prend l'Authorization header pour pouvoir appeler getUserSessionContext
    private Mono<Review> enrichReviewWithAuthorDetails(Review review, String authorizationHeader) {
        return profileService.getUserSessionContext(review.getAuthorId(), authorizationHeader, null) // Utilise getUserSessionContext
            .flatMap(authorContext -> {
                if (authorContext.getDriverProfile() != null) {
                    review.setAuthorFirstName(authorContext.getDriverProfile().getFirstName());
                    review.setAuthorLastName(authorContext.getDriverProfile().getLastName());
                    review.setAuthorProfileImageUrl(authorContext.getDriverProfile().getProfileImageUrl());
                } else if (authorContext.getClientProfile() != null) {
                    review.setAuthorFirstName(authorContext.getClientProfile().getFirstName());
                    review.setAuthorLastName(authorContext.getClientProfile().getLastName());
                    review.setAuthorProfileImageUrl(authorContext.getClientProfile().getProfileImageUrl());
                }
                return Mono.just(review);
            })
            .defaultIfEmpty(review); // En cas d'erreur ou d'absence de profil, on renvoie l'avis sans les détails enrichis
    }
}// END OF FILE: src/main/java/com/freelance/driver_backend/controller/ReviewController.java

//---> PATH: /home/mbogneng-junior/freelance-driver_Sylladb/backend/src/main/java/com/freelance/driver_backend/controller/VehicleController.java


// PATH: /home/mbogneng-junior/freelance-driver (Copie)/backend/src/main/java/com/freelance/driver_backend/controller/VehicleController.java

package com.freelance.driver_backend.controller;

import com.freelance.driver_backend.dto.CreateProductRequest; // Ajouté pour les méthodes POST/PUT
import com.freelance.driver_backend.dto.UserSessionContextDto; // Nouveau import
import com.freelance.driver_backend.model.DriverProfile; // Nouveau import
import com.freelance.driver_backend.model.Product;
import com.freelance.driver_backend.service.ProfileService;
import com.freelance.driver_backend.service.ResourceService;
import com.freelance.driver_backend.util.JwtUtil;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.http.HttpStatus; // Ajouté pour les ResponseEntity
import org.springframework.http.ResponseEntity; // Ajouté pour les ResponseEntity
import org.springframework.security.core.annotation.AuthenticationPrincipal; // Ajouté pour les méthodes POST/PUT
import org.springframework.security.oauth2.jwt.Jwt; // Ajouté pour les méthodes POST/PUT
import org.springframework.web.bind.annotation.*;
import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;

import java.util.Optional;
import java.util.UUID;

@RestController
@RequestMapping("/api/vehicles")
@RequiredArgsConstructor
@Slf4j
public class VehicleController {

    private final ProfileService profileService;
    private final ResourceService resourceService;

    private static final UUID VEHICLE_CATEGORY_ID = UUID.fromString("e2a7f23e-a3a3-4b0c-852a-227a1c1d6a7e");

    /**
     * SECURISE: Récupère tous les véhicules du chauffeur actuellement connecté.
     */
    @GetMapping
    public Flux<Product> getMyVehicles(
            @AuthenticationPrincipal Mono<Jwt> jwtMono,
            @RequestHeader("Authorization") String authorizationHeader) {

        return jwtMono
            .flatMap(jwt -> profileService.getUserSessionContext(JwtUtil.getUserIdFromToken(jwt), authorizationHeader, null))
            .flatMapMany(userContext -> {
                // Seuls les chauffeurs peuvent avoir des véhicules
                if (userContext.getDriverProfile() == null) {
                    return Flux.error(new IllegalStateException("Seuls les chauffeurs peuvent gérer leurs véhicules."));
                }
                if (userContext.getOrganisation() == null || userContext.getOrganisation().getOrganizationId() == null) {
                    return Flux.error(new IllegalStateException("L'utilisateur n'a pas d'organisation valide associée."));
                }
                UUID organizationId = userContext.getOrganisation().getOrganizationId();
                // Filtre les produits par categoryId ET clientId (chauffeur connecté)
                return resourceService.getProductsByCategory(organizationId, VEHICLE_CATEGORY_ID, authorizationHeader, null)
                                      .filter(product -> userContext.getUserId().equals(product.getClientId()));
            });
    }

    /**
     * PUBLIC: Récupère les véhicules d'un utilisateur spécifique par son ID.
     * Cette route devrait idéalement être utilisée pour afficher les véhicules d'un CHAUFFEUR public.
     */
    @GetMapping("/user/{userId}")
    public Flux<Product> getVehiclesForUser(
            @PathVariable UUID userId,
            @RequestHeader(value = "Authorization", required = false) String authorizationHeader
    ) {
        log.info("▶️ [VehicleController] Récupération des véhicules pour l'utilisateur ID: {}", userId);

        String token = Optional.ofNullable(authorizationHeader).orElse(null);

        // MODIFIÉ : Récupère l'organisation ID du userId spécifié.
        // Puis, filtre les produits de cette organisation qui appartiennent à ce userId.
        return profileService.findOrganisationIdByUserId(userId)
                .flatMapMany(orgId -> resourceService.getProductsByCategory(orgId, VEHICLE_CATEGORY_ID, token, null)
                                                    .filter(product -> userId.equals(product.getClientId())));
    }

    /**
     * SECURISE (CONDUCTEUR): Crée un nouveau véhicule pour le chauffeur connecté.
     */
    @PostMapping
    public Mono<ResponseEntity<Product>> createVehicle(
            @RequestBody CreateProductRequest request,
            @AuthenticationPrincipal Mono<Jwt> jwtMono,
            @RequestHeader("Authorization") String authorizationHeader) {

        return jwtMono
            .flatMap(jwt -> profileService.getUserSessionContext(JwtUtil.getUserIdFromToken(jwt), authorizationHeader, null))
            .flatMap(userContext -> {
                if (userContext.getDriverProfile() == null) {
                    return Mono.error(new IllegalStateException("Seuls les chauffeurs peuvent créer des véhicules."));
                }
                if (userContext.getOrganisation() == null || userContext.getOrganisation().getOrganizationId() == null) {
                    return Mono.error(new IllegalStateException("Contexte utilisateur invalide pour créer un véhicule (organisation manquante)."));
                }
                DriverProfile driverProfile = userContext.getDriverProfile();

                request.setCategoryId(VEHICLE_CATEGORY_ID);
                request.setClientId(driverProfile.getUserId()); // Le chauffeur connecté est le propriétaire du véhicule
                // Les autres champs comme clientName, clientPhoneNumber, clientProfileImageUrl peuvent être définis ici
                // pour enrichir le produit si nécessaire, mais le service de ressources pourrait déjà le faire.
                request.setClientName(driverProfile.getFirstName() + " " + driverProfile.getLastName());
                request.setClientPhoneNumber(driverProfile.getPhoneNumber());
                request.setClientProfileImageUrl(driverProfile.getProfileImageUrl());
                
                log.info("▶️ Controller: Création d'un nouveau véhicule '{}' pour le chauffeur {}", request.getName(), driverProfile.getUserId());
                
                return resourceService.createProduct(
                    userContext.getOrganisation().getOrganizationId(), 
                    request, 
                    authorizationHeader, 
                    null
                );
            })
            .map(createdProduct -> new ResponseEntity<>(createdProduct, HttpStatus.CREATED));
    }

    /**
     * SECURISE (CONDUCTEUR): Met à jour un véhicule existant.
     */
    @PutMapping("/{vehicleId}")
    public Mono<ResponseEntity<Product>> updateVehicle(
            @PathVariable UUID vehicleId,
            @RequestBody CreateProductRequest request,
            @AuthenticationPrincipal Mono<Jwt> jwtMono,
            @RequestHeader("Authorization") String authorizationHeader) {
        
        return jwtMono
            .flatMap(jwt -> profileService.getUserSessionContext(JwtUtil.getUserIdFromToken(jwt), authorizationHeader, null))
            .flatMap(userContext -> {
                if (userContext.getDriverProfile() == null) {
                    return Mono.error(new IllegalStateException("Seuls les chauffeurs peuvent modifier leurs véhicules."));
                }
                if (userContext.getOrganisation() == null || userContext.getOrganisation().getOrganizationId() == null) {
                    return Mono.error(new IllegalStateException("Contexte utilisateur invalide pour mettre à jour un véhicule (organisation manquante)."));
                }
                DriverProfile driverProfile = userContext.getDriverProfile();

                // Vérification cruciale : l'utilisateur connecté est-il le propriétaire du véhicule ?
                return resourceService.getProductsByCategory(userContext.getOrganisation().getOrganizationId(), VEHICLE_CATEGORY_ID, authorizationHeader, null)
                        .filter(product -> product.getId().equals(vehicleId) && driverProfile.getUserId().equals(product.getClientId()))
                        .next() // Prend le premier élément ou vide
                        .switchIfEmpty(Mono.error(new SecurityException("Le chauffeur n'est pas autorisé à modifier ce véhicule ou il n'existe pas.")))
                        .flatMap(existingVehicle -> {
                            request.setCategoryId(VEHICLE_CATEGORY_ID);
                            request.setClientId(driverProfile.getUserId()); // Assure que le propriétaire reste le même
                            request.setClientName(driverProfile.getFirstName() + " " + driverProfile.getLastName());
                            request.setClientPhoneNumber(driverProfile.getPhoneNumber());
                            request.setClientProfileImageUrl(driverProfile.getProfileImageUrl());

                            log.info("▶️ Controller: Mise à jour du véhicule ID: {}", vehicleId);
                            
                            return resourceService.updateProduct(
                                userContext.getOrganisation().getOrganizationId(), 
                                vehicleId,
                                request, 
                                authorizationHeader, 
                                null
                            );
                        });
            })
            .map(ResponseEntity::ok)
            .defaultIfEmpty(ResponseEntity.notFound().build());
    }

    /**
     * SECURISE (CONDUCTEUR): Supprime un véhicule existant.
     */
    @DeleteMapping("/{vehicleId}")
    public Mono<ResponseEntity<Void>> deleteVehicle(
            @PathVariable UUID vehicleId,
            @AuthenticationPrincipal Mono<Jwt> jwtMono,
            @RequestHeader("Authorization") String authorizationHeader) {

        return jwtMono
            .flatMap(jwt -> profileService.getUserSessionContext(JwtUtil.getUserIdFromToken(jwt), authorizationHeader, null))
            .flatMap(userContext -> {
                if (userContext.getDriverProfile() == null) {
                    return Mono.error(new IllegalStateException("Seuls les chauffeurs peuvent supprimer leurs véhicules."));
                }
                if (userContext.getOrganisation() == null || userContext.getOrganisation().getOrganizationId() == null) {
                    return Mono.error(new IllegalStateException("Contexte utilisateur invalide pour supprimer un véhicule (organisation manquante)."));
                }
                DriverProfile driverProfile = userContext.getDriverProfile();

                // Vérification cruciale : l'utilisateur connecté est-il le propriétaire du véhicule ?
                return resourceService.getProductsByCategory(userContext.getOrganisation().getOrganizationId(), VEHICLE_CATEGORY_ID, authorizationHeader, null)
                        .filter(product -> product.getId().equals(vehicleId) && driverProfile.getUserId().equals(product.getClientId()))
                        .next() // Prend le premier élément ou vide
                        .switchIfEmpty(Mono.error(new SecurityException("Le chauffeur n'est pas autorisé à supprimer ce véhicule ou il n'existe pas.")))
                        .flatMap(existingVehicle -> {
                            log.info("▶️ Controller: Suppression du véhicule ID: {}", vehicleId);
                            return resourceService.deleteProduct(
                                userContext.getOrganisation().getOrganizationId(), 
                                vehicleId,
                                authorizationHeader, 
                                null
                            );
                        });
            })
            .then(Mono.just(new ResponseEntity<Void>(HttpStatus.NO_CONTENT)));
    }
}// END OF FILE: src/main/java/com/freelance/driver_backend/controller/VehicleController.java

//---> PATH: /home/mbogneng-junior/freelance-driver_Sylladb/backend/src/main/java/com/freelance/driver_backend/DriverBackendApplication.java

package com.freelance.driver_backend;


import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;



@SpringBootApplication

public class DriverBackendApplication {

    public static void main(String[] args) {
        SpringApplication.run(DriverBackendApplication.class, args);
    }

   
}// END OF FILE: src/main/java/com/freelance/driver_backend/DriverBackendApplication.java

//---> PATH: /home/mbogneng-junior/freelance-driver_Sylladb/backend/src/main/java/com/freelance/driver_backend/dto/CreateProductRequest.java

// src/main/java/com/freelance/driver_backend/dto/CreateProductRequest.java

package com.freelance.driver_backend.dto;

import lombok.Data;
import java.math.BigDecimal;
import java.util.Map;
import java.util.UUID;

/**
 * DTO (Data Transfer Object) universel pour la création et la mise à jour de
 * "Produits".
 * Il regroupe tous les champs potentiels envoyés par le frontend pour
 * différentes entités
 * (Annonces, Plannings, Véhicules, Adresses, etc.).
 */
@Data
public class CreateProductRequest {
    private String id; // L'ID du produit (UUID en string)

    // --- Champs Communs ---
    private String name;
    private String shortDescription;
    private UUID categoryId;
    private Boolean isActive;
    private String status;
    private BigDecimal defaultSellPrice;

    // --- Champs de Trajet (Annonces/Plannings) ---
    private String pickupLocation;
    private String dropoffLocation;
    private String startDate;
    private String startTime;
    private String endDate;
    private String endTime;

    // --- Champs d'Annonce Spécifiques ---
    private String baggageInfo;
    private boolean isNegotiable;
    private String paymentMethod;

    // --- Champs d'Auteur (Client ou Conducteur) ---
    private UUID clientId;
    private String clientName;
    private String clientPhoneNumber;
    private String clientProfileImageUrl;

    // --- Champs Spécifiques au Planning (stockés dans metadata par le controller)
    // ---
    private String paymentOption;
    private BigDecimal regularAmount;
    private String discountPercentage;
    private BigDecimal discountedAmount;

    // --- Stockage Flexible ---
    private Map<String, String> metadata;
}// END OF FILE: src/main/java/com/freelance/driver_backend/dto/CreateProductRequest.java

//---> PATH: /home/mbogneng-junior/freelance-driver_Sylladb/backend/src/main/java/com/freelance/driver_backend/dto/CreateReviewRequest.java

package com.freelance.driver_backend.dto;

import lombok.Data;

import java.util.UUID;

@Data
public class CreateReviewRequest {
    private UUID targetUserId;
    private int score;
    private String comment;
}
// END OF FILE: src/main/java/com/freelance/driver_backend/dto/CreateReviewRequest.java

//---> PATH: /home/mbogneng-junior/freelance-driver_Sylladb/backend/src/main/java/com/freelance/driver_backend/dto/external/ChatUserCreationPayload.java

package com.freelance.driver_backend.dto.external;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.util.Map;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class ChatUserCreationPayload {
    private String projectId;
    private String externalId;
    private String avatar;
    private String displayName;
    private String email;
    private String phoneNumber;
    private String login;
    private String secret;
    private Map<String, String> customJson;
}// END OF FILE: src/main/java/com/freelance/driver_backend/dto/external/ChatUserCreationPayload.java

//---> PATH: /home/mbogneng-junior/freelance-driver_Sylladb/backend/src/main/java/com/freelance/driver_backend/dto/external/ChatUserCreationResponse.java

package com.freelance.driver_backend.dto.external;

import lombok.Data;


@Data
public class ChatUserCreationResponse {
    private String id;
    private String projectId;
    private String externalId;
    private String avatar;
    private String displayName;
    private String email;
    private String phoneNumber;
    private String login;
    private String username;
    private boolean online;
    private boolean enabled;
    // On peut omettre les autres champs pour la simplicité
}// END OF FILE: src/main/java/com/freelance/driver_backend/dto/external/ChatUserCreationResponse.java

//---> PATH: /home/mbogneng-junior/freelance-driver_Sylladb/backend/src/main/java/com/freelance/driver_backend/dto/external/ChatUserLoginPayload.java

package com.freelance.driver_backend.dto.external;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class ChatUserLoginPayload {
    private String projectId;
    private String login;
    private String secret;
}
// END OF FILE: src/main/java/com/freelance/driver_backend/dto/external/ChatUserLoginPayload.java

//---> PATH: /home/mbogneng-junior/freelance-driver_Sylladb/backend/src/main/java/com/freelance/driver_backend/dto/external/ChatUserLoginResponse.java

package com.freelance.driver_backend.dto.external;

import lombok.Data;

@Data
public class ChatUserLoginResponse {
    private ChatUserCreationResponse data;
    private String token;
}// END OF FILE: src/main/java/com/freelance/driver_backend/dto/external/ChatUserLoginResponse.java

//---> PATH: /home/mbogneng-junior/freelance-driver_Sylladb/backend/src/main/java/com/freelance/driver_backend/dto/external/LoginRequest.java

package com.freelance.driver_backend.dto.external;


import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class LoginRequest {
    private String username;
    private String password;
}// END OF FILE: src/main/java/com/freelance/driver_backend/dto/external/LoginRequest.java

//---> PATH: /home/mbogneng-junior/freelance-driver_Sylladb/backend/src/main/java/com/freelance/driver_backend/dto/external/LoginResponse.java

// Fichier : src/main/java/com/freelance/driver_backend/dto/external/LoginResponse.java
package com.freelance.driver_backend.dto.external;

import com.fasterxml.jackson.annotation.JsonProperty;
import lombok.Data;
import java.util.List;
import java.util.UUID;

@Data
public class LoginResponse {
    @JsonProperty("access_token")
    private AccessToken accessToken;
    private UserInfo user;
    private List<String> roles;
    private List<String> permissions;

    @Data
    public static class AccessToken {
        private String token;
        private String type;
        @JsonProperty("expire_in")
        private int expiresIn;
    }

    @Data
    public static class UserInfo {
        private UUID id;
        @JsonProperty("first_name")
        private String firstName;
        @JsonProperty("last_name")
        private String lastName;
        private String username;
        private String email;
        @JsonProperty("phone_number")
        private String phoneNumber;
        @JsonProperty("email_verified")
        private boolean emailVerified;
        @JsonProperty("phone_number_verified")
        private boolean phoneNumberVerified;
    }
}// END OF FILE: src/main/java/com/freelance/driver_backend/dto/external/LoginResponse.java

//---> PATH: /home/mbogneng-junior/freelance-driver_Sylladb/backend/src/main/java/com/freelance/driver_backend/dto/external/NotificationRequest.java

package com.freelance.driver_backend.dto.external;

import com.fasterxml.jackson.annotation.JsonProperty;
import lombok.Builder;
import lombok.Data;
import java.util.List;
import java.util.Map;
import java.util.UUID;

@Data
@Builder
public class NotificationRequest {

    @JsonProperty("template_id")
    private UUID templateId;

    private String subject;
    private String body;
    private List<String> recipients;
    private String type; // ex: "EMAIL", "SMS"
    private String priority; // ex: "LEVEL_1"
    

    // Pour les variables Thymeleaf
    private Map<String, String> metadata;
    private Map<String, String> data;
}// END OF FILE: src/main/java/com/freelance/driver_backend/dto/external/NotificationRequest.java

//---> PATH: /home/mbogneng-junior/freelance-driver_Sylladb/backend/src/main/java/com/freelance/driver_backend/dto/external/OAuthTokenResponse.java

package com.freelance.driver_backend.dto.external;

import com.fasterxml.jackson.annotation.JsonProperty;
import lombok.Data;

@Data
public class OAuthTokenResponse {

    @JsonProperty("access_token")
    private String accessToken;

    @JsonProperty("token_type")
    private String tokenType;

    @JsonProperty("expires_in")
    private int expiresIn;

    private String scope;
}// END OF FILE: src/main/java/com/freelance/driver_backend/dto/external/OAuthTokenResponse.java

//---> PATH: /home/mbogneng-junior/freelance-driver_Sylladb/backend/src/main/java/com/freelance/driver_backend/dto/external/OrganisationCreationRequest.java

package com.freelance.driver_backend.dto.external;

import com.fasterxml.jackson.annotation.JsonProperty;
import lombok.Builder;
import lombok.Data;

import java.time.OffsetDateTime;
import java.util.List;

@Data
@Builder
public class OrganisationCreationRequest {

    @JsonProperty("long_name")
    private String longName;

    @JsonProperty("short_name")
    private String shortName;

    private String email;
    private String description;

    @JsonProperty("business_domains")
    private List<String> businessDomains;

    @JsonProperty("logo_url")
    private String logoUrl;

    @JsonProperty("legal_form")
    private String legalForm; // ex: "11"

    @JsonProperty("web_site_url")
    private String webSiteUrl;

    @JsonProperty("social_network")
    private String socialNetwork;

    @JsonProperty("business_registration_number")
    private String businessRegistrationNumber;

    @JsonProperty("tax_number")
    private String taxNumber;

    @JsonProperty("capital_share")
    private Double capitalShare;

    @JsonProperty("registration_date")
    private OffsetDateTime registrationDate;

    @JsonProperty("ceo_name")
    private String ceoName;

    @JsonProperty("year_founded")
    private OffsetDateTime yearFounded;

    private List<String> keywords;

    @JsonProperty("number_of_employees")
    private Integer numberOfEmployees;
}// END OF FILE: src/main/java/com/freelance/driver_backend/dto/external/OrganisationCreationRequest.java

//---> PATH: /home/mbogneng-junior/freelance-driver_Sylladb/backend/src/main/java/com/freelance/driver_backend/dto/external/OrganisationDto.java

// Fichier : src/main/java/com/freelance/driver_backend/dto/external/OrganisationDto.java
package com.freelance.driver_backend.dto.external;

import com.fasterxml.jackson.annotation.JsonProperty;
import lombok.Data;
import java.util.UUID;

@Data
public class OrganisationDto {
    @JsonProperty("organization_id")
    private UUID organizationId;
    @JsonProperty("long_name")
    private String longName;
    private String description;
    private String status;
    // Ajouter d'autres champs si nécessaire pour votre logique,
    // mais pour le moment, c'est suffisant.
}// END OF FILE: src/main/java/com/freelance/driver_backend/dto/external/OrganisationDto.java

//---> PATH: /home/mbogneng-junior/freelance-driver_Sylladb/backend/src/main/java/com/freelance/driver_backend/dto/external/RegistrationRequest.java

package com.freelance.driver_backend.dto.external;

import com.fasterxml.jackson.annotation.JsonProperty;
import lombok.Builder;
import lombok.Data;
import java.util.Collections;
import java.util.List;

@Data
@Builder // Utiliser le pattern Builder est plus propre
public class RegistrationRequest {
    private String username;
    private String email;
    private String password;
    @JsonProperty("first_name")
    private String firstName;
    @JsonProperty("last_name")
    private String lastName;
    @JsonProperty("phone_number")
    private String phoneNumber;
    
    // Initialisé à une liste vide comme dans l'exemple de l'API
    @Builder.Default
    private List<Authority> authorities = Collections.emptyList();

    @Data
    public static class Authority {
        // Cette classe peut rester vide si on ne l'utilise pas, ou la supprimer si on envoie toujours une liste vide.
    }
}// END OF FILE: src/main/java/com/freelance/driver_backend/dto/external/RegistrationRequest.java

//---> PATH: /home/mbogneng-junior/freelance-driver_Sylladb/backend/src/main/java/com/freelance/driver_backend/dto/external/UploadMediaResponse.java

package com.freelance.driver_backend.dto.external;

import lombok.Data;
import java.util.UUID;

/**
 * Représente la réponse JSON obtenue après un téléversement réussi
 * auprès du service de média.
 */
@Data
public class UploadMediaResponse {
    private UUID id;
    private UUID resourceId;
    private String uri;
    private String url;
}// END OF FILE: src/main/java/com/freelance/driver_backend/dto/external/UploadMediaResponse.java

//---> PATH: /home/mbogneng-junior/freelance-driver_Sylladb/backend/src/main/java/com/freelance/driver_backend/dto/external/UserDto.java

package com.freelance.driver_backend.dto.external;



import com.fasterxml.jackson.annotation.JsonProperty;
import lombok.Data;
import java.time.OffsetDateTime;
import java.util.UUID;

@Data
public class UserDto {
    private UUID id;
    private String username;
    private String email;
    @JsonProperty("first_name")
    private String firstName;
    @JsonProperty("last_name")
    private String lastName;
    @JsonProperty("phone_number")
    private String phoneNumber;
    @JsonProperty("email_verified")
    private boolean emailVerified;
    @JsonProperty("phone_number_verified")
    private boolean phoneNumberVerified;
    @JsonProperty("is_enabled")
    private boolean isEnabled;
    @JsonProperty("created_at")
    private OffsetDateTime createdAt;
    @JsonProperty("updated_at")
    private OffsetDateTime updatedAt;
}// END OF FILE: src/main/java/com/freelance/driver_backend/dto/external/UserDto.java

//---> PATH: /home/mbogneng-junior/freelance-driver_Sylladb/backend/src/main/java/com/freelance/driver_backend/dto/onboarding/ChatSessionInfo.java

package com.freelance.driver_backend.dto.onboarding;

import com.freelance.driver_backend.dto.external.ChatUserCreationResponse;
import lombok.Builder; // <-- Vérifie cet import
import lombok.Data;

@Data
@Builder // <-- C'est cette annotation qui crée la méthode builder()
public class ChatSessionInfo {
    private String token;
    private ChatUserCreationResponse userDetails;
}// END OF FILE: src/main/java/com/freelance/driver_backend/dto/onboarding/ChatSessionInfo.java

//---> PATH: /home/mbogneng-junior/freelance-driver_Sylladb/backend/src/main/java/com/freelance/driver_backend/dto/onboarding/ClientOnboardingRequest.java

package com.freelance.driver_backend.dto.onboarding;

import lombok.Data;

@Data
public class ClientOnboardingRequest {
    // Infos pour le compte User
    private String email;
    private String password;
    private String firstName; // Nom du contact principal
    private String lastName;  // Prénom du contact principal
    private String phoneNumber;

    // Infos pour l'organisation du Client
    private String companyName;
    private String companyDescription;
    private String otp;
}// END OF FILE: src/main/java/com/freelance/driver_backend/dto/onboarding/ClientOnboardingRequest.java

//---> PATH: /home/mbogneng-junior/freelance-driver_Sylladb/backend/src/main/java/com/freelance/driver_backend/dto/onboarding/DriverOnboardingRequest.java

package com.freelance.driver_backend.dto.onboarding;

import lombok.Data;

@Data
public class DriverOnboardingRequest {
    // Infos pour le compte User
    private String email;
    private String password;
    private String firstName;
    private String lastName;
    private String phoneNumber;

    // Infos pour l'organisation
    private String companyName;
    private String companyDescription;

    // Infos pour le profil spécifique Driver
    private String licenseNumber;
    private String vehicleDetails;
    private String otp;
}// END OF FILE: src/main/java/com/freelance/driver_backend/dto/onboarding/DriverOnboardingRequest.java

//---> PATH: /home/mbogneng-junior/freelance-driver_Sylladb/backend/src/main/java/com/freelance/driver_backend/dto/onboarding/OnboardingResponse.java

package com.freelance.driver_backend.dto.onboarding;

import lombok.Builder;
import lombok.Data;

@Data
@Builder
public class OnboardingResponse {
    private String token;
    private Object profile;
    private ChatSessionInfo chatSession; // <-- AJOUTE CETTE LIGNE
}// END OF FILE: src/main/java/com/freelance/driver_backend/dto/onboarding/OnboardingResponse.java

//---> PATH: /home/mbogneng-junior/freelance-driver_Sylladb/backend/src/main/java/com/freelance/driver_backend/dto/RateCriteriaRequest.java

package com.freelance.driver_backend.dto;

import lombok.Data;
import java.util.Map;
import java.util.UUID;

@Data
public class RateCriteriaRequest {
    private String entityId;
    private Map<String, Integer> ratings;
}
// END OF FILE: src/main/java/com/freelance/driver_backend/dto/RateCriteriaRequest.java

//---> PATH: /home/mbogneng-junior/freelance-driver_Sylladb/backend/src/main/java/com/freelance/driver_backend/dto/UserSessionContextDto.java

package com.freelance.driver_backend.dto;

import com.fasterxml.jackson.annotation.JsonInclude;
import com.freelance.driver_backend.dto.external.OrganisationDto;
import com.freelance.driver_backend.model.ClientProfile; // Nouveau import
import com.freelance.driver_backend.model.DriverProfile; // Nouveau import
import lombok.Builder;
import lombok.Data;
import java.util.List; // Import modifié pour une liste de rôles
import java.util.UUID;

@Data
@Builder // Le Builder sera très pratique pour construire cet objet complexe
@JsonInclude(JsonInclude.Include.NON_NULL) // N'inclut que les champs non nuls dans le JSON
public class UserSessionContextDto {

    private UUID userId;
    // MODIFIÉ : Une liste de rôles, permettant plusieurs rôles
    private List<UserRole> roles;
    // MODIFIÉ : Des objets de profil spécifiques, peuvent être nuls
    private DriverProfile driverProfile;
    private ClientProfile clientProfile;
    // L'objet Organisation enrichi. Un utilisateur aura une organisation "principale" (par exemple, la première créée)
    private OrganisationDto organisation;

    public enum UserRole {
        DRIVER,
        CLIENT,
        NO_PROFILE // Représente un utilisateur avec un compte d'authentification mais sans profil spécifique encore
    }
}// END OF FILE: src/main/java/com/freelance/driver_backend/dto/UserSessionContextDto.java

//---> PATH: /home/mbogneng-junior/freelance-driver_Sylladb/backend/src/main/java/com/freelance/driver_backend/initializer/ApplicationInitializer.java



package com.freelance.driver_backend.initializer;

import com.freelance.driver_backend.model.DesignTemplate;
import com.freelance.driver_backend.model.EmailTemplate;
import com.freelance.driver_backend.model.FirebaseSetting;
import com.freelance.driver_backend.model.PushTemplate;
import com.freelance.driver_backend.model.SmtpSetting;
import com.freelance.driver_backend.model.mock.MockOrganisation;
import com.freelance.driver_backend.repository.DesignTemplateRepository;
import com.freelance.driver_backend.repository.EmailTemplateRepository;
import com.freelance.driver_backend.repository.FirebaseSettingRepository;
import com.freelance.driver_backend.repository.PushTemplateRepository;
import com.freelance.driver_backend.repository.SmtpSettingRepository;
import com.freelance.driver_backend.repository.mock.MockOrganisationRepository;
import io.github.cdimascio.dotenv.Dotenv;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.boot.CommandLineRunner;
import org.springframework.context.annotation.Profile;
import org.springframework.core.io.ClassPathResource;
import org.springframework.stereotype.Component;

import java.io.IOException;
import java.io.InputStream;
import java.util.UUID;


@Component

@RequiredArgsConstructor
@Slf4j
public class ApplicationInitializer implements CommandLineRunner {

    private final Dotenv dotenv;
    @Value("${spring.mail.host}")
    private String mailHost;
    @Value("${spring.mail.port}")
    private int mailPort;
    @Value("${spring.mail.username}")
    private String mailUsername;
    @Value("${spring.mail.password}")
    private String mailPassword;

    private final MockOrganisationRepository mockOrganisationRepository;
    private final SmtpSettingRepository smtpSettingRepository;
    private final FirebaseSettingRepository firebaseSettingRepository;
    private final DesignTemplateRepository designTemplateRepository;
    private final EmailTemplateRepository emailTemplateRepository;
    private final PushTemplateRepository pushTemplateRepository;


    @Override
    public void run(String... args) {
        log.info("🚀 Démarrage du processus d'initialisation des templates et configs internes de l'application...");

        UUID sysOrgId = getUuidFromEnv("SYSTEM_ORGANIZATION_ID");
        UUID smtpSettingId = getUuidFromEnv("SMTP_SETTING_ID");
        UUID firebaseSettingId = getUuidFromEnv("FIREBASE_SETTING_ID");
        UUID designEmailOtpId = getUuidFromEnv("DESIGN_EMAIL_OTP_ID");
        UUID templateEmailOtpId = getUuidFromEnv("TEMPLATE_EMAIL_OTP_ID");
        UUID templatePushNewPlanningId = getUuidFromEnv("TEMPLATE_PUSH_NEW_PLANNING_ID");
        UUID templatePushNewAnnouncementId = getUuidFromEnv("TEMPLATE_PUSH_NEW_ANNOUNCEMENT_ID");
        UUID templatePushAnnouncementAcceptedId = getUuidFromEnv("TEMPLATE_PUSH_ANNOUNCEMENT_ACCEPTED_ID");
        UUID templatePushAnnouncementConfirmedId = getUuidFromEnv("TEMPLATE_PUSH_ANNOUNCEMENT_CONFIRMED_ID");
        UUID templatePushPostulationCancelledId = getUuidFromEnv("TEMPLATE_PUSH_POSTULATION_CANCELLED_ID");

        // NOUVEAUX TEMPLATES POUR LE FLUX CLIENT-PLANNING
        UUID templatePushPlanningBookingRequestedToDriverId = getUuidFromEnv("TEMPLATE_PUSH_PLANNING_BOOKING_REQUESTED_TO_DRIVER_ID");
        UUID templatePushPlanningBookingAcceptedToClientId = getUuidFromEnv("TEMPLATE_PUSH_PLANNING_BOOKING_ACCEPTED_TO_CLIENT_ID");
        UUID templatePushPlanningReservationCancelledId = getUuidFromEnv("TEMPLATE_PUSH_PLANNING_RESERVATION_CANCELLED_ID");


        log.info("ℹ️ Les configurations UUID pour les templates sont lues depuis les variables d'environnement/fichier .env.");

        // Étape 2: Insertion de l'organisation 'Système'
        MockOrganisation systemOrg = new MockOrganisation();
        systemOrg.setOrganizationId(sysOrgId);
        systemOrg.setLongName("System Default");
        systemOrg.setDescription("Organisation par défaut pour les templates globaux");
        mockOrganisationRepository.save(systemOrg)
            .doOnSuccess(org -> log.info("✅ Organisation 'Système' insérée/mise à jour: {}", org.getLongName()))
            .doOnError(e -> log.error("❌ Échec de l'insertion de l'organisation système dans ScyllaDB: {}", e.getMessage()))
            .block();


        log.info("🔷 ÉTAPE 3: Configuration des templates de notification via les dépôts...");

        // 3.1 Création du Setting SMTP
        SmtpSetting smtpSetting = new SmtpSetting();
        smtpSetting.setId(smtpSettingId);
        smtpSetting.setOrganizationId(sysOrgId);
        smtpSetting.setHost(mailHost);
        smtpSetting.setPort(mailPort);
        smtpSetting.setEncryption("TLS");
        smtpSetting.setUsername(mailUsername);
        smtpSetting.setPassword(mailPassword);
        smtpSetting.setSenderEmail("no-reply@freelancedriver.com");
        smtpSetting.setSenderName("Freelance Driver App");

        smtpSettingRepository.save(smtpSetting)
            .doOnSuccess(s -> log.info("✅ Template SMTP créé/mis à jour."))
            .doOnError(e -> log.error("❌ Échec création/mise à jour SMTP: {}", e.getMessage()))
            .block();

        // 3.2 Création du Setting Firebase
        FirebaseSetting firebaseSetting = new FirebaseSetting();
        firebaseSetting.setId(firebaseSettingId);
        firebaseSetting.setOrganizationId(sysOrgId);
        firebaseSetting.setProjectId("freelance-driver-app"); 

        ClassPathResource resource = new ClassPathResource("firebase-service-account-key.json");
        try (InputStream serviceAccount = resource.getInputStream()) {
            String privateKeyJson = new String(serviceAccount.readAllBytes());
            privateKeyJson = privateKeyJson.replace("\"", "\\\"").replace("\n", "").replace("\r", "");
            firebaseSetting.setPrivateKey(privateKeyJson);
        } catch (IOException e) {
            log.error("❌ Erreur de lecture du fichier Firebase private key: {}", e.getMessage());
            throw new RuntimeException("Could not load Firebase service account key.", e);
        }

        firebaseSettingRepository.save(firebaseSetting)
            .doOnSuccess(fs -> log.info("✅ Template Firebase créé/mis à jour."))
            .doOnError(e -> log.error("❌ Échec création/mise à jour Firebase: {}", e.getMessage()))
            .block();

        // 3.3 Création du Design de l'email OTP
        DesignTemplate designOtp = new DesignTemplate();
        designOtp.setId(designEmailOtpId);
        designOtp.setOrganizationId(sysOrgId);
        designOtp.setTitle("Email OTP");
        designOtp.setSubject("Votre code de vérification : [[${otpCode}]]");
        designOtp.setHtml("<!DOCTYPE html><html xmlns:th=\"http://www.thymeleaf.org\"><body><h1>Bonjour [[${firstName}]],</h1><p>Votre code de vérification est :</p><h2 style='color: #007AFF;'>[[${otpCode}]]</h2></body></html>");

        designTemplateRepository.save(designOtp)
            .doOnSuccess(dt -> log.info("✅ DesignTemplate (OTP) créé/mis à jour."))
            .doOnError(e -> log.error("❌ Échec création/mise à jour DesignTemplate (OTP): {}", e.getMessage()))
            .block();

        // 3.4 Création de l'EmailTemplate (Règle d'envoi OTP)
        EmailTemplate emailOtpTemplate = new EmailTemplate();
        emailOtpTemplate.setId(templateEmailOtpId);
        emailOtpTemplate.setOrganizationId(sysOrgId);
        emailOtpTemplate.setSettingId(smtpSettingId);
        emailOtpTemplate.setDesignTemplateId(designEmailOtpId);
        emailOtpTemplate.setTitle("Règle envoi OTP");

        emailTemplateRepository.save(emailOtpTemplate)
            .doOnSuccess(et -> log.info("✅ EmailTemplate (OTP) créé/mis à jour."))
            .doOnError(e -> log.error("❌ Échec création/mise à jour EmailTemplate (OTP): {}", e.getMessage()))
            .block();

        PushTemplate pushNewPlanning = new PushTemplate();
        pushNewPlanning.setId(templatePushNewPlanningId);
        pushNewPlanning.setOrganizationId(sysOrgId);
        pushNewPlanning.setSettingId(firebaseSettingId);
        pushNewPlanning.setTitle("Nouveau planning disponible !");
        pushNewPlanning.setBody("Le chauffeur {{driverName}} propose un trajet vers {{destination}} à {{cost}} FCFA.");
        pushTemplateRepository.save(pushNewPlanning)
            .doOnSuccess(pt -> log.info("✅ PushTemplate (New Planning) créé/mis à jour."))
            .doOnError(e -> log.error("❌ Échec création/mise à jour PushTemplate (New Planning): {}", e.getMessage()))
            .block();

        PushTemplate pushNewAnnouncement = new PushTemplate();
        pushNewAnnouncement.setId(templatePushNewAnnouncementId);
        pushNewAnnouncement.setOrganizationId(sysOrgId);
        pushNewAnnouncement.setSettingId(firebaseSettingId);
        pushNewAnnouncement.setTitle("Nouvelle course client !");
        pushNewAnnouncement.setBody("Un client a posté un nouveau trajet : {{tripTitle}}");
        pushTemplateRepository.save(pushNewAnnouncement)
            .doOnSuccess(pt -> log.info("✅ PushTemplate (New Announcement) créé/mis à jour."))
            .doOnError(e -> log.error("❌ Échec création/mise à jour PushTemplate (New Announcement): {}", e.getMessage()))
            .block();

        PushTemplate pushAnnouncementAccepted = new PushTemplate();
        pushAnnouncementAccepted.setId(templatePushAnnouncementAcceptedId);
        pushAnnouncementAccepted.setOrganizationId(sysOrgId);
        pushAnnouncementAccepted.setSettingId(firebaseSettingId);
        pushAnnouncementAccepted.setTitle("Votre course a un chauffeur !");
        pushAnnouncementAccepted.setBody("Le chauffeur {{driverName}} a postulé pour votre trajet \"{{tripTitle}}\". Appuyez pour accepter.");
        pushTemplateRepository.save(pushAnnouncementAccepted)
            .doOnSuccess(pt -> log.info("✅ PushTemplate (Announcement Accepted - Postulation) créé/mis à jour."))
            .doOnError(e -> log.error("❌ Échec création/mise à jour PushTemplate (Announcement Accepted - Postulation): {}", e.getMessage()))
            .block();

        PushTemplate pushAnnouncementConfirmed = new PushTemplate();
        pushAnnouncementConfirmed.setId(templatePushAnnouncementConfirmedId);
        pushAnnouncementConfirmed.setOrganizationId(sysOrgId);
        pushAnnouncementConfirmed.setSettingId(firebaseSettingId);
        pushAnnouncementConfirmed.setTitle("Félicitations ! Votre postulation a été acceptée !");
        pushAnnouncementConfirmed.setBody("Le client {{clientName}} a confirmé votre postulation pour le trajet \"{{tripTitle}}\". La course est en cours !");
        pushTemplateRepository.save(pushAnnouncementConfirmed)
            .doOnSuccess(pt -> log.info("✅ PushTemplate (Announcement Confirmed - Chauffeur) créé/mis à jour."))
            .doOnError(e -> log.error("❌ Échec création/mise à jour PushTemplate (Announcement Confirmed - Chauffeur): {}", e.getMessage()))
            .block();

        PushTemplate pushPostulationCancelled = new PushTemplate();
        pushPostulationCancelled.setId(templatePushPostulationCancelledId);
        pushPostulationCancelled.setOrganizationId(sysOrgId);
        pushPostulationCancelled.setSettingId(firebaseSettingId);
        pushPostulationCancelled.setTitle("Annulation de postulation !");
        pushPostulationCancelled.setBody("Le chauffeur {{driverName}} a annulé sa postulation pour votre annonce \"{{tripTitle}}\". L'annonce est de nouveau publiée.");
        pushTemplateRepository.save(pushPostulationCancelled)
            .doOnSuccess(pt -> log.info("✅ PushTemplate (Postulation Cancelled) créé/mis à jour."))
            .doOnError(e -> log.error("❌ Échec création/mise à jour PushTemplate (Postulation Cancelled): {}", e.getMessage()))
            .block();

        // NOUVEAU : Template pour la notification au CHAUFFEUR quand le client DEMANDE à réserver son planning
        PushTemplate pushPlanningBookingRequestedToDriver = new PushTemplate();
        pushPlanningBookingRequestedToDriver.setId(templatePushPlanningBookingRequestedToDriverId);
        pushPlanningBookingRequestedToDriver.setOrganizationId(sysOrgId);
        pushPlanningBookingRequestedToDriver.setSettingId(firebaseSettingId);
        pushPlanningBookingRequestedToDriver.setTitle("Demande de réservation reçue !");
        pushPlanningBookingRequestedToDriver.setBody("Le client {{clientName}} souhaite réserver votre planning \"{{tripTitle}}\". Appuyez pour accepter ou refuser.");
        pushTemplateRepository.save(pushPlanningBookingRequestedToDriver)
            .doOnSuccess(pt -> log.info("✅ PushTemplate (Planning Booking Requested To Driver) créé/mis à jour."))
            .doOnError(e -> log.error("❌ Échec création/mise à jour PushTemplate (Planning Booking Requested To Driver): {}", e.getMessage()))
            .block();

        // NOUVEAU : Template pour la notification au CLIENT quand le chauffeur ACCEPTE sa demande de réservation de planning
        PushTemplate pushPlanningBookingAcceptedToClient = new PushTemplate();
        pushPlanningBookingAcceptedToClient.setId(templatePushPlanningBookingAcceptedToClientId);
        pushPlanningBookingAcceptedToClient.setOrganizationId(sysOrgId);
        pushPlanningBookingAcceptedToClient.setSettingId(firebaseSettingId);
        pushPlanningBookingAcceptedToClient.setTitle("Votre réservation a été acceptée !");
        pushPlanningBookingAcceptedToClient.setBody("Le chauffeur {{driverName}} a accepté votre demande de réservation pour le planning \"{{tripTitle}}\". La course est en cours !");
        pushTemplateRepository.save(pushPlanningBookingAcceptedToClient)
            .doOnSuccess(pt -> log.info("✅ PushTemplate (Planning Booking Accepted To Client) créé/mis à jour."))
            .doOnError(e -> log.error("❌ Échec création/mise à jour PushTemplate (Planning Booking Accepted To Client): {}", e.getMessage()))
            .block();

        // NOUVEAU : Template pour la notification au CHAUFFEUR quand le client ANNULE sa réservation de planning
        PushTemplate pushPlanningReservationCancelled = new PushTemplate();
        pushPlanningReservationCancelled.setId(templatePushPlanningReservationCancelledId);
        pushPlanningReservationCancelled.setOrganizationId(sysOrgId);
        pushPlanningReservationCancelled.setSettingId(firebaseSettingId);
        pushPlanningReservationCancelled.setTitle("Réservation de planning annulée !");
        pushPlanningReservationCancelled.setBody("Le client {{clientName}} a annulé sa réservation pour votre planning \"{{tripTitle}}\". Le planning est de nouveau publié.");
        pushTemplateRepository.save(pushPlanningReservationCancelled)
            .doOnSuccess(pt -> log.info("✅ PushTemplate (Planning Reservation Cancelled) créé/mis à jour."))
            .doOnError(e -> log.error("❌ Échec création/mise à jour PushTemplate (Planning Reservation Cancelled): {}", e.getMessage()))
            .block();

        log.info("\n🎉 --- INITIALISATION INTERNE TERMINÉE ---");
    }

    private UUID getUuidFromEnv(String key) {
        String value = dotenv.get(key);
        if (value == null || value.isEmpty()) {
            log.error("❌ Variable d'environnement UUID '{}' non trouvée ou vide dans .env ou les variables système. L'initialisation va échouer.", key);
            throw new IllegalStateException("Missing or empty UUID environment variable: " + key);
        }
        try {
            return UUID.fromString(value);
        } catch (IllegalArgumentException e) {
            log.error("❌ La valeur '{}' pour la variable d'environnement '{}' n'est pas un UUID valide. L'initialisation va échouer.", value, key);
            throw new IllegalStateException("Invalid UUID format for environment variable: " + key, e);
        }
    }
}

// END OF FILE: src/main/java/com/freelance/driver_backend/initializer/ApplicationInitializer.java

//---> PATH: /home/mbogneng-junior/freelance-driver_Sylladb/backend/src/main/java/com/freelance/driver_backend/model/AnnouncementStatus.java

package com.freelance.driver_backend.model;

public enum AnnouncementStatus {
    DRAFT, // Annonce créée mais pas encore visible
    PUBLISHED, // Annonce visible pour les chauffeurs ou Planning visible pour les clients
    PENDING_CONFIRMATION, // Un chauffeur a postulé, en attente de la confirmation du client (pour ANNONCE)
    PENDING_DRIVER_CONFIRMATION, // Un client a demandé une réservation, en attente de la confirmation du chauffeur (pour PLANNING)
    CONFIRMED, // Le client a confirmé le chauffeur (pour ANNONCE) ou le planning est confirmé (pour PLANNING) - note: CONFIRMED est souvent une étape avant ONGOING
    ONGOING, // La course est en cours
    TERMINATED, // La course est terminée
    CANCELLED // La course est annulée
}// END OF FILE: src/main/java/com/freelance/driver_backend/model/AnnouncementStatus.java

//---> PATH: /home/mbogneng-junior/freelance-driver_Sylladb/backend/src/main/java/com/freelance/driver_backend/model/ClientProfile.java

package com.freelance.driver_backend.model;

import lombok.Data;
import org.springframework.data.cassandra.core.mapping.Column;
import org.springframework.data.cassandra.core.mapping.PrimaryKey;
import org.springframework.data.cassandra.core.mapping.Table;
import java.util.UUID;
import org.springframework.data.cassandra.core.mapping.Indexed;

@Table("client_profiles")
@Data
public class ClientProfile {
    @PrimaryKey
    private UUID id;

    @Indexed
    @Column("user_id")
    private UUID userId;

    @Column("organisation_id")
    private UUID organisationId;

    @Column("profile_image_url")
    private String profileImageUrl;

    // Informations de l'entreprise
    @Column("company_name")
    private String companyName;

    // Informations du contact principal
    @Column("first_name")
    private String firstName;

    @Column("last_name")
    private String lastName;

    @Column("nickname")
    private String nickname;

    @Column("contact_email")
    private String contactEmail;

    @Column("phone_number")
    private String phoneNumber;

    // Informations personnelles additionnelles
    @Column("birth_date")
    private String birthDate;

    @Column("nationality")
    private String nationality;

    @Column("gender")
    private String gender;

    @Column("language")
    private String language;
}// END OF FILE: src/main/java/com/freelance/driver_backend/model/ClientProfile.java

//---> PATH: /home/mbogneng-junior/freelance-driver_Sylladb/backend/src/main/java/com/freelance/driver_backend/model/DesignTemplate.java

package com.freelance.driver_backend.model;

import lombok.Data;
import org.springframework.data.cassandra.core.mapping.Column;
import org.springframework.data.cassandra.core.mapping.PrimaryKey;
import org.springframework.data.cassandra.core.mapping.Table;
import java.util.UUID;

@Table("design_templates")
@Data
public class DesignTemplate {
    @PrimaryKey
    private UUID id;
    @Column("organization_id")
    private UUID organizationId;
    private String title;
    private String html;
    private String subject;
}// END OF FILE: src/main/java/com/freelance/driver_backend/model/DesignTemplate.java

//---> PATH: /home/mbogneng-junior/freelance-driver_Sylladb/backend/src/main/java/com/freelance/driver_backend/model/DeviceToken.java

package com.freelance.driver_backend.model;

import lombok.Data;
import org.springframework.data.cassandra.core.cql.PrimaryKeyType;
import org.springframework.data.cassandra.core.mapping.Column;
import org.springframework.data.cassandra.core.mapping.PrimaryKeyColumn;
import org.springframework.data.cassandra.core.mapping.Table;
import java.util.UUID;

@Table("device_tokens")
@Data
public class DeviceToken {

    @PrimaryKeyColumn(name = "user_id", ordinal = 0, type = PrimaryKeyType.PARTITIONED)
    @Column("user_id")
    private UUID userId;

    @PrimaryKeyColumn(name = "device_token", ordinal = 1, type = PrimaryKeyType.CLUSTERED)
    @Column("device_token")
    private String token;
}// END OF FILE: src/main/java/com/freelance/driver_backend/model/DeviceToken.java

//---> PATH: /home/mbogneng-junior/freelance-driver_Sylladb/backend/src/main/java/com/freelance/driver_backend/model/DriverProfile.java

package com.freelance.driver_backend.model;

import org.springframework.data.cassandra.core.mapping.Column;
import org.springframework.data.cassandra.core.mapping.PrimaryKey;
import org.springframework.data.cassandra.core.mapping.Table;
import org.springframework.data.cassandra.core.mapping.Indexed;
import java.util.UUID;
import lombok.Data;

@Table("driver_profiles")
@Data
public class DriverProfile {

    @PrimaryKey
    private UUID id;

    @Indexed
    @Column("user_id")
    private UUID userId;

    @Column("organisation_id")
    private UUID organisationId;

    @Column("first_name")
    private String firstName;

    @Column("last_name")
    private String lastName;

    @Column("phone_number")
    private String phoneNumber;

    @Column("license_number")
    private String licenseNumber;

    @Column("vehicle_details")
    private String vehicleDetails;

    @Column("profile_image_url")
    private String profileImageUrl;

    @Column("nickname")
    private String nickname;
    @Column("birth_date")
    private String birthDate; // On garde en String pour la simplicité
    @Column("nationality")
    private String nationality;
    @Column("gender")
    private String gender;
    @Column("language")
    private String language;
    @Column("biography")
    private String biography;
}
// END OF FILE: src/main/java/com/freelance/driver_backend/model/DriverProfile.java

//---> PATH: /home/mbogneng-junior/freelance-driver_Sylladb/backend/src/main/java/com/freelance/driver_backend/model/EmailTemplate.java

package com.freelance.driver_backend.model;

import com.fasterxml.jackson.annotation.JsonProperty; // <-- AJOUTER CET IMPORT
import lombok.Data;
import org.springframework.data.cassandra.core.mapping.Column;
import org.springframework.data.cassandra.core.mapping.PrimaryKey;
import org.springframework.data.cassandra.core.mapping.Table;
import java.util.UUID;

@Table("email_templates")
@Data
public class EmailTemplate {
    @PrimaryKey
    private UUID id;
    
    @Column("organization_id")
    @JsonProperty("organization_id")
    private UUID organizationId;
    
    @Column("setting_id")
    @JsonProperty("setting_id") // <-- CORRECTION ICI
    private UUID settingId;
    
    @Column("design_template_id")
    @JsonProperty("design_template_id") // <-- CORRECTION ICI
    private UUID designTemplateId;
    
    private String title;
}// END OF FILE: src/main/java/com/freelance/driver_backend/model/EmailTemplate.java

//---> PATH: /home/mbogneng-junior/freelance-driver_Sylladb/backend/src/main/java/com/freelance/driver_backend/model/FirebaseSetting.java

package com.freelance.driver_backend.model;

import lombok.Data;
import org.springframework.data.cassandra.core.mapping.*;
import java.util.UUID;

@Table("firebase_settings")
@Data
public class FirebaseSetting {
    @PrimaryKey
    private UUID id;
    @Column("organization_id")
    private UUID organizationId;
    @Column("project_id")
    private String projectId;
    @Column("private_key")
    private String privateKey; // Stocker le JSON de la clé de service
}// END OF FILE: src/main/java/com/freelance/driver_backend/model/FirebaseSetting.java

//---> PATH: /home/mbogneng-junior/freelance-driver_Sylladb/backend/src/main/java/com/freelance/driver_backend/model/mock/MockOrganisation.java

package com.freelance.driver_backend.model.mock; // <-- Vérifiez ce package

import lombok.Data;
import org.springframework.data.cassandra.core.mapping.*;
import java.util.UUID;

@Table("mock_organisations") // <-- Vérifiez le nom de la table
@Data
public class MockOrganisation {
    @PrimaryKey
    @Column("organization_id")
    private UUID organizationId;

    @Column("long_name")
    private String longName;

    private String description;

    @Indexed
    @Column("owner_user_id")
    private UUID ownerUserId;
}// END OF FILE: src/main/java/com/freelance/driver_backend/model/mock/MockOrganisation.java

//---> PATH: /home/mbogneng-junior/freelance-driver_Sylladb/backend/src/main/java/com/freelance/driver_backend/model/mock/MockUser.java

// Fichier : src/main/java/com/freelance/driver_backend/model/mock/MockUser.java
package com.freelance.driver_backend.model.mock;

import lombok.Data;
import org.springframework.data.cassandra.core.cql.Ordering;
import org.springframework.data.cassandra.core.cql.PrimaryKeyType;
import org.springframework.data.cassandra.core.mapping.*;

import java.util.UUID;

@Table("mock_users")
@Data
public class MockUser {
    @PrimaryKey
    private UUID id;

    @Indexed // Permet de chercher rapidement par email
    private String email;
    
    private String username;
    private String password; // ATTENTION: En DEV seulement, ne jamais stocker de mdp en clair en prod.
    
    @Column("first_name")
    private String firstName;
    
    @Column("last_name")
    private String lastName;
    
    @Column("phone_number")
    private String phoneNumber;

    // IMPORTANT : On ajoute une colonne pour savoir à quelle organisation cet utilisateur est lié.
    @Column("organisation_id")
    private UUID organisationId;
}// END OF FILE: src/main/java/com/freelance/driver_backend/model/mock/MockUser.java

//---> PATH: /home/mbogneng-junior/freelance-driver_Sylladb/backend/src/main/java/com/freelance/driver_backend/model/OtpVerification.java

package com.freelance.driver_backend.model;

import lombok.Data;
import org.springframework.data.cassandra.core.mapping.PrimaryKey;
import org.springframework.data.cassandra.core.mapping.Table;

import java.time.Instant;

@Table("otp_verifications")
@Data
public class OtpVerification {
    @PrimaryKey // L'email de l'utilisateur est la clé unique
    private String email;
    
    private String otpCode;
    
    private Instant expiresAt;
}// END OF FILE: src/main/java/com/freelance/driver_backend/model/OtpVerification.java

//---> PATH: /home/mbogneng-junior/freelance-driver_Sylladb/backend/src/main/java/com/freelance/driver_backend/model/Product.java

// src/main/java/com/freelance/driver_backend/model/Product.java

package com.freelance.driver_backend.model;

import lombok.Data;
import org.springframework.data.cassandra.core.mapping.Column;
import org.springframework.data.cassandra.core.mapping.Indexed;
import org.springframework.data.cassandra.core.mapping.PrimaryKey;
import org.springframework.data.cassandra.core.mapping.Table;
import java.math.BigDecimal;
import java.util.Map;
import java.util.UUID;

import org.springframework.data.annotation.Transient;

@Table("products")
@Data
public class Product {
    @PrimaryKey
    private ProductKey key;

    // --- Champs Communs ---
    private String name; // Utilisé pour le titre de l'annonce/planning, le modèle du véhicule, le titre de l'adresse...
    
    @Column("short_description")
    private String shortDescription; // Utilisé pour les bagages, la description du véhicule, le code postal...
    
    @Indexed
    @Column("category_id")
    private UUID categoryId; // L'identifiant qui distingue un véhicule d'une annonce, etc.
    
    @Column("is_active")
    private Boolean isActive;

    @Column("status")
    private String status; // Draft, Published, Confirmed, Terminated, METADATA, etc.
    
    @Column("default_sell_price")
    private BigDecimal defaultSellPrice; // Coût de la course, etc.

    // --- Champs Spécifiques au Trajet (Annonces & Plannings) ---
    @Column("pickup_location")
    private String pickupLocation;
    
    @Column("dropoff_location")
    private String dropoffLocation;
    
    @Column("start_date")
    private String startDate;
    
    @Column("start_time")
    private String startTime;

    @Column("end_date")
    private String endDate;

    @Column("end_time")
    private String endTime;

    @Column("baggage_info")
    private String baggageInfo;
    
    @Column("is_negotiable")
    private Boolean isNegotiable;
    
    @Column("payment_method")
    private String paymentMethod;
    
    // --- Info sur l'Auteur (client ou conducteur) ---
    @Indexed
    @Column("client_id")
    private UUID clientId; // L'ID de l'utilisateur qui a créé ce "produit"
    
    @Column("client_name")
    private String clientName;

    @Column("client_phone_number")
    private String clientPhoneNumber;

    @Column("client_profile_image_url")
    private String clientProfileImageUrl; // Utilisé pour l'avatar de l'auteur, ou la photo principale du véhicule

    // --- Info sur la Réservation ---
    @Indexed
    @Column("reserved_by_driver_id")
    private UUID reservedByDriverId; // ID du chauffeur (pour une annonce) ou du client (pour un planning)

    @Column("reserved_by_driver_name")
    private String reservedByDriverName;

    // --- Stockage flexible pour les champs non-standards ---
    @Column("metadata") 
    private Map<String, String> metadata; // Pour les détails du véhicule, les options de paiement du planning, etc.

    // --- Champs Transitoires pour l'enrichissement ---
    @Transient
    private UUID authorId;
    @Transient
    private String authorName;
    @Transient
    private String authorPhoneNumber;
    @Transient
    private String authorProfileImageUrl;


    // --- Méthodes d'accès pratiques ---
    public UUID getId() { return this.key != null ? this.key.getId() : null; }
    public UUID getOrganizationId() { return this.key != null ? this.key.getOrganizationId() : null; }
}// END OF FILE: src/main/java/com/freelance/driver_backend/model/Product.java

//---> PATH: /home/mbogneng-junior/freelance-driver_Sylladb/backend/src/main/java/com/freelance/driver_backend/model/ProductKey.java

package com.freelance.driver_backend.model;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;
import org.springframework.data.cassandra.core.cql.PrimaryKeyType;
import org.springframework.data.cassandra.core.mapping.PrimaryKeyClass;
import org.springframework.data.cassandra.core.mapping.PrimaryKeyColumn;
import java.io.Serializable;
import java.util.UUID;

@PrimaryKeyClass
@Data
@AllArgsConstructor
@NoArgsConstructor
public class ProductKey implements Serializable {
    @PrimaryKeyColumn(name = "organization_id", ordinal = 0, type = PrimaryKeyType.PARTITIONED)
    private UUID organizationId;

    @PrimaryKeyColumn(name = "id", ordinal = 1, type = PrimaryKeyType.CLUSTERED)
    private UUID id;
}// END OF FILE: src/main/java/com/freelance/driver_backend/model/ProductKey.java

//---> PATH: /home/mbogneng-junior/freelance-driver_Sylladb/backend/src/main/java/com/freelance/driver_backend/model/PushTemplate.java

package com.freelance.driver_backend.model;

import lombok.Data;
import org.springframework.data.cassandra.core.mapping.*;
import java.util.UUID;

@Table("push_templates")
@Data
public class PushTemplate {
    @PrimaryKey
    private UUID id;
    @Column("organization_id")
    private UUID organizationId;
    @Column("setting_id")
    private UUID settingId; // Lien vers FirebaseSetting
    private String title;   // Ex: "Nouvelle course disponible !"
    private String body;    // Ex: "Acceptez la course de {{clientName}} pour {{destination}}."
}// END OF FILE: src/main/java/com/freelance/driver_backend/model/PushTemplate.java

//---> PATH: /home/mbogneng-junior/freelance-driver_Sylladb/backend/src/main/java/com/freelance/driver_backend/model/Resource.java


package com.freelance.driver_backend.model;

import com.fasterxml.jackson.annotation.JsonAlias;
import com.fasterxml.jackson.annotation.JsonProperty;
import lombok.Data;
import org.springframework.data.cassandra.core.mapping.Column;
import org.springframework.data.cassandra.core.mapping.PrimaryKey;
import org.springframework.data.cassandra.core.mapping.Table;

import java.math.BigDecimal;
import org.springframework.data.annotation.Transient;
import java.time.Instant;
import java.util.Map; // Ajout de l'import
import java.util.UUID;

@Table("resources")
@Data
public class Resource {

@PrimaryKey
private ResourceKey key;

private String name;

// =====================================================================
//                         CORRECTION PRINCIPALE
// =====================================================================
// @JsonProperty est pour la SORTIE (Java -> JSON)
// @JsonAlias est pour l'ENTRÉE (JSON -> Java). Il permet plusieurs noms pour un même champ.

@Column("short_description")
@JsonProperty("short_description")
@JsonAlias("baggageInfo") // Accepte "baggageInfo" en entrée
private String shortDescription;

@Column("long_description")
@JsonProperty("long_description")
@JsonAlias("dropoffLocation") // Accepte "dropoffLocation" en entrée
private String longDescription;

@Column("storage_condition")
@JsonProperty("storage_condition")
@JsonAlias("pickupLocation") // Accepte "pickupLocation" en entrée
private String storageCondition;

@Column("base_price")
@JsonProperty("base_price")
@JsonAlias("cost") // Accepte "cost" en entrée
private BigDecimal basePrice;

@Column("sku_code")
@JsonProperty("sku_code")
@JsonAlias("paymentMethod") // Accepte "paymentMethod" en entrée
private String skuCode;

@Column("expires_at")
@JsonProperty("expires_at")
@JsonAlias("expiresAt") // Accepte "expiresAt" en entrée
private Instant expiresAt;

// --- Champs restants ---
private String state;

@Column("product_type")
@JsonProperty("product_type")
private String productType;

private String accessibility;

@Column("iot_number")
@JsonProperty("iot_number")
private String iotNumber;

@Column("available_quantity")
@JsonProperty("available_quantity")
private Integer availableQuantity;

@Column("is_tangible")
@JsonProperty("is_tangible")
private boolean isTangible;

@Column("created_at")
@JsonProperty("created_at")
private Instant createdAt;

@Column("updated_at")
@JsonProperty("updated_at")
private Instant updatedAt;

@Transient 
private Map<String, String> metadata;   


// Méthodes utilitaires (inchangées)
public UUID getResourceId() { return this.key != null ? this.key.getResourceId() : null; }
public UUID getOrganizationId() { return this.key != null ? this.key.getOrganizationId() : null; }
public String getCategoryId() { return this.key != null ? this.key.getCategoryId() : null; }
public void setResourceId(UUID id) { if(this.key == null) this.key = new ResourceKey(); this.key.setResourceId(id); }
public void setOrganizationId(UUID id) { if(this.key == null) this.key = new ResourceKey(); this.key.setOrganizationId(id); }
public void setCategoryId(String id) { if(this.key == null) this.key = new ResourceKey(); this.key.setCategoryId(id); }
}// END OF FILE: src/main/java/com/freelance/driver_backend/model/Resource.java

//---> PATH: /home/mbogneng-junior/freelance-driver_Sylladb/backend/src/main/java/com/freelance/driver_backend/model/ResourceKey.java

package com.freelance.driver_backend.model;

import lombok.Data;
import org.springframework.data.cassandra.core.cql.Ordering;
import org.springframework.data.cassandra.core.cql.PrimaryKeyType;
import org.springframework.data.cassandra.core.mapping.PrimaryKeyClass;
import org.springframework.data.cassandra.core.mapping.PrimaryKeyColumn;

import java.io.Serializable;
import java.util.UUID;

@PrimaryKeyClass
@Data
public class ResourceKey implements Serializable {

    @PrimaryKeyColumn(name = "organization_id", ordinal = 0, type = PrimaryKeyType.PARTITIONED)
    private UUID organizationId;

    @PrimaryKeyColumn(name = "category_id", ordinal = 1, type = PrimaryKeyType.CLUSTERED)
    private String categoryId;

    @PrimaryKeyColumn(name = "resource_id", ordinal = 2, type = PrimaryKeyType.CLUSTERED, ordering = Ordering.DESCENDING)
    private UUID resourceId;
}// END OF FILE: src/main/java/com/freelance/driver_backend/model/ResourceKey.java

//---> PATH: /home/mbogneng-junior/freelance-driver_Sylladb/backend/src/main/java/com/freelance/driver_backend/model/Review.java

package com.freelance.driver_backend.model;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;
import org.springframework.data.cassandra.core.mapping.PrimaryKey;
import org.springframework.data.cassandra.core.mapping.Table;
import java.util.UUID;

@Table("reviews")
@Data
@NoArgsConstructor
@AllArgsConstructor
public class Review {

    @PrimaryKey
    private UUID id;

    private UUID targetUserId; // L'utilisateur qui est noté
    private UUID authorId;     // L'utilisateur qui a écrit la note
    private String authorFirstName;
    private String authorLastName;
    private String authorProfileImageUrl;
    private int score;
    private String comment;
    private long createdAt;
}
// END OF FILE: src/main/java/com/freelance/driver_backend/model/Review.java

//---> PATH: /home/mbogneng-junior/freelance-driver_Sylladb/backend/src/main/java/com/freelance/driver_backend/model/SmtpSetting.java

package com.freelance.driver_backend.model;

import com.fasterxml.jackson.annotation.JsonProperty; // <-- AJOUTER CET IMPORT
import lombok.Data;
import org.springframework.data.cassandra.core.mapping.Column;
import org.springframework.data.cassandra.core.mapping.PrimaryKey;
import org.springframework.data.cassandra.core.mapping.Table;
import java.util.UUID;

@Table("smtp_settings")
@Data
public class SmtpSetting {
    @PrimaryKey
    private UUID id;
    
    @Column("organization_id")
    @JsonProperty("organization_id") // Pour la sortie JSON
    private UUID organizationId;
    
    private String host;
    private int port;
    private String encryption;
    private String username;
    private String password;
    
    @Column("sender_email")
    @JsonProperty("sender_email") // <-- CORRECTION ICI
    private String senderEmail;
    
    @Column("sender_name")
    @JsonProperty("sender_name") // <-- CORRECTION ICI
    private String senderName;
}// END OF FILE: src/main/java/com/freelance/driver_backend/model/SmtpSetting.java

//---> PATH: /home/mbogneng-junior/freelance-driver_Sylladb/backend/src/main/java/com/freelance/driver_backend/repository/ClientProfileRepository.java

package com.freelance.driver_backend.repository;

import com.freelance.driver_backend.model.ClientProfile;


import reactor.core.publisher.Mono;

import org.springframework.data.cassandra.repository.ReactiveCassandraRepository;
import org.springframework.stereotype.Repository;
import java.util.UUID;

@Repository
public interface ClientProfileRepository extends ReactiveCassandraRepository<ClientProfile, UUID> {

    // AJOUT DE CETTE MÉTHODE
    // Spring Data comprendra automatiquement qu'il faut chercher sur la colonne "user_id"
    Mono<ClientProfile> findByUserId(UUID userId);
}
// END OF FILE: src/main/java/com/freelance/driver_backend/repository/ClientProfileRepository.java

//---> PATH: /home/mbogneng-junior/freelance-driver_Sylladb/backend/src/main/java/com/freelance/driver_backend/repository/DesignTemplateRepository.java

package com.freelance.driver_backend.repository;

import com.freelance.driver_backend.model.DesignTemplate;
import org.springframework.data.cassandra.repository.ReactiveCassandraRepository;
import java.util.UUID;

public interface DesignTemplateRepository extends ReactiveCassandraRepository<DesignTemplate, UUID> {}// END OF FILE: src/main/java/com/freelance/driver_backend/repository/DesignTemplateRepository.java

//---> PATH: /home/mbogneng-junior/freelance-driver_Sylladb/backend/src/main/java/com/freelance/driver_backend/repository/DeviceTokenRepository.java

package com.freelance.driver_backend.repository;

import com.freelance.driver_backend.model.DeviceToken;
import org.springframework.data.cassandra.repository.ReactiveCassandraRepository;
import org.springframework.stereotype.Repository;
import reactor.core.publisher.Flux;
import java.util.UUID;

@Repository
public interface DeviceTokenRepository extends ReactiveCassandraRepository<DeviceToken, UUID> {
    Flux<DeviceToken> findByUserId(UUID userId);
}// END OF FILE: src/main/java/com/freelance/driver_backend/repository/DeviceTokenRepository.java

//---> PATH: /home/mbogneng-junior/freelance-driver_Sylladb/backend/src/main/java/com/freelance/driver_backend/repository/DriverProfileRepository.java

package com.freelance.driver_backend.repository;

import com.freelance.driver_backend.model.DriverProfile;

import reactor.core.publisher.Mono;

import org.springframework.data.cassandra.repository.ReactiveCassandraRepository;
import org.springframework.stereotype.Repository;
import java.util.UUID;

@Repository
public interface DriverProfileRepository extends ReactiveCassandraRepository<DriverProfile, UUID> {


    // AJOUT DE CETTE MÉTHODE
    // Spring Data comprendra automatiquement qu'il faut chercher sur la colonne "user_id"
    Mono<DriverProfile> findByUserId(UUID userId);
}// END OF FILE: src/main/java/com/freelance/driver_backend/repository/DriverProfileRepository.java

//---> PATH: /home/mbogneng-junior/freelance-driver_Sylladb/backend/src/main/java/com/freelance/driver_backend/repository/EmailTemplateRepository.java

package com.freelance.driver_backend.repository;

import com.freelance.driver_backend.model.EmailTemplate;
import org.springframework.data.cassandra.repository.ReactiveCassandraRepository;
import java.util.UUID;

public interface EmailTemplateRepository extends ReactiveCassandraRepository<EmailTemplate, UUID> {}// END OF FILE: src/main/java/com/freelance/driver_backend/repository/EmailTemplateRepository.java

//---> PATH: /home/mbogneng-junior/freelance-driver_Sylladb/backend/src/main/java/com/freelance/driver_backend/repository/FirebaseSettingRepository.java

package com.freelance.driver_backend.repository;

import com.freelance.driver_backend.model.FirebaseSetting;
import org.springframework.data.cassandra.repository.ReactiveCassandraRepository;
import java.util.UUID;

public interface FirebaseSettingRepository extends ReactiveCassandraRepository<FirebaseSetting, UUID> {}// END OF FILE: src/main/java/com/freelance/driver_backend/repository/FirebaseSettingRepository.java

//---> PATH: /home/mbogneng-junior/freelance-driver_Sylladb/backend/src/main/java/com/freelance/driver_backend/repository/mock/MockOrganisationRepository.java

package com.freelance.driver_backend.repository.mock;

import com.freelance.driver_backend.model.mock.MockOrganisation;
import org.springframework.data.cassandra.repository.ReactiveCassandraRepository;
import reactor.core.publisher.Flux;
import java.util.UUID;

public interface MockOrganisationRepository extends ReactiveCassandraRepository<MockOrganisation, UUID> {
    Flux<MockOrganisation> findByOwnerUserId(UUID ownerUserId);
}// END OF FILE: src/main/java/com/freelance/driver_backend/repository/mock/MockOrganisationRepository.java

//---> PATH: /home/mbogneng-junior/freelance-driver_Sylladb/backend/src/main/java/com/freelance/driver_backend/repository/mock/MockUserCassandraRepository.java

package com.freelance.driver_backend.repository.mock;

import com.freelance.driver_backend.model.mock.MockUser;
import org.springframework.data.cassandra.repository.AllowFiltering;
import org.springframework.data.cassandra.repository.ReactiveCassandraRepository;
import org.springframework.stereotype.Repository;
import reactor.core.publisher.Mono;

import java.util.UUID;

@Repository
public interface MockUserCassandraRepository extends ReactiveCassandraRepository<MockUser, UUID> {
    
    @AllowFiltering
    Mono<MockUser> findByEmail(String email);
    
    @AllowFiltering
    Mono<MockUser> findByUsername(String username);
}// END OF FILE: src/main/java/com/freelance/driver_backend/repository/mock/MockUserCassandraRepository.java

//---> PATH: /home/mbogneng-junior/freelance-driver_Sylladb/backend/src/main/java/com/freelance/driver_backend/repository/mock/MockUserRepository.java

package com.freelance.driver_backend.repository.mock;

import com.freelance.driver_backend.model.mock.MockUser;
import org.springframework.data.cassandra.repository.AllowFiltering;
import org.springframework.data.cassandra.repository.ReactiveCassandraRepository;
import org.springframework.stereotype.Repository;
import reactor.core.publisher.Mono;

import java.util.UUID;

@Repository
public interface MockUserRepository extends ReactiveCassandraRepository<MockUser, UUID> {
    
    @AllowFiltering
    Mono<MockUser> findByEmail(String email);
    
    @AllowFiltering
    Mono<MockUser> findByUsername(String username);
}// END OF FILE: src/main/java/com/freelance/driver_backend/repository/mock/MockUserRepository.java

//---> PATH: /home/mbogneng-junior/freelance-driver_Sylladb/backend/src/main/java/com/freelance/driver_backend/repository/OtpVerificationRepository.java

package com.freelance.driver_backend.repository;

import com.freelance.driver_backend.model.OtpVerification;
import org.springframework.data.cassandra.repository.ReactiveCassandraRepository;
import org.springframework.stereotype.Repository;

@Repository
public interface OtpVerificationRepository extends ReactiveCassandraRepository<OtpVerification, String> {
    // Spring Data se charge de tout, cette interface peut rester vide.
}// END OF FILE: src/main/java/com/freelance/driver_backend/repository/OtpVerificationRepository.java

//---> PATH: /home/mbogneng-junior/freelance-driver_Sylladb/backend/src/main/java/com/freelance/driver_backend/repository/ProductRepository.java

package com.freelance.driver_backend.repository;

import com.freelance.driver_backend.model.Product;
import com.freelance.driver_backend.model.ProductKey;
import org.springframework.data.cassandra.repository.Query;
import org.springframework.data.cassandra.repository.ReactiveCassandraRepository;
import reactor.core.publisher.Flux;
import java.util.UUID;

public interface ProductRepository extends ReactiveCassandraRepository<Product, ProductKey> {

    Flux<Product> findByKeyOrganizationIdAndCategoryId(UUID organizationId, UUID categoryId);

    @Query("SELECT * FROM products WHERE category_id = ?0 ALLOW FILTERING")
    Flux<Product> findByCategoryId(UUID categoryId);
    
    Flux<Product> findByKeyOrganizationId(UUID organizationId);

    @Query("SELECT * FROM products WHERE client_id = ?0 AND category_id = ?1 ALLOW FILTERING")
    Flux<Product> findByClientIdAndCategoryId(UUID clientId, UUID categoryId);
    
    @Query("SELECT * FROM products WHERE reserved_by_driver_id = ?0 ALLOW FILTERING")
    Flux<Product> findByReservedByDriverId(UUID driverId);
}// END OF FILE: src/main/java/com/freelance/driver_backend/repository/ProductRepository.java

//---> PATH: /home/mbogneng-junior/freelance-driver_Sylladb/backend/src/main/java/com/freelance/driver_backend/repository/PushTemplateRepository.java

package com.freelance.driver_backend.repository;

import com.freelance.driver_backend.model.PushTemplate;
import org.springframework.data.cassandra.repository.ReactiveCassandraRepository;
import java.util.UUID;

public interface PushTemplateRepository extends ReactiveCassandraRepository<PushTemplate, UUID> {}// END OF FILE: src/main/java/com/freelance/driver_backend/repository/PushTemplateRepository.java

//---> PATH: /home/mbogneng-junior/freelance-driver_Sylladb/backend/src/main/java/com/freelance/driver_backend/repository/ResourceRepository.java

package com.freelance.driver_backend.repository;

import com.freelance.driver_backend.model.Resource;
import com.freelance.driver_backend.model.ResourceKey; // <-- Import de la nouvelle clé
import org.springframework.data.cassandra.repository.Query;
import org.springframework.data.cassandra.repository.ReactiveCassandraRepository;
import org.springframework.stereotype.Repository;
import reactor.core.publisher.Flux;
import java.util.UUID;

@Repository
// Le deuxième paramètre générique est maintenant ResourceKey
public interface ResourceRepository extends ReactiveCassandraRepository<Resource, ResourceKey> { 
    
    // Cette méthode est maintenant beaucoup plus efficace !
    Flux<Resource> findByKeyOrganizationIdAndKeyCategoryId(UUID organizationId, String categoryId);
    
    // On doit ajouter ALLOW FILTERING car category_id n'est pas la clé de partition
    @Query("SELECT * FROM resources WHERE category_id = ?0 ALLOW FILTERING")
    Flux<Resource> findByKeyCategoryId(String categoryId);
}// END OF FILE: src/main/java/com/freelance/driver_backend/repository/ResourceRepository.java

//---> PATH: /home/mbogneng-junior/freelance-driver_Sylladb/backend/src/main/java/com/freelance/driver_backend/repository/ReviewRepository.java

package com.freelance.driver_backend.repository;

import com.freelance.driver_backend.model.Review;
import org.springframework.data.cassandra.repository.AllowFiltering;
import org.springframework.data.cassandra.repository.ReactiveCassandraRepository;
import reactor.core.publisher.Flux;
import java.util.UUID;

public interface ReviewRepository extends ReactiveCassandraRepository<Review, UUID> {
    @AllowFiltering
    Flux<Review> findByTargetUserId(UUID targetUserId);
}
// END OF FILE: src/main/java/com/freelance/driver_backend/repository/ReviewRepository.java

//---> PATH: /home/mbogneng-junior/freelance-driver_Sylladb/backend/src/main/java/com/freelance/driver_backend/repository/SmtpSettingRepository.java

package com.freelance.driver_backend.repository;

import com.freelance.driver_backend.model.SmtpSetting;
import org.springframework.data.cassandra.repository.ReactiveCassandraRepository;
import java.util.UUID;

public interface SmtpSettingRepository extends ReactiveCassandraRepository<SmtpSetting, UUID> {}// END OF FILE: src/main/java/com/freelance/driver_backend/repository/SmtpSettingRepository.java

//---> PATH: /home/mbogneng-junior/freelance-driver_Sylladb/backend/src/main/java/com/freelance/driver_backend/service/external/AuthService.java

package com.freelance.driver_backend.service.external;

import com.freelance.driver_backend.dto.external.*;
import reactor.core.publisher.Mono;

/**
 * Interface définissant le contrat pour les interactions avec le service d'authentification externe.
 * Cela permet de découpler la logique métier des implémentations concrètes (API réelle vs Mock local).
 */
public interface AuthService {

    /**
     * Obtient un token de type Machine-to-Machine (M2M) en utilisant les client credentials.
     * @param clientId L'ID du client OAuth2.
     * @param clientSecret Le secret du client OAuth2.
     * @return Un Mono contenant la réponse avec le token.
     */
    Mono<OAuthTokenResponse> getClientCredentialsToken(String clientId, String clientSecret);

    /**
     * Enregistre un nouvel utilisateur auprès du service d'authentification.
     * @param request Les données d'inscription de l'utilisateur.
     * @param m2mBearerToken Le token M2M nécessaire pour autoriser cette opération.
     * @return Un Mono contenant les informations de l'utilisateur créé.
     */
   

     Mono<UserDto> registerUser(RegistrationRequest request, String m2mBearerToken);

    /**
     * Connecte un utilisateur pour obtenir un token d'accès personnel.
     * @param request Les identifiants de l'utilisateur.
     * @param m2mBearerToken Le token M2M nécessaire pour autoriser cette opération.
     * @return Un Mono contenant la réponse de connexion complète (token, infos utilisateur, etc.).
     */
     Mono<LoginResponse> loginUser(LoginRequest request, String m2mBearerToken);



    
}// END OF FILE: src/main/java/com/freelance/driver_backend/service/external/AuthService.java

//---> PATH: /home/mbogneng-junior/freelance-driver_Sylladb/backend/src/main/java/com/freelance/driver_backend/service/external/AuthServiceWebClientImpl.java

package com.freelance.driver_backend.service.external;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.DeserializationFeature;
import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.freelance.driver_backend.dto.external.*;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.context.annotation.Profile;
import org.springframework.http.HttpStatusCode;
import org.springframework.http.MediaType;
import org.springframework.stereotype.Component;
import org.springframework.util.LinkedMultiValueMap;
import org.springframework.util.MultiValueMap;
import org.springframework.web.reactive.function.BodyInserters;
import org.springframework.web.reactive.function.client.WebClient;
import reactor.core.publisher.Mono;

@Component
@Slf4j
public class AuthServiceWebClientImpl implements AuthService {

    private final WebClient webClient;
    private final WebClient mockWebClient;

    // Le Qualifier pointe toujours vers le Bean défini dans WebClientConfig
    public AuthServiceWebClientImpl(@Qualifier("authServiceWebClient") WebClient webClient,@Qualifier("mockWebClient") WebClient mockWebClient) {
        this.webClient = webClient;
        this.mockWebClient = mockWebClient;
    }

    @Override
    public Mono<OAuthTokenResponse> getClientCredentialsToken(String clientId, String clientSecret) {
        log.info("Requesting M2M token with client_id: {}", clientId);

        MultiValueMap<String, String> formData = new LinkedMultiValueMap<>();
        formData.add("grant_type", "client_credentials");
        formData.add("client_id", clientId);
        formData.add("client_secret", clientSecret);
        formData.add("scope", "read write manage_api");

        return webClient.post()
                .uri("/oauth/token")
                .contentType(MediaType.APPLICATION_FORM_URLENCODED)
                .body(BodyInserters.fromFormData(formData))
                .retrieve()
                .onStatus(HttpStatusCode::isError, response ->
                        response.bodyToMono(String.class)
                                .flatMap(errorBody -> {
                                    log.error("Error obtaining client credentials token: {} - {}", response.statusCode(), errorBody);
                                    return Mono.error(new RuntimeException("Could not obtain M2M token: " + errorBody));
                                })
                )
                .bodyToMono(OAuthTokenResponse.class);
    }


    //On desactive m2m bearer token pour l'instant
    // public Mono<UserDto> registerUser(RegistrationRequest  request,String m2mBearerToken) {
    public Mono<UserDto> registerUser(RegistrationRequest  request, String m2mBearerToken) {
        log.info("Étape 1: Sending mock registration request for {}", request.getEmail());
        
        return mockWebClient.post()
                .uri("/api/mock_user/register")
                .bodyValue(request)
                .retrieve()
                .onStatus(HttpStatusCode::isError, response ->
                        response.bodyToMono(String.class)
                                .flatMap(errorBody -> {
                                    log.error("Error during mock user registration for {}: {} - {}", 
                                            request.getEmail(), response.statusCode(), errorBody);

                                    String clientErrorMessage = "Mock registration failed with status " + response.statusCode();
                                    
                                    // Log la réponse brute pour le débogage
                                    clientErrorMessage += ": Mock service responded with: " + 
                                            (errorBody != null && !errorBody.isEmpty() ? errorBody : "[Empty or Null Body]");

                                    try {
                                        ObjectMapper mapper = new ObjectMapper();
                                        mapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);
                                        JsonNode root = mapper.readTree(errorBody);

                                        // Extraction de messages d'erreur spécifiques
                                        if (root.has("message") && root.get("message").isTextual()) {
                                            clientErrorMessage = root.get("message").asText();
                                        } else if (root.has("error") && root.get("error").isTextual()) {
                                            clientErrorMessage = root.get("error").asText();
                                        }
                                        
                                        if (root.has("errors") && root.get("errors").isObject()) {
                                            clientErrorMessage += " (Details: " + root.get("errors").toString() + ")";
                                        }
                                        
                                    } catch (JsonProcessingException e) {
                                        log.warn("Could not parse errorBody from mock service as JSON: {}", errorBody, e);
                                    } catch (Exception e) {
                                        log.error("Unexpected error while processing errorBody from mock service: {}", errorBody, e);
                                    }
    
                                    return Mono.error(new RuntimeException(clientErrorMessage));
                                })
                )
                .bodyToMono(UserDto.class);
    }
    
    //On desactive m2m bearer token pour l'instant
    // public Mono<LoginResponse> loginUser(LoginRequest request, String m2mBearerToken) {
    public Mono<LoginResponse> loginUser(LoginRequest request, String m2mBearerToken) {
        log.info("Étape 2: Sending mock login request for {}", request.getUsername());
        
        return mockWebClient.post()
                .uri("/api/mock_user/login")
                .bodyValue(request)
                .retrieve()
                .onStatus(HttpStatusCode::isError, response ->
                        response.bodyToMono(String.class)
                                .flatMap(errorBody -> {
                                    log.error("HTTP Error during mock login for user {}: {} - {}", 
                                            request.getUsername(), response.statusCode(), errorBody);
                                    return Mono.error(new RuntimeException("Mock login failed with HTTP status: " + response.statusCode()));
                                })
                )
                .bodyToMono(String.class)
                .flatMap(rawBody -> {
                    log.info("Raw JSON response from mock /api/mock_user/login for user {}: {}", 
                            request.getUsername(), rawBody);
                    
                    try {
                        ObjectMapper objectMapper = new ObjectMapper();
                        objectMapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);

                        JsonNode rootNode = objectMapper.readTree(rawBody);
                        
                        // Vérifier si l'API mock renvoie un statut FAILED
                        if (rootNode.has("status") && "FAILED".equals(rootNode.get("status").asText())) {
                            String errorMessage = rootNode.get("message").asText("Invalid Credentials");
                            log.warn("Mock login failed for user '{}': {}", request.getUsername(), errorMessage);
                            return Mono.empty(); // Retourner un Mono vide pour signaler l'échec
                        }

                        // Si succès, parser la réponse complète
                        LoginResponse loginResponse = objectMapper.readValue(rawBody, LoginResponse.class);
                        return Mono.just(loginResponse);

                    } catch (JsonProcessingException e) {
                        log.error("Failed to parse mock login response JSON", e);
                        return Mono.error(new RuntimeException("Failed to parse mock login response JSON", e));
                    }
                });
    }
    
    /* 
    @Override
    public Mono<UserDto> registerUser(RegistrationRequest request, String m2mBearerToken) {
        log.info("Étape 1: Sending registration request for {}", request.getEmail());
        return webClient.post()
                .uri("/api/register")
                .header("Authorization", m2mBearerToken)
                .bodyValue(request)
                .retrieve()
                .onStatus(HttpStatusCode::isError, response ->
                        response.bodyToMono(String.class)
                                .flatMap(errorBody -> {
                                    log.error("Error during user registration for {}: {} - {}", request.getEmail(), response.statusCode(), errorBody);

                                    String clientErrorMessage = "Registration failed with status " + response.statusCode();
                                    
                                    // AJOUT ICI : Log la réponse brute pour le débogage côté frontend
                                    clientErrorMessage += ": External service responded with: " + (errorBody != null && !errorBody.isEmpty() ? errorBody : "[Empty or Null Body]");

                                    try {
                                        ObjectMapper mapper = new ObjectMapper();
                                        mapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false); // Ignorer les champs inconnus
                                        JsonNode root = mapper.readTree(errorBody);

                                        // Tentative d'extraction de messages d'erreur plus spécifiques
                                        if (root.has("message") && root.get("message").isTextual()) {
                                            clientErrorMessage = root.get("message").asText();
                                        } else if (root.has("error") && root.get("error").isTextual()) {
                                            clientErrorMessage = root.get("error").asText();
                                        }
                                        
                                        if (root.has("errors") && root.get("errors").isObject()) {
                                            // Ajoute les détails des erreurs de validation si présents
                                            clientErrorMessage += " (Details: " + root.get("errors").toString() + ")";
                                        }
                                        
                                    } catch (JsonProcessingException e) {
                                        log.warn("Could not parse errorBody from external auth service as JSON: {}", errorBody, e);
                                        // Le clientErrorMessage inclut déjà le corps brut, donc pas besoin de l'ajouter ici
                                    } catch (Exception e) {
                                        log.error("Unexpected error while processing errorBody from external auth service: {}", errorBody, e);
                                        // Le clientErrorMessage inclut déjà le corps brut
                                    }
    
                                    return Mono.error(new RuntimeException(clientErrorMessage));
                                })
                )
                .bodyToMono(UserDto.class);
    }

    @Override
    public Mono<LoginResponse> loginUser(LoginRequest request, String m2mBearerToken) {
        log.info("Étape 2: Sending login request for {}", request.getUsername());
        return webClient.post()
                .uri("/api/login")
                .header("Authorization", m2mBearerToken)
                .bodyValue(request)
                .retrieve()
                .onStatus(HttpStatusCode::isError, response ->
                        response.bodyToMono(String.class)
                                .flatMap(errorBody -> {
                                    log.error("HTTP Error during login for user {}: {} - {}", request.getUsername(), response.statusCode(), errorBody);
                                    return Mono.error(new RuntimeException("Login failed with HTTP status: " + response.statusCode()));
                                })
                )
                .bodyToMono(String.class)
                .flatMap(rawBody -> {
                    log.info("Raw JSON response from /api/login for user {}: {}", request.getUsername(), rawBody);
                    try {
                        ObjectMapper objectMapper = new ObjectMapper();
                        objectMapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);

                        JsonNode rootNode = objectMapper.readTree(rawBody);
                        
                        // --- DÉBUT DE LA CORRECTION ---
                        // Si l'API renvoie un statut FAILED (identifiants invalides)
                        if (rootNode.has("status") && "FAILED".equals(rootNode.get("status").asText())) {
                            String errorMessage = rootNode.get("message").asText("Invalid Credentials");
                            log.warn("Login failed for user '{}': {}", request.getUsername(), errorMessage);
                            // On retourne un Mono vide pour signaler l'échec sans crasher l'application
                            return Mono.empty(); 
                        }
                        // --- FIN DE LA CORRECTION ---

                        // Si le statut est un succès, on parse la réponse complète
                        LoginResponse loginResponse = objectMapper.readValue(rawBody, LoginResponse.class);
                        return Mono.just(loginResponse);

                    } catch (JsonProcessingException e) {
                        log.error("Failed to parse login response JSON", e);
                        return Mono.error(new RuntimeException("Failed to parse login response JSON", e));
                    }
                });
    } */
}// END OF FILE: src/main/java/com/freelance/driver_backend/service/external/AuthServiceWebClientImpl.java

//---> PATH: /home/mbogneng-junior/freelance-driver_Sylladb/backend/src/main/java/com/freelance/driver_backend/service/external/ChatService.java

package com.freelance.driver_backend.service.external;

import com.freelance.driver_backend.dto.external.ChatUserCreationPayload;
import com.freelance.driver_backend.dto.external.ChatUserLoginPayload;
import com.freelance.driver_backend.dto.external.ChatUserLoginResponse;
import reactor.core.publisher.Mono;

public interface ChatService {
    Mono<ChatUserLoginResponse> registerAndLoginChatUser(ChatUserCreationPayload payload);
    Mono<ChatUserLoginResponse> loginChatUser(ChatUserLoginPayload payload);
}// END OF FILE: src/main/java/com/freelance/driver_backend/service/external/ChatService.java

//---> PATH: /home/mbogneng-junior/freelance-driver_Sylladb/backend/src/main/java/com/freelance/driver_backend/service/external/ChatServiceWebClientImpl.java

package com.freelance.driver_backend.service.external;

import com.freelance.driver_backend.dto.external.*;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Profile;
import org.springframework.http.HttpStatusCode;
import org.springframework.stereotype.Component;
import org.springframework.web.reactive.function.client.WebClient;
import reactor.core.publisher.Mono;

@Component

@Slf4j
public class ChatServiceWebClientImpl implements ChatService {

    private final WebClient webClient;
    private final String projectId;

    public ChatServiceWebClientImpl(@Qualifier("chatServiceWebClient") WebClient webClient,
                                  @Value("${freelancedriver.chat.project-id}") String projectId) {
        this.webClient = webClient;
        this.projectId = projectId;
    }

    private Mono<Void> createUserInChatSystem(ChatUserCreationPayload payload) {
        log.info("Chat API Call: Creating user {}", payload.getLogin());
        payload.setProjectId(this.projectId);
        return webClient.post().uri("/users/create")
                .bodyValue(payload)
                .retrieve()
                .onStatus(HttpStatusCode::isError, response -> response.bodyToMono(String.class)
                        .flatMap(error -> Mono.error(new RuntimeException("Chat user creation failed: " + error))))
                .bodyToMono(Void.class);
    }

    @Override
    public Mono<ChatUserLoginResponse> registerAndLoginChatUser(ChatUserCreationPayload payload) {
        return createUserInChatSystem(payload)
                .then(loginChatUser(new ChatUserLoginPayload(null, payload.getLogin(), payload.getSecret())));
    }

    
    @Override
    public Mono<ChatUserLoginResponse> loginChatUser(ChatUserLoginPayload payload) {
        log.info("Chat API Call: Logging in user {}", payload.getLogin());
        payload.setProjectId(this.projectId);
        return webClient.post().uri("/auth/user")
                .bodyValue(payload)
                .retrieve()
                .onStatus(HttpStatusCode::isError, response -> response.bodyToMono(String.class)
                        .flatMap(error -> Mono.error(new RuntimeException("Chat login failed: " + error))))
                .bodyToMono(ChatUserLoginResponse.class);
    }
}// END OF FILE: src/main/java/com/freelance/driver_backend/service/external/ChatServiceWebClientImpl.java

//---> PATH: /home/mbogneng-junior/freelance-driver_Sylladb/backend/src/main/java/com/freelance/driver_backend/service/external/mock/MockNotificationServiceImpl.java

package com.freelance.driver_backend.service.external.mock;

import com.freelance.driver_backend.dto.external.NotificationRequest;
import com.freelance.driver_backend.repository.DesignTemplateRepository;
import com.freelance.driver_backend.repository.EmailTemplateRepository;
import com.freelance.driver_backend.repository.PushTemplateRepository;
import com.freelance.driver_backend.repository.SmtpSettingRepository;
import com.freelance.driver_backend.service.external.NotificationService;
import com.freelance.driver_backend.service.FcmHttpClient;
import jakarta.mail.internet.MimeMessage;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.context.annotation.Profile;
import org.springframework.mail.javamail.JavaMailSender;
import org.springframework.mail.javamail.MimeMessageHelper;
import org.springframework.stereotype.Service;
import org.thymeleaf.context.Context;
import org.thymeleaf.spring6.SpringTemplateEngine;
import reactor.core.publisher.Mono;
import reactor.core.scheduler.Schedulers;

import java.nio.charset.StandardCharsets;
import java.util.List;
import java.util.Map;
import java.util.UUID;
import java.util.stream.Collectors;

import com.google.firebase.FirebaseApp;

@Service

@RequiredArgsConstructor
@Slf4j
public class MockNotificationServiceImpl implements NotificationService {

    private final EmailTemplateRepository emailTemplateRepository;
    private final DesignTemplateRepository designTemplateRepository;
    private final SmtpSettingRepository smtpSettingRepository;
    private final JavaMailSender javaMailSender;
    private final SpringTemplateEngine thymeleafTemplateEngine;
    private final PushTemplateRepository pushTemplateRepository;
    private final FirebaseApp firebaseApp; 
    private final FcmHttpClient fcmHttpClient;

    @Override
    public Mono<Boolean> sendEmailNotification(UUID organisationId, NotificationRequest request, String userBearerToken, String publicKey) {
        log.warn("==================== [LOCAL EMAIL SERVICE - REAL SEND] ====================");
        
        if (request.getRecipients() == null || request.getRecipients().isEmpty()) {
            return Mono.error(new IllegalArgumentException("Recipients list cannot be empty."));
        }

        return emailTemplateRepository.findById(request.getTemplateId())
            .flatMap(emailTemplate -> 
                Mono.zip(
                    designTemplateRepository.findById(emailTemplate.getDesignTemplateId()),
                    smtpSettingRepository.findById(emailTemplate.getSettingId())
                )
            )
            .flatMap(tuple -> {
                var designTemplate = tuple.getT1();
                var smtpSetting = tuple.getT2();
                Context thymeleafContext = new Context();
                if (request.getMetadata() != null) {
                    request.getMetadata().forEach(thymeleafContext::setVariable);
                }
                String finalSubject = thymeleafTemplateEngine.process(designTemplate.getSubject(), thymeleafContext);
                String finalHtmlBody = thymeleafTemplateEngine.process(designTemplate.getHtml(), thymeleafContext);

                return Mono.fromCallable(() -> {
                    try {
                        MimeMessage message = javaMailSender.createMimeMessage();
                        MimeMessageHelper helper = new MimeMessageHelper(message, true, StandardCharsets.UTF_8.name());
                        helper.setTo(request.getRecipients().toArray(new String[0]));
                        helper.setSubject(finalSubject);
                        helper.setText(finalHtmlBody, true);
                        helper.setFrom(smtpSetting.getSenderEmail(), smtpSetting.getSenderName());

                        javaMailSender.send(message);
                        log.warn(">>> REAL EMAIL SENT via LOCAL Service to {} <<<", request.getRecipients());
                        return true;
                    } catch (Exception e) {
                        log.error("==================== ERREUR SMTP ====================");
                        log.error("Échec de l'envoi de l'email. Cause: {}", e.getMessage());
                        log.error("Vérifiez vos identifiants dans application.properties et le mot de passe d'application Google.");
                        log.error("=====================================================");
                        throw new RuntimeException("Failed to send email", e);
                    }
                })
                .subscribeOn(Schedulers.boundedElastic())
                .onErrorReturn(false);
            })
            .defaultIfEmpty(false);
    }

    @Override
    public Mono<Boolean> sendPushNotification(UUID organisationId, NotificationRequest request, String userBearerToken, String publicKey) {
        log.warn("==================== [LOCAL PUSH SERVICE - REAL SEND VIA FCM HTTP CLIENT] ====================");
        
        if (request.getRecipients() == null || request.getRecipients().isEmpty()) {
            log.warn("[LOCAL PUSH SERVICE] Aucuns destinataires pour la notification push.");
            return Mono.just(false);
        }

        return pushTemplateRepository.findById(request.getTemplateId())
            .flatMap(pushTemplate -> {
                String finalTitle = replaceMetadata(pushTemplate.getTitle(), request.getMetadata());
                String finalBody = replaceMetadata(pushTemplate.getBody(), request.getMetadata());

                // --- MODIFICATION ICI : Appeler FcmHttpClient avec le dataPayload ---
                return fcmHttpClient.sendNotifications(request.getRecipients(), finalTitle, finalBody, request.getData()) // <-- AJOUT DE request.getData()
                           .then(Mono.just(true)) 
                           .onErrorResume(e -> { 
                               log.error("❌ Erreur lors de l'envoi de notifications push via FcmHttpClient: {}", e.getMessage());
                               return Mono.just(false);
                           });
            })
            .defaultIfEmpty(false)
            .doOnError(e -> log.error("Error during local push sending process (outside flatMap)", e))
            .onErrorReturn(false);
    }

    private String replaceMetadata(String text, Map<String, String> metadata) {
        if (text == null || metadata == null) return text;
        for (Map.Entry<String, String> entry : metadata.entrySet()) {
            text = text.replace("{{" + entry.getKey() + "}}", entry.getValue());
        }
        return text;
    }
}// END OF FILE: src/main/java/com/freelance/driver_backend/service/external/mock/MockNotificationServiceImpl.java

//---> PATH: /home/mbogneng-junior/freelance-driver_Sylladb/backend/src/main/java/com/freelance/driver_backend/service/external/mock/MockOrganisationServiceImpl.java

package com.freelance.driver_backend.service.external.mock;

import com.freelance.driver_backend.dto.external.OrganisationCreationRequest;
import com.freelance.driver_backend.dto.external.OrganisationDto;
import com.freelance.driver_backend.model.mock.MockOrganisation;
import com.freelance.driver_backend.repository.mock.MockOrganisationRepository;
import com.freelance.driver_backend.service.external.OrganisationService;
import com.freelance.driver_backend.util.JwtUtil; // Utilitaire pour décoder le token
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;

import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.context.annotation.Profile;
import org.springframework.security.oauth2.jwt.Jwt;
import org.springframework.security.oauth2.jwt.JwtDecoder;

import org.springframework.security.oauth2.jwt.JwtException;
import org.springframework.security.oauth2.jwt.ReactiveJwtDecoder;
import org.springframework.stereotype.Service;
import reactor.core.publisher.Mono;

import java.util.List;
import java.util.UUID;

@Service

@RequiredArgsConstructor
@Slf4j
public class MockOrganisationServiceImpl implements OrganisationService {

    private final MockOrganisationRepository mockOrganisationRepository;
    private final ReactiveJwtDecoder jwtDecoder; // On injecte le décodeur de JWT

    @Qualifier("localJwtDecoder")
    private final JwtDecoder localJwtDecoder;

    @Override
    public Mono<OrganisationDto> createOrganisation(OrganisationCreationRequest request, String bearerToken, String publicKey) {
        log.warn("[MOCK-ORG] Creating organisation '{}' in local DB.", request.getLongName());

        // On décode le VRAI token pour obtenir le VRAI userId
        return decodeTokenMock(bearerToken)
            .flatMap(jwt -> {
                UUID ownerId = JwtUtil.getUserIdFromToken(jwt);
                log.info("[MOCK-ORG] Extracted real userId {} from token for new organisation.", ownerId);

                MockOrganisation newOrg = new MockOrganisation();
                newOrg.setOrganizationId(UUID.randomUUID());
                newOrg.setLongName(request.getLongName());
                newOrg.setDescription(request.getDescription());
                newOrg.setOwnerUserId(ownerId); // On utilise le vrai ID !

                return mockOrganisationRepository.save(newOrg).map(this::mapToDto);
            });
    }

    @Override
    public Mono<List<OrganisationDto>> getUserOrganisations(String userBearerToken, String publicKey) {
        log.warn("[MOCK-ORG] Getting user organisations from local DB using real user token.");
        
        return decodeTokenMock(userBearerToken)
            .flatMap(jwt -> {
                UUID ownerId = JwtUtil.getUserIdFromToken(jwt);
                log.info("[MOCK-ORG] Finding organisations for real userId {}.", ownerId);
                return mockOrganisationRepository.findByOwnerUserId(ownerId)
                    .map(this::mapToDto)
                    .collectList();
            });
    }

    @Override
    public Mono<OrganisationDto> getOrganisationById(UUID organisationId, String userBearerToken, String publicKey) {
         return mockOrganisationRepository.findById(organisationId).map(this::mapToDto);
    }
    
    private OrganisationDto mapToDto(MockOrganisation org) {
        OrganisationDto dto = new OrganisationDto();
        dto.setOrganizationId(org.getOrganizationId());
        dto.setLongName(org.getLongName());
        dto.setDescription(org.getDescription());
        dto.setStatus("ACTIVE"); // Simule un statut actif
        return dto;
    }

    // Méthode utilitaire pour décoder le token JWT réel. On le decommentera plus tard

    /* 
    private Mono<Jwt> decodeToken(String bearerToken) {
        if (bearerToken == null || !bearerToken.startsWith("Bearer ")) {
            return Mono.error(new IllegalArgumentException("Invalid Authorization header format"));
        }
        String token = bearerToken.substring(7);
        return jwtDecoder.decode(token)
            .doOnError(JwtException.class, e -> log.error("Failed to decode JWT token", e));
    }*/



     // Methode utilitaire pour decoder les mocks token
    private Mono<Jwt> decodeTokenMock(String bearerToken) {
        if (bearerToken == null || !bearerToken.startsWith("Bearer ")) {
            return Mono.error(new IllegalArgumentException("Invalid Authorization header format"));
        }
        String token = bearerToken.substring(7);
        
        try {
            // Utiliser le décodeur LOCAL synchrone au lieu du réactif externe
            Jwt jwt = localJwtDecoder.decode(token);
            return Mono.just(jwt);
        } catch (JwtException e) {
            log.error("Failed to decode local JWT token", e);
            return Mono.error(e);
        }
    }
}// END OF FILE: src/main/java/com/freelance/driver_backend/service/external/mock/MockOrganisationServiceImpl.java

//---> PATH: /home/mbogneng-junior/freelance-driver_Sylladb/backend/src/main/java/com/freelance/driver_backend/service/external/NotificationService.java

package com.freelance.driver_backend.service.external;

import com.freelance.driver_backend.dto.external.NotificationRequest;
import reactor.core.publisher.Mono;
import java.util.UUID;

public interface NotificationService {

    /**
     * Envoie une notification par email en utilisant le service de notification.
     *
     * @param organisationId L'ID de l'organisation qui envoie la notification.
     * @param request        L'objet contenant les détails de la notification (template, destinataires, etc.).
     * @param userBearerToken  Le token de l'utilisateur authentifié.
     * @param publicKey      La clé publique de l'API.
     * @return Un Mono<Boolean> qui retourne true si la notification a été acceptée pour envoi.
     */
    Mono<Boolean> sendEmailNotification(UUID organisationId, NotificationRequest request, String userBearerToken, String publicKey);
    Mono<Boolean> sendPushNotification(UUID organisationId, NotificationRequest request, String userBearerToken, String publicKey);

}// END OF FILE: src/main/java/com/freelance/driver_backend/service/external/NotificationService.java

//---> PATH: /home/mbogneng-junior/freelance-driver_Sylladb/backend/src/main/java/com/freelance/driver_backend/service/external/OrganisationService.java

package com.freelance.driver_backend.service.external;

import com.freelance.driver_backend.dto.external.OrganisationCreationRequest;
import com.freelance.driver_backend.dto.external.OrganisationDto;
import reactor.core.publisher.Mono;
import java.util.List;
import java.util.UUID;

public interface OrganisationService {
    // La signature est maintenant Mono<OrganisationDto> pour refléter la réponse de l'API
    Mono<OrganisationDto> createOrganisation(OrganisationCreationRequest request, String bearerToken, String publicKey);

    Mono<List<OrganisationDto>> getUserOrganisations(String userBearerToken, String publicKey);
    Mono<OrganisationDto> getOrganisationById(UUID organisationId, String userBearerToken, String publicKey);
}// END OF FILE: src/main/java/com/freelance/driver_backend/service/external/OrganisationService.java

//---> PATH: /home/mbogneng-junior/freelance-driver_Sylladb/backend/src/main/java/com/freelance/driver_backend/service/FcmHttpClient.java

package com.freelance.driver_backend.service;

import com.google.auth.oauth2.GoogleCredentials;
import com.google.firebase.FirebaseApp;
import lombok.extern.slf4j.Slf4j;
import org.springframework.core.io.ClassPathResource;
import org.springframework.http.MediaType;
import org.springframework.stereotype.Service;
import org.springframework.web.reactive.function.client.WebClient;
import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;
import org.springframework.http.HttpStatusCode;
import java.util.HashMap;

import java.io.IOException;
import java.io.InputStream;
import java.util.Collections;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;

@Service
@Slf4j
public class FcmHttpClient {

    private final WebClient webClient;
    private final FirebaseApp firebaseApp; 
    private final String projectId;        

    public FcmHttpClient(FirebaseApp firebaseApp) { 
        this.firebaseApp = firebaseApp;
        this.projectId = firebaseApp.getOptions().getProjectId(); 
        
        if (this.projectId == null || this.projectId.isBlank()) {
            throw new IllegalStateException("Firebase Project ID not configured in FirebaseApp options.");
        }

        this.webClient = WebClient.builder()
                .baseUrl("https://fcm.googleapis.com") 
                .build();
    }

    private Mono<String> getAccessToken() {
        return Mono.fromCallable(() -> {
            ClassPathResource resource = new ClassPathResource("firebase-service-account-key.json"); 
            try (InputStream stream = resource.getInputStream()) {
                GoogleCredentials credentials = GoogleCredentials.fromStream(stream)
                    .createScoped(Collections.singletonList("https://www.googleapis.com/auth/firebase.messaging"));
                
                credentials.refreshIfExpired(); 
                return credentials.getAccessToken().getTokenValue();
            }
        }).onErrorMap(IOException.class, e -> new RuntimeException("Impossible d'obtenir le token d'accès Google pour FCM.", e));
    }

    // NOUVELLE SIGNATURE : Accepte un dataPayload
    public Mono<Void> sendNotifications(List<String> tokens, String title, String body, Map<String, String> dataPayload) {
        if (tokens == null || tokens.isEmpty()) {
            log.warn("[FCM HTTP CLIENT] Aucun token fourni, l'envoi de notification est annulé.");
            return Mono.empty();
        }
        
        log.info("▶️ [FCM HTTP CLIENT] Préparation de l'envoi de la notification '{}' à {} appareil(s). Projet: {}", title, tokens.size(), this.projectId);

        return getAccessToken().flatMap(token ->
            Flux.fromIterable(tokens)
                .flatMap(singleToken -> { 
                    // Construction du corps de la requête JSON pour l'API FCM v1
                    Map<String, Object> messageContent = new HashMap<>();
                    messageContent.put("token", singleToken);
                    messageContent.put("notification", Map.of("title", title, "body", body));
                    
                    // AJOUT : Inclure le dataPayload si présent
                    if (dataPayload != null && !dataPayload.isEmpty()) {
                        messageContent.put("data", dataPayload);
                    }

                    Map<String, Object> notificationPayload = Map.of(
                        "message", messageContent
                    );

                    return webClient.post()
                        .uri("/v1/projects/{projectId}/messages:send", this.projectId)
                        .headers(headers -> headers.setBearerAuth(token))
                        .contentType(MediaType.APPLICATION_JSON)
                        .bodyValue(notificationPayload)
                        .retrieve()
                        .onStatus(HttpStatusCode::isError, response -> 
                            response.bodyToMono(String.class)
                                    .map(errorBody -> {
                                        log.error("❌ [FCM HTTP CLIENT] Erreur HTTP lors de l'envoi à FCM (Status: {}): {}", response.statusCode(), errorBody);
                                        return new RuntimeException("Échec d'envoi FCM: " + errorBody);
                                    })
                                    .switchIfEmpty(Mono.defer(() -> {
                                        log.error("❌ [FCM HTTP CLIENT] Échec d'envoi FCM: corps d'erreur vide. Status: {}", response.statusCode());
                                        return Mono.just(new RuntimeException("Échec d'envoi FCM: corps d'erreur vide. Status: " + response.statusCode()));
                                    }))
                        )
                        // <-- LA PARENTHÈSE EN TROP ÉTAIT ICI, JE L'AI SUPPRIMÉE !
                        .bodyToMono(String.class) 
                        .doOnSuccess(responseBody -> log.info("✅ [FCM HTTP CLIENT] Réponse de FCM pour token {}: {}", singleToken.substring(0, 10) + "...", responseBody)) 
                        .doOnError(e -> log.error("❌ [FCM HTTP CLIENT] Échec de l'envoi à FCM pour token {}: {}", singleToken.substring(0, 10) + "...", e.getMessage())) 
                        .onErrorResume(e -> Mono.empty()); 
                })
                .then() // <-- C'est ici que le Mono<Void> est généré.
        );
    }
}// END OF FILE: src/main/java/com/freelance/driver_backend/service/FcmHttpClient.java

//---> PATH: /home/mbogneng-junior/freelance-driver_Sylladb/backend/src/main/java/com/freelance/driver_backend/service/FirebaseService.java

package com.freelance.driver_backend.service;

import com.google.auth.oauth2.GoogleCredentials;
import com.google.firebase.FirebaseApp;
import com.google.firebase.FirebaseOptions;
import jakarta.annotation.PostConstruct;
import lombok.extern.slf4j.Slf4j;
import org.springframework.core.io.ClassPathResource;
import org.springframework.stereotype.Service;

import java.io.InputStream;

@Service
@Slf4j
public class FirebaseService {

    @PostConstruct // Cette méthode sera exécutée au démarrage de Spring
    public void initialize() {
        try {
            // Assurez-vous que votre fichier de clé de service Firebase
            // est placé dans src/main/resources
            ClassPathResource resource = new ClassPathResource("firebase-service-account-key.example");
            InputStream serviceAccount = resource.getInputStream();

            FirebaseOptions options = FirebaseOptions.builder()
                .setCredentials(GoogleCredentials.fromStream(serviceAccount))
                .build();

            if (FirebaseApp.getApps().isEmpty()) {
                FirebaseApp.initializeApp(options);
                log.info("Firebase Admin SDK a été initialisé avec succès.");
            } else {
                log.warn("Firebase Admin SDK est déjà initialisé.");
            }
        } catch (Exception e) {
            log.error("Erreur lors de l'initialisation du Firebase Admin SDK. Les notifications push ne fonctionneront pas.", e);
        }
    }
}// END OF FILE: src/main/java/com/freelance/driver_backend/service/FirebaseService.java

//---> PATH: /home/mbogneng-junior/freelance-driver_Sylladb/backend/src/main/java/com/freelance/driver_backend/service/internal/ExternalMediaStorageService.java

package com.freelance.driver_backend.service.internal;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.DeserializationFeature;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.freelance.driver_backend.dto.external.OAuthTokenResponse;
import com.freelance.driver_backend.dto.external.UploadMediaResponse;
import com.freelance.driver_backend.service.StorageService;
import com.freelance.driver_backend.service.external.AuthService;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Primary;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpStatusCode;
import org.springframework.http.MediaType;
import org.springframework.http.codec.multipart.FilePart;
import org.springframework.stereotype.Service;
import org.springframework.util.LinkedMultiValueMap;
import org.springframework.util.MultiValueMap;
import org.springframework.web.reactive.function.BodyInserters;
import org.springframework.web.reactive.function.client.WebClient;
import reactor.core.publisher.Mono;

import java.net.URI;
import java.net.URISyntaxException;
import java.util.UUID;

@Service
@Primary
@Slf4j
public class ExternalMediaStorageService implements StorageService {

    private final WebClient externalMediaServiceWebClient;
    private final AuthService authService;
    private final String oauthClientId;
    private final String oauthClientSecret;

    public ExternalMediaStorageService(
            @Qualifier("externalMediaServiceWebClient") WebClient externalMediaServiceWebClient,
            AuthService authService,
            @Value("${freelancedriver.oauth2.client-id}") String oauthClientId,
            @Value("${freelancedriver.oauth2.client-secret}") String oauthClientSecret) {
        this.externalMediaServiceWebClient = externalMediaServiceWebClient;
        this.authService = authService;
        this.oauthClientId = oauthClientId;
        this.oauthClientSecret = oauthClientSecret;
    }

    private Mono<String> getM2MBearerToken() {
        return authService.getClientCredentialsToken(oauthClientId, oauthClientSecret)
                .map(OAuthTokenResponse::getAccessToken)
                .map(token -> "Bearer " + token)
                .doOnError(e -> log.error("❌ Échec de l'obtention du token M2M pour l'API de médias: {}",
                        e.getMessage(), e))
                .switchIfEmpty(
                        Mono.error(new RuntimeException("Impossible d'obtenir un token M2M pour l'API de médias.")));
    }

    private String determineExternalMediaType(MediaType contentType) {
        if (contentType == null)
            return "unknown";
        if (contentType.isCompatibleWith(MediaType.IMAGE_JPEG) || contentType.isCompatibleWith(MediaType.IMAGE_PNG)
                || contentType.isCompatibleWith(MediaType.IMAGE_GIF)) {
            return "image";
        }
        if (contentType.isCompatibleWith(MediaType.APPLICATION_PDF)) {
            return "pdf";
        }
        if (contentType.isCompatibleWith(MediaType.parseMediaType("audio/*"))) {
            return "audio";
        }
        if (contentType.isCompatibleWith(MediaType.parseMediaType("video/*"))) {
            return "video";
        }
        return "file";
    }

    @Override
    public Mono<UploadMediaResponse> saveFile(String serviceContext, String frontendLogicalType, UUID uploaderUserId,
            UUID targetResourceId, String originalFileName, FilePart file) {
        log.info(
                "[ExternalMediaStorageService] Téléversement vers l'API externe de médias. FrontendType: {}, ResourceId: {}, UserId: {}",
                frontendLogicalType, targetResourceId, uploaderUserId);

        String externalMediaType = determineExternalMediaType(file.headers().getContentType());
        if ("unknown".equals(externalMediaType)) {
            return Mono.error(new IllegalArgumentException("Unsupported media type for file: " + originalFileName));
        }

        // ---------- CORRECTION DE LA CONSTRUCTION DE L'URI POUR POST ----------
        // L'API s'attend à: /media/{service}/{type}/{path}/{resource_id}
        // où {path} est un segment simple (ex: "avatars")
        // et {resource_id} est l'ID de la ressource associée (ex: l'ID de
        // l'utilisateur)
        String apiUri = String.format("/media/%s/%s/%s/%s",
                serviceContext, // ex: "product"
                externalMediaType, // ex: "image"
                frontendLogicalType, // C'est le {path} simple, ex: "avatars"
                targetResourceId.toString()); // C'est le {resource_id}, ex: l'UUID de l'utilisateur
        // -------------------------------------------------------------------

        log.info("[ExternalMediaStorageService] URI de l'API externe pour POST : {}", apiUri);

        MultiValueMap<String, Object> body = new LinkedMultiValueMap<>();
        body.add("file", file);

        return getM2MBearerToken()
                .flatMap(m2mBearerToken -> externalMediaServiceWebClient.post()
                        .uri(apiUri)
                        .header(HttpHeaders.AUTHORIZATION, m2mBearerToken)
                        .contentType(MediaType.MULTIPART_FORM_DATA)
                        .body(BodyInserters.fromMultipartData(body))
                        .retrieve()
                        .onStatus(HttpStatusCode::isError, response -> response.bodyToMono(String.class)
                                .flatMap(errorBody -> {
                                    log.error("❌ Erreur HTTP lors du téléversement vers l'API externe (Status: {}): {}",
                                            response.statusCode(), errorBody);
                                    return Mono.error(new RuntimeException(
                                            "Échec du téléversement vers le service de médias externe: " + errorBody));
                                })
                                .switchIfEmpty(Mono.defer(() -> Mono.error(new RuntimeException(
                                        "Échec du téléversement vers le service de médias externe: corps d'erreur vide. Status: "
                                                + response.statusCode()))))
                                .cast(Throwable.class))
                        .bodyToMono(String.class)
                        .flatMap(rawResponseBody -> {
                            log.info("[ExternalMediaStorageService] Réponse brute de l'API de médias externe: {}",
                                    rawResponseBody);

                            if (rawResponseBody == null || rawResponseBody.trim().isEmpty()) {
                                log.error(
                                        "[ExternalMediaStorageService] L'API de médias externe a renvoyé une réponse vide ou nulle APRÈS un statut 2xx. Ceci est inattendu.");
                                return Mono.error(new RuntimeException(
                                        "L'API de médias externe a renvoyé une réponse vide après un statut de succès."));
                            }

                            try {
                                ObjectMapper objectMapper = new ObjectMapper();
                                objectMapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);

                                UploadMediaResponse uploadResponse = objectMapper.readValue(rawResponseBody,
                                        UploadMediaResponse.class);

                                if (uploadResponse == null || uploadResponse.getId() == null
                                        || uploadResponse.getResourceId() == null || uploadResponse.getUri() == null
                                        || uploadResponse.getUrl() == null || uploadResponse.getUrl().isEmpty()) {
                                    log.error(
                                            "[ExternalMediaStorageService] La désérialisation a réussi, mais la réponse de l'API de médias externe est INVALIDE (champs essentiels manquants ou nuls): {}. Réponse brute: {}",
                                            uploadResponse, rawResponseBody);
                                    return Mono.error(new RuntimeException(
                                            "La réponse de l'API de médias externe est incomplète ou invalide."));
                                }

                                return Mono.just(uploadResponse);
                            } catch (JsonProcessingException e) {
                                log.error(
                                        "[ExternalMediaStorageService] Erreur de désérialisation JSON de la réponse de l'API de médias externe: {} - Réponse brute: {}",
                                        e.getMessage(), rawResponseBody, e);
                                return Mono.error(new RuntimeException(
                                        "Échec de l'analyse JSON de la réponse du service de médias externe.", e));
                            } catch (Exception e) {
                                log.error(
                                        "[ExternalMediaStorageService] Erreur inattendue lors du traitement de la réponse de l'API de médias externe: {} - Réponse brute: {}",
                                        e.getMessage(), rawResponseBody, e);
                                return Mono.error(new RuntimeException(
                                        "Erreur lors du traitement de la réponse du service de médias externe.", e));
                            }
                        })
                        .doOnSuccess(uploadResponse -> log.info(
                                "✅ [ExternalMediaStorageService] Upload réussi. URL: {}, URI: {}",
                                uploadResponse.getUrl(), uploadResponse.getUri()))
                        .onErrorResume(e -> {
                            log.error(
                                    "[ExternalMediaStorageService] Erreur fatale dans la chaîne de traitement de l'upload: {}",
                                    e.getMessage(), e);
                            return Mono
                                    .error(new RuntimeException("Échec de l'upload de fichier: " + e.getMessage(), e));
                        }));
    }

    @Override
    public Mono<Void> deleteFile(String mediaUri) {
        log.info("[ExternalMediaStorageService] Suppression du fichier via l'API externe: {}", mediaUri);

        try {
            URI uri = new URI(mediaUri);
            String path = uri.getPath();

            String[] segments = path.split("/");
            // On s'attend à ce que l'URI après /media-service/ soit de la forme:
            // /service/type/path/resource_id/filename.jpg
            // ex: /product/image/avatars/user_id_uuid/unique_filename.jpg
            if (segments.length < 6) { // "", "service", "type", "path", "resource_id", "filename"
                log.error(
                        "URI de média invalide pour la suppression (segments insuffisants): {}. Attendu au moins 6 segments.",
                        mediaUri);
                return Mono.error(new IllegalArgumentException("URI de média invalide pour la suppression: " + mediaUri
                        + ". Format attendu: /service/type/{path}/{resource_id}/filename"));
            }

            String service = segments[1]; // ex: "product"
            String type = segments[2]; // ex: "image"
            String pathSegment = segments[3]; // ex: "avatars"
            String resourceIdSegment = segments[4]; // ex: "user_id_uuid"
            String filename = segments[5]; // ex: "unique_filename.jpg"

            // ---------- CORRECTION DE LA CONSTRUCTION DE L'URI POUR DELETE ----------
            // L'API DELETE attend: /media/{service}/{type}/{path}/{filename}
            // où {path} représente le chemin complet jusqu'au dossier du fichier, SANS le
            // nom de fichier.
            // Donc, notre {path} doit être "avatars/user_id_uuid"
            String fullPathForDelete = String.format("%s/%s", pathSegment, resourceIdSegment); // Ceci crée
                                                                                               // "avatars/user_id_uuid"
            // -------------------------------------------------------------------

            String apiUrl = String.format("/media/%s/%s/%s/%s", service, type, fullPathForDelete, filename);

            log.info("[ExternalMediaStorageService] URI de l'API externe pour DELETE : {}", apiUrl);

            return getM2MBearerToken()
                    .flatMap(m2mBearerToken -> externalMediaServiceWebClient.delete()
                            .uri(apiUrl)
                            .header(HttpHeaders.AUTHORIZATION, m2mBearerToken)
                            .retrieve()
                            .onStatus(HttpStatusCode::isError, response -> response.bodyToMono(String.class)
                                    .flatMap(errorBody -> {
                                        log.error(
                                                "❌ Erreur HTTP lors de la suppression de l'API externe (Status: {}): {}",
                                                response.statusCode(), errorBody);
                                        return Mono.just(new RuntimeException(
                                                "Échec de la suppression du fichier sur le service de médias externe: "
                                                        + errorBody));
                                    })
                                    .switchIfEmpty(Mono.defer(() -> Mono.just(new RuntimeException(
                                            "Échec de la suppression du fichier sur le service de médias externe: corps d'erreur vide. Status: "
                                                    + response.statusCode())))))
                            .bodyToMono(Void.class)
                            .doOnError(e -> log.error(
                                    "[ExternalMediaStorageService] Erreur inattendue lors de la suppression de l'API externe : {}",
                                    e.getMessage(), e)));

        } catch (URISyntaxException e) {
            log.error("URI de média invalide fournie pour la suppression: {}", mediaUri, e);
            return Mono.error(new IllegalArgumentException("URI de média invalide: " + mediaUri, e));
        }
    }
}// END OF FILE: src/main/java/com/freelance/driver_backend/service/internal/ExternalMediaStorageService.java

//---> PATH: /home/mbogneng-junior/freelance-driver_Sylladb/backend/src/main/java/com/freelance/driver_backend/service/internal/ResourceServiceLocalImpl.java

package com.freelance.driver_backend.service.internal;

import com.freelance.driver_backend.dto.CreateProductRequest;
import com.freelance.driver_backend.model.Product;
import com.freelance.driver_backend.service.ResourceService;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.context.annotation.Profile;
import org.springframework.stereotype.Service;
import org.springframework.web.reactive.function.client.WebClient;
import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;
import java.util.UUID;





@Service
@Slf4j
public class ResourceServiceLocalImpl implements ResourceService {
    private final WebClient localApiClient;

    public ResourceServiceLocalImpl(@Qualifier("localApiWebClient") WebClient localApiClient) {
        this.localApiClient = localApiClient;
    }

    @Override
    public Mono<Product> createProduct(UUID organizationId, CreateProductRequest request, String bearerToken, String publicKey) {
        log.warn("[LOCAL-IMPL] Appel de MockProductController pour créer un produit/adresse.");
        return localApiClient.post()
                .uri("/api/mock-products/{organizationId}", organizationId)
                .header("Authorization", bearerToken)
                .bodyValue(request)
                .retrieve()
                .bodyToMono(Product.class);
    }

    @Override
    public Flux<Product> getProductsByCategory(UUID organizationId, UUID categoryId, String bearerToken, String publicKey) {
        log.warn("[LOCAL-IMPL] Appel de MockProductController pour lister les produits/adresses.");
        return localApiClient.get()
                .uri(uriBuilder -> uriBuilder
                        .path("/api/mock-products/{organizationId}")
                        .queryParam("categoryId", categoryId)
                        .build(organizationId))
                .header("Authorization", bearerToken)
                .retrieve()
                .bodyToFlux(Product.class);
    }

    @Override
    public Mono<Product> updateProduct(UUID organizationId, UUID productId, CreateProductRequest request, String bearerToken, String publicKey) {
        log.warn("[LOCAL-IMPL] Appel de MockProductController pour mettre à jour le produit/adresse {}.", productId);
        return localApiClient.put()
                .uri("/api/mock-products/{organizationId}/{productId}", organizationId, productId)
                .header("Authorization", bearerToken)
                .bodyValue(request)
                .retrieve()
                .bodyToMono(Product.class);
    }

    @Override
    public Mono<Void> deleteProduct(UUID organizationId, UUID productId, String bearerToken, String publicKey) {
        log.warn("[LOCAL-IMPL] Appel de MockProductController pour supprimer le produit/adresse {}.", productId);
        return localApiClient.delete()
                .uri("/api/mock-products/{organizationId}/{productId}", organizationId, productId)
                .header("Authorization", bearerToken)
                .retrieve()
                .bodyToMono(Void.class);
    }
}// END OF FILE: src/main/java/com/freelance/driver_backend/service/internal/ResourceServiceLocalImpl.java

//---> PATH: /home/mbogneng-junior/freelance-driver_Sylladb/backend/src/main/java/com/freelance/driver_backend/service/JwtService.java

package com.freelance.driver_backend.service;

import com.freelance.driver_backend.model.mock.MockUser;
import lombok.RequiredArgsConstructor;
import org.springframework.security.oauth2.jwt.JwtClaimsSet;
import org.springframework.security.oauth2.jwt.JwtEncoder;
import org.springframework.security.oauth2.jwt.JwtEncoderParameters;
import org.springframework.stereotype.Service;

import java.time.Instant;
import java.time.temporal.ChronoUnit;
import java.util.HashMap;
import java.util.Map;

@Service
@RequiredArgsConstructor
public class JwtService {

    private final JwtEncoder jwtEncoder;

    public String generateToken(MockUser user) {
        Instant now = Instant.now();
        Instant expiration = now.plus(1, ChronoUnit.HOURS);

        // Créer le claim "user" compatible avec votre JwtUtil
        Map<String, Object> userClaim = new HashMap<>();
        userClaim.put("id", user.getId().toString());
        userClaim.put("username", user.getUsername());
        userClaim.put("email", user.getEmail());
        userClaim.put("firstName", user.getFirstName());
        userClaim.put("lastName", user.getLastName());

        JwtClaimsSet claims = JwtClaimsSet.builder()
                .issuer("freelance-driver-app")
                .issuedAt(now)
                .expiresAt(expiration)
                .subject(user.getUsername())
                .claim("user", userClaim)
                .build();

        return jwtEncoder.encode(JwtEncoderParameters.from(claims)).getTokenValue();
    }
}// END OF FILE: src/main/java/com/freelance/driver_backend/service/JwtService.java

//---> PATH: /home/mbogneng-junior/freelance-driver_Sylladb/backend/src/main/java/com/freelance/driver_backend/service/LoginService.java


/* package com.freelance.driver_backend.service;

import com.freelance.driver_backend.dto.external.ChatUserLoginPayload;
import com.freelance.driver_backend.dto.external.ChatUserLoginResponse;
import com.freelance.driver_backend.dto.external.LoginRequest;
import com.freelance.driver_backend.dto.external.LoginResponse;
import com.freelance.driver_backend.dto.onboarding.ChatSessionInfo;
import com.freelance.driver_backend.dto.onboarding.OnboardingResponse;
import com.freelance.driver_backend.repository.ClientProfileRepository;
import com.freelance.driver_backend.repository.DriverProfileRepository;
import com.freelance.driver_backend.service.external.AuthService;
import com.freelance.driver_backend.service.external.ChatService;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Service;
import reactor.core.publisher.Mono;

import java.util.Collections;
import java.util.List;
import java.util.UUID;

@Service
@RequiredArgsConstructor
@Slf4j
public class LoginService {

    private final AuthService authService;
    private final ChatService chatService;
    private final DriverProfileRepository driverProfileRepository;
    private final ClientProfileRepository clientProfileRepository;
    private final ProfileService profileService;

    @Value("${freelancedriver.oauth2.client-id}")
    private String oauthClientId;
    @Value("${freelancedriver.oauth2.client-secret}")
    private String oauthClientSecret;

    public Mono<OnboardingResponse> loginAndGetContext(LoginRequest loginRequest) {
        log.info("Login process started for user: {}", loginRequest.getUsername());

        return authService.getClientCredentialsToken(oauthClientId, oauthClientSecret)
                .flatMap(m2mToken -> authService.loginUser(loginRequest, "Bearer " + m2mToken.getAccessToken()))
                .flatMap(loginResponse -> {
                    if (loginResponse.getUser() == null || loginResponse.getUser().getId() == null) {
                        return Mono.error(new RuntimeException("Incomplete login response from auth service."));
                    }

                    log.info("User {} successfully logged in. Chat login temporarily disabled.", loginResponse.getUser().getUsername());

                    String userBearerToken = "Bearer " + loginResponse.getAccessToken().getToken();

                    return profileService.getUserSessionContext(loginResponse.getUser().getId(), userBearerToken, null)
                            .flatMap(userContextDto -> {
                                if (userContextDto == null) {
                                    return Mono.error(new RuntimeException("No local profile context found for user " + loginResponse.getUser().getId()));
                                }

                                // MODIFIÉ : Utilise getRoles() qui retourne une List<UserRole>
                                log.info("Profile context found for user {}. Roles: {}", loginResponse.getUser().getUsername(), userContextDto.getRoles());

                                return Mono.just(OnboardingResponse.builder()
                                        .token(loginResponse.getAccessToken().getToken())
                                        .profile(userContextDto)
                                        .chatSession(null)
                                        .build());
                            });
                });
    }
}

*/



package com.freelance.driver_backend.service;

import com.freelance.driver_backend.dto.external.ChatUserLoginPayload;
import com.freelance.driver_backend.dto.external.ChatUserLoginResponse;
import com.freelance.driver_backend.dto.external.LoginRequest;
import com.freelance.driver_backend.dto.external.LoginResponse;
import com.freelance.driver_backend.dto.onboarding.ChatSessionInfo;
import com.freelance.driver_backend.dto.onboarding.OnboardingResponse;
import com.freelance.driver_backend.repository.ClientProfileRepository;
import com.freelance.driver_backend.repository.DriverProfileRepository;
import com.freelance.driver_backend.service.external.AuthService;
import com.freelance.driver_backend.service.external.ChatService;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Service;
import reactor.core.publisher.Mono;

import java.util.Collections;
import java.util.List;
import java.util.UUID;

@Service
@RequiredArgsConstructor
@Slf4j
public class LoginService {

    private final AuthService authService;
    private final ChatService chatService;
    private final DriverProfileRepository driverProfileRepository;
    private final ClientProfileRepository clientProfileRepository;
    private final ProfileService profileService;

    @Value("${freelancedriver.oauth2.client-id}")
    private String oauthClientId;
    @Value("${freelancedriver.oauth2.client-secret}")
    private String oauthClientSecret;

    public Mono<OnboardingResponse> loginAndGetContext(LoginRequest loginRequest) {
        log.info("Login process started for user: {}", loginRequest.getUsername());

        return authService.loginUser(loginRequest, "Bearer hhdjdeiieeueuue" )
                .flatMap(loginResponse -> {
                    if (loginResponse.getUser() == null || loginResponse.getUser().getId() == null) {
                        return Mono.error(new RuntimeException("Incomplete login response from auth service."));
                    }

                    log.info("User {} successfully logged in. Chat login temporarily disabled.", loginResponse.getUser().getUsername());

                    String userBearerToken = "Bearer " + loginResponse.getAccessToken().getToken();

                    return profileService.getUserSessionContext(loginResponse.getUser().getId(), userBearerToken, null)
                            .flatMap(userContextDto -> {
                                if (userContextDto == null) {
                                    return Mono.error(new RuntimeException("No local profile context found for user " + loginResponse.getUser().getId()));
                                }

                                // MODIFIÉ : Utilise getRoles() qui retourne une List<UserRole>
                                log.info("Profile context found for user {}. Roles: {}", loginResponse.getUser().getUsername(), userContextDto.getRoles());

                                return Mono.just(OnboardingResponse.builder()
                                        .token(loginResponse.getAccessToken().getToken())
                                        .profile(userContextDto)
                                        .chatSession(null)
                                        .build());
                            });
                });
    }
}
// END OF FILE: src/main/java/com/freelance/driver_backend/service/LoginService.java

//---> PATH: /home/mbogneng-junior/freelance-driver_Sylladb/backend/src/main/java/com/freelance/driver_backend/service/MockUserService.java

package com.freelance.driver_backend.service;

import com.freelance.driver_backend.dto.external.*;
import com.freelance.driver_backend.model.mock.MockUser;
import com.freelance.driver_backend.repository.mock.MockUserRepository;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Service;
import reactor.core.publisher.Mono;

import java.time.OffsetDateTime;
import java.util.List;
import java.util.UUID;

@Service
@RequiredArgsConstructor
public class MockUserService {
    
   private final MockUserRepository mockUserRepository;
    private final JwtService jwtService;

    public Mono<UserDto> register(RegistrationRequest request) {
        return mockUserRepository.findByEmail(request.getEmail())
                .hasElement()
                .flatMap(emailExists -> {
                    if (emailExists) {
                        return Mono.error(new RuntimeException("Email déjà utilisé"));
                    }
                    return mockUserRepository.findByUsername(request.getUsername()).hasElement();
                })
                .flatMap(usernameExists -> {
                    if (usernameExists) {
                        return Mono.error(new RuntimeException("Username déjà utilisé"));
                    }
                    
                    MockUser user = new MockUser();
                    user.setId(UUID.randomUUID());
                    user.setUsername(request.getUsername());
                    user.setPassword(request.getPassword());
                    user.setEmail(request.getEmail());
                    user.setFirstName(request.getFirstName());
                    user.setLastName(request.getLastName());
                    user.setPhoneNumber(request.getPhoneNumber());
                    // Supprimer cette ligne si RegistrationRequest n'a pas organisationId
                    // user.setOrganisationId(request.getOrganisationId()); 
                    //user.setOrganisationId(null); // Ou définir une valeur par défaut

                    return mockUserRepository.save(user);
                })
                .map(this::convertToUserDto);
    }

    

    public Mono<LoginResponse> login(LoginRequest request) {
        return mockUserRepository.findByUsername(request.getUsername())
                .switchIfEmpty(Mono.error(new RuntimeException("Identifiants invalides")))
                .filter(user -> user.getPassword().equals(request.getPassword()))
                .switchIfEmpty(Mono.error(new RuntimeException("Identifiants invalides")))
                .map(user -> {
                    // JwtService est maintenant synchrone
                    String token = jwtService.generateToken(user);
                    return createLoginResponse(user, token);
                });
    }

    private LoginResponse createLoginResponse(MockUser user, String jwtToken) {
        LoginResponse response = new LoginResponse();
        
        // Access Token avec vrai JWT
        LoginResponse.AccessToken accessToken = new LoginResponse.AccessToken();
        accessToken.setToken(jwtToken);
        accessToken.setType("Bearer");
        accessToken.setExpiresIn(3600);
        response.setAccessToken(accessToken);
        
        // User Info
        LoginResponse.UserInfo userInfo = new LoginResponse.UserInfo();
        userInfo.setId(user.getId());
        userInfo.setFirstName(user.getFirstName());
        userInfo.setLastName(user.getLastName());
        userInfo.setUsername(user.getUsername());
        userInfo.setEmail(user.getEmail());
        userInfo.setPhoneNumber(user.getPhoneNumber());
        userInfo.setEmailVerified(false);
        userInfo.setPhoneNumberVerified(false);
        response.setUser(userInfo);
        
        response.setRoles(List.of("USER"));
        response.setPermissions(List.of("READ_PROFILE", "UPDATE_PROFILE"));
        
        return response;
    }

    private UserDto convertToUserDto(MockUser user) {
        UserDto dto = new UserDto();
        dto.setId(user.getId());
        dto.setUsername(user.getUsername());
        dto.setEmail(user.getEmail());
        dto.setFirstName(user.getFirstName());
        dto.setLastName(user.getLastName());
        dto.setPhoneNumber(user.getPhoneNumber());
        dto.setEmailVerified(false);
        dto.setPhoneNumberVerified(false);
        dto.setEnabled(true);
        dto.setCreatedAt(OffsetDateTime.now());
        dto.setUpdatedAt(OffsetDateTime.now());
        return dto;
    }
}// END OF FILE: src/main/java/com/freelance/driver_backend/service/MockUserService.java

//---> PATH: /home/mbogneng-junior/freelance-driver_Sylladb/backend/src/main/java/com/freelance/driver_backend/service/NotificationTriggerService.java



package com.freelance.driver_backend.service;

import com.freelance.driver_backend.dto.external.NotificationRequest;
import com.freelance.driver_backend.model.ClientProfile;
import com.freelance.driver_backend.model.DeviceToken;
import com.freelance.driver_backend.model.DriverProfile;
import com.freelance.driver_backend.model.Product;
import com.freelance.driver_backend.repository.ClientProfileRepository;
import com.freelance.driver_backend.repository.DeviceTokenRepository;
import com.freelance.driver_backend.repository.DriverProfileRepository;
import com.freelance.driver_backend.service.external.NotificationService;
import io.github.cdimascio.dotenv.Dotenv;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;
import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;

import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.UUID;
import java.util.stream.Collectors;

@Service
@RequiredArgsConstructor
@Slf4j
public class NotificationTriggerService {

    private final ClientProfileRepository clientProfileRepository;
    private final DriverProfileRepository driverProfileRepository;
    private final DeviceTokenRepository deviceTokenRepository;
    private final NotificationService notificationService;
    private final Dotenv dotenv;

    /**
     * Notifie un client qu'un chauffeur a postulé à son annonce.
     */
    public Mono<Void> notifyClientOfAcceptedAnnouncement(Product announcement, DriverProfile driverProfile) {
        UUID targetClientId = announcement.getClientId();
        if (targetClientId == null) return Mono.empty();
        
        log.info("Déclenchement de la notification pour le client {} (postulation par chauffeur {}) pour l'annonce {}.", targetClientId, driverProfile.getUserId(), announcement.getName());

        return deviceTokenRepository.findByUserId(targetClientId)
            .map(DeviceToken::getToken)
            .collectList()
            .flatMap(tokens -> {
                if (tokens.isEmpty()) {
                    log.warn("Aucun token d'appareil trouvé pour le client {}.", targetClientId);
                    return Mono.empty();
                }
                
                UUID templateId = UUID.fromString(dotenv.get("TEMPLATE_PUSH_ANNOUNCEMENT_ACCEPTED_ID"));
                
                Map<String, String> dataPayload = new HashMap<>();
                dataPayload.put("screen", "DriverDetails");
                dataPayload.put("driverId", driverProfile.getUserId().toString());
                dataPayload.put("announcementId", announcement.getId().toString());
                dataPayload.put("source", "notification");
                
                NotificationRequest request = NotificationRequest.builder()
                    .templateId(templateId)
                    .recipients(tokens)
                    .metadata(Map.of(
                        "driverName", driverProfile.getFirstName() + " " + driverProfile.getLastName(),
                        "tripTitle", announcement.getName(),
                        "driverId", driverProfile.getUserId().toString() 
                    ))
                    .data(dataPayload)
                    .build();
                
                return notificationService.sendPushNotification(announcement.getOrganizationId(), request, null, null);
            })
            .then();
    }

    /**
     * Notifie un chauffeur que sa postulation a été acceptée par le client.
     */
    public Mono<Void> notifyDriverOfConfirmedAnnouncement(Product announcement, DriverProfile driverProfile) {
        UUID targetDriverId = driverProfile.getUserId();
        if (targetDriverId == null) return Mono.empty();

        log.info("Déclenchement de la notification pour le chauffeur {} (postulation ACCEPTÉE) pour l'annonce {}.", targetDriverId, announcement.getName());

        return deviceTokenRepository.findByUserId(targetDriverId)
            .map(DeviceToken::getToken)
            .collectList()
            .flatMap(tokens -> {
                if (tokens.isEmpty()) {
                    log.warn("Aucun token d'appareil trouvé pour le chauffeur {}.", targetDriverId);
                    return Mono.empty();
                }

                UUID templateId = UUID.fromString(dotenv.get("TEMPLATE_PUSH_ANNOUNCEMENT_CONFIRMED_ID")); 
                
                return clientProfileRepository.findByUserId(announcement.getClientId())
                    .flatMap(clientProfile -> {
                        Map<String, String> dataPayload = new HashMap<>();
                        dataPayload.put("screen", "MyAcceptedRides"); 
                        dataPayload.put("tripId", announcement.getId().toString());
                        dataPayload.put("source", "notification");

                        NotificationRequest request = NotificationRequest.builder()
                            .templateId(templateId)
                            .recipients(tokens)
                            .metadata(Map.of(
                                "clientName", clientProfile.getFirstName() + " " + clientProfile.getLastName(),
                                "tripTitle", announcement.getName(),
                                "tripId", announcement.getId().toString()
                            ))
                            .data(dataPayload)
                            .build();
                        return notificationService.sendPushNotification(announcement.getOrganizationId(), request, null, null);
                    })
                    .then();
            })
            .then();
    }

    /**
     * Notifie le client qu'un chauffeur a annulé sa postulation.
     */
    public Mono<Void> notifyClientOfCancelledPostulation(Product announcement, DriverProfile driverProfile) {
        UUID targetClientId = announcement.getClientId();
        if (targetClientId == null) return Mono.empty();

        log.info("Déclenchement de la notification pour le client {} (postulation ANNULÉE par chauffeur {}) pour l'annonce {}.", targetClientId, driverProfile.getUserId(), announcement.getName());

        return deviceTokenRepository.findByUserId(targetClientId)
            .map(DeviceToken::getToken)
            .collectList()
            .flatMap(tokens -> {
                if (tokens.isEmpty()) {
                    log.warn("Aucun token d'appareil trouvé pour le client {}.", targetClientId);
                    return Mono.empty();
                }

                UUID templateId = UUID.fromString(dotenv.get("TEMPLATE_PUSH_POSTULATION_CANCELLED_ID")); 
                
                Map<String, String> dataPayload = new HashMap<>();
                dataPayload.put("screen", "MyAnnouncements"); 
                dataPayload.put("announcementId", announcement.getId().toString());
                dataPayload.put("source", "notification");

                NotificationRequest request = NotificationRequest.builder()
                    .templateId(templateId)
                    .recipients(tokens)
                    .metadata(Map.of(
                        "driverName", driverProfile.getFirstName() + " " + driverProfile.getLastName(),
                        "tripTitle", announcement.getName()
                    ))
                    .data(dataPayload)
                    .build();
                return notificationService.sendPushNotification(announcement.getOrganizationId(), request, null, null);
            })
            .then();
    }
    
    /**
     * NOUVEAU : Notifie le CHAUFFEUR qu'un client a DEMANDÉ à réserver son planning.
     */
    public Mono<Void> notifyDriverOfPlanningBookingRequest(Product planning, ClientProfile clientProfile) {
        UUID targetDriverId = planning.getClientId(); // L'auteur du planning est le chauffeur
        if (targetDriverId == null) return Mono.empty();

        log.info("Déclenchement de la notification pour le chauffeur {} (demande de réservation de planning par client {}) pour le planning {}.", targetDriverId, clientProfile.getUserId(), planning.getName());

        return deviceTokenRepository.findByUserId(targetDriverId)
            .map(DeviceToken::getToken)
            .collectList()
            .flatMap(tokens -> {
                if (tokens.isEmpty()) {
                    log.warn("Aucun token d'appareil trouvé pour le chauffeur {}.", targetDriverId);
                    return Mono.empty();
                }

                UUID templateId = UUID.fromString(dotenv.get("TEMPLATE_PUSH_PLANNING_BOOKING_REQUESTED_TO_DRIVER_ID"));
                
                Map<String, String> dataPayload = new HashMap<>();
                dataPayload.put("screen", "MyPlannings"); // Écran où le chauffeur voit ses plannings ou demandes
                dataPayload.put("planningId", planning.getId().toString());
                dataPayload.put("clientId", clientProfile.getUserId().toString()); // Pour que le chauffeur puisse confirmer
                dataPayload.put("source", "notification");

                NotificationRequest request = NotificationRequest.builder()
                    .templateId(templateId)
                    .recipients(tokens)
                    .metadata(Map.of(
                        "clientName", clientProfile.getFirstName() + " " + clientProfile.getLastName(),
                        "tripTitle", planning.getName()
                    ))
                    .data(dataPayload)
                    .build();
                return notificationService.sendPushNotification(planning.getOrganizationId(), request, null, null);
            })
            .then();
    }

    /**
     * NOUVEAU : Notifie le CLIENT qu'un chauffeur a ACCEPTÉ sa demande de réservation de planning.
     */
    public Mono<Void> notifyClientOfPlanningBookingAccepted(Product planning, DriverProfile driverProfile) {
        UUID targetClientId = planning.getReservedByDriverId(); // C'est le client qui avait initié la réservation
        if (targetClientId == null) return Mono.empty();

        log.info("Déclenchement de la notification pour le client {} (réservation de planning ACCEPTÉE par chauffeur {}) pour le planning {}.", targetClientId, driverProfile.getUserId(), planning.getName());

        return deviceTokenRepository.findByUserId(targetClientId)
            .map(DeviceToken::getToken)
            .collectList()
            .flatMap(tokens -> {
                if (tokens.isEmpty()) {
                    log.warn("Aucun token d'appareil trouvé pour le client {}.", targetClientId);
                    return Mono.empty();
                }

                UUID templateId = UUID.fromString(dotenv.get("TEMPLATE_PUSH_PLANNING_BOOKING_ACCEPTED_TO_CLIENT_ID"));
                
                Map<String, String> dataPayload = new HashMap<>();
                dataPayload.put("screen", "MyReservations"); // Écran où le client voit ses réservations
                dataPayload.put("planningId", planning.getId().toString());
                dataPayload.put("driverId", driverProfile.getUserId().toString()); // Infos du chauffeur si besoin
                dataPayload.put("source", "notification");

                NotificationRequest request = NotificationRequest.builder()
                    .templateId(templateId)
                    .recipients(tokens)
                    .metadata(Map.of(
                        "driverName", driverProfile.getFirstName() + " " + driverProfile.getLastName(),
                        "tripTitle", planning.getName()
                    ))
                    .data(dataPayload)
                    .build();
                return notificationService.sendPushNotification(planning.getOrganizationId(), request, null, null);
            })
            .then();
    }

    /**
     * NOUVEAU : Notifie le CHAUFFEUR qu'un client a ANNULÉ sa réservation ou sa demande de réservation de planning.
     */
    public Mono<Void> notifyDriverOfCancelledPlanningReservation(Product planning, ClientProfile clientProfile) {
        UUID targetDriverId = planning.getClientId(); // L'auteur du planning est le chauffeur
        if (targetDriverId == null) return Mono.empty();

        log.info("Déclenchement de la notification pour le chauffeur {} (réservation/demande ANNULÉE par client {}) pour le planning {}.", targetDriverId, clientProfile.getUserId(), planning.getName());

        return deviceTokenRepository.findByUserId(targetDriverId)
            .map(DeviceToken::getToken)
            .collectList()
            .flatMap(tokens -> {
                if (tokens.isEmpty()) {
                    log.warn("Aucun token d'appareil trouvé pour le chauffeur {}.", targetDriverId);
                    return Mono.empty();
                }

                UUID templateId = UUID.fromString(dotenv.get("TEMPLATE_PUSH_PLANNING_RESERVATION_CANCELLED_ID"));
                
                Map<String, String> dataPayload = new HashMap<>();
                dataPayload.put("screen", "MyPlannings"); // Écran où le chauffeur voit ses plannings
                dataPayload.put("planningId", planning.getId().toString());
                dataPayload.put("source", "notification");

                NotificationRequest request = NotificationRequest.builder()
                    .templateId(templateId)
                    .recipients(List.copyOf(tokens))
                    .metadata(Map.of(
                        "clientName", clientProfile.getFirstName() + " " + clientProfile.getLastName(),
                        "tripTitle", planning.getName()
                    ))
                    .data(dataPayload)
                    .build();
                return notificationService.sendPushNotification(planning.getOrganizationId(), request, null, null);
            })
            .then();
    }
    
    /**
     * Notifie TOUS les clients de la publication d'un nouveau planning par un chauffeur.
     */
    public Mono<Void> notifyAllClientsOfNewPlanning(Product planning) {
        log.info("Déclenchement des notifications à tous les clients pour le nouveau planning: {}", planning.getName());
        
        UUID templateId = UUID.fromString(dotenv.get("TEMPLATE_PUSH_NEW_PLANNING_ID"));
        
        return clientProfileRepository.findAll()
            .map(client -> client.getUserId())
            .collectList()
            .flatMap(clientIds -> this.sendBroadcastNotification(
                clientIds, 
                templateId, 
                planning.getOrganizationId(), 
                Map.of(
                    "driverName", planning.getClientName(),
                    "destination", planning.getDropoffLocation(),
                    "cost", planning.getDefaultSellPrice() != null ? planning.getDefaultSellPrice().toString() : "0"
                )
            )).then();
    }

    /**
     * Notifie TOUS les chauffeurs de la publication d'une nouvelle annonce par un client.
     */
    public Mono<Void> notifyAllDriversOfNewAnnouncement(Product announcement) {
        log.info("Déclenchement des notifications à tous les chauffeurs pour la nouvelle annonce: {}", announcement.getName());
        
        UUID templateId = UUID.fromString(dotenv.get("TEMPLATE_PUSH_NEW_ANNOUNCEMENT_ID"));
        
        return driverProfileRepository.findAll()
            .map(driver -> driver.getUserId())
            .collectList()
            .flatMap(driverIds -> this.sendBroadcastNotification(
                driverIds, 
                templateId, 
                announcement.getOrganizationId(), 
                Map.of("tripTitle", announcement.getName())
            )).then();
    }
    
    /**
     * Méthode utilitaire privée pour envoyer une notification à une liste d'utilisateurs.
     */
    private Mono<Boolean> sendBroadcastNotification(List<UUID> userIds, UUID templateId, UUID organizationId, Map<String, String> metadata) {
        if (userIds.isEmpty()) {
            log.warn("La liste d'utilisateurs à notifier est vide. Annulation.");
            return Mono.just(true);
        }
        return Flux.fromIterable(userIds)
            .flatMap(deviceTokenRepository::findByUserId)
            .map(DeviceToken::getToken)
            .collect(Collectors.toSet())
            .flatMap(tokens -> {
                if (tokens.isEmpty()) {
                    log.warn("Aucun token d'appareil trouvé pour la liste d'utilisateurs.");
                    return Mono.just(true);
                }
                log.info("Envoi de la notification (template {}) à {} appareils.", templateId, tokens.size());
                NotificationRequest request = NotificationRequest.builder()
                    .templateId(templateId)
                    .recipients(List.copyOf(tokens))
                    .metadata(metadata)
                    .build();
                // Assurez-vous que sendPushNotification peut prendre le dataPayload si nécessaire
                return notificationService.sendPushNotification(organizationId, request, null, null); 
            });
    }
}// END OF FILE: src/main/java/com/freelance/driver_backend/service/NotificationTriggerService.java

//---> PATH: /home/mbogneng-junior/freelance-driver_Sylladb/backend/src/main/java/com/freelance/driver_backend/service/OnboardingService.java

package com.freelance.driver_backend.service;

import com.freelance.driver_backend.dto.external.*;
import com.freelance.driver_backend.dto.onboarding.ClientOnboardingRequest;
import com.freelance.driver_backend.dto.onboarding.DriverOnboardingRequest;
import com.freelance.driver_backend.dto.onboarding.OnboardingResponse;
import com.freelance.driver_backend.dto.UserSessionContextDto; // Importez la nouvelle structure
import com.freelance.driver_backend.model.ClientProfile;
import com.freelance.driver_backend.model.DriverProfile;
import com.freelance.driver_backend.repository.ClientProfileRepository;
import com.freelance.driver_backend.repository.DriverProfileRepository;
import com.freelance.driver_backend.repository.OtpVerificationRepository;
import com.freelance.driver_backend.service.external.AuthService;
import com.freelance.driver_backend.service.external.OrganisationService;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Service;
import reactor.core.publisher.Mono;

import java.time.Instant;
import java.util.Collections;
import java.util.UUID;

@Service
@Slf4j
public class OnboardingService {

    // --- Structures internes pour la clarté ---
    private record AllInfo(LoginResponse.UserInfo user, OrganisationDto organisation, LoginResponse loginResponse) {}

    // --- Dépendances ---
    private final AuthService authService;
    private final OrganisationService organisationService;
    private final DriverProfileRepository driverProfileRepository;
    private final ClientProfileRepository clientProfileRepository;
    private final ProfileService profileService;
    private final OtpVerificationRepository otpVerificationRepository;
    private final String publicKey;
    private final String oauthClientId;
    private final String oauthClientSecret;

    public OnboardingService(
            AuthService authService,
            OrganisationService organisationService,
            DriverProfileRepository driverProfileRepository,
            ClientProfileRepository clientProfileRepository,
            ProfileService profileService,
            OtpVerificationRepository otpVerificationRepository,
            @Value("${freelancedriver.api.public-key}") String publicKey,
            @Value("${freelancedriver.oauth2.client-id}") String oauthClientId,
            @Value("${freelancedriver.oauth2.client-secret}") String oauthClientSecret
    ) {
        this.authService = authService;
        this.organisationService = organisationService;
        this.driverProfileRepository = driverProfileRepository;
        this.clientProfileRepository = clientProfileRepository;
        this.profileService = profileService;
        this.otpVerificationRepository = otpVerificationRepository;
        this.publicKey = publicKey;
        this.oauthClientId = oauthClientId;
        this.oauthClientSecret = oauthClientSecret;
    }

    /**
     * Orchestre la création complète d'un compte Chauffeur (Auth + Organisation + DriverProfile).
     * Utilisé pour la première inscription.
     */
    public Mono<OnboardingResponse> createDriverAccount(DriverOnboardingRequest dto) {
        return verifyOtp(dto.getEmail(), dto.getOtp())
            .then(createAuthUserAndOrganization(dto.getEmail(), dto.getPassword(), dto.getFirstName(), dto.getLastName(), dto.getPhoneNumber(), dto.getCompanyName(), dto.getCompanyDescription()))
            .flatMap(allInfo -> {
                log.info("Étape 5/6 (Driver): Sauvegarde du profil Driver pour l'utilisateur ID: {}", allInfo.user().getId());
                return createDriverProfile(allInfo.user().getId(), allInfo.organisation().getOrganizationId(), dto, allInfo.user())
                    .then(buildFinalResponse(allInfo.loginResponse()));
            });
    }

    /**
     * Orchestre la création complète d'un compte Client (Auth + Organisation + ClientProfile).
     * Utilisé pour la première inscription.
     */
    public Mono<OnboardingResponse> createClientAccount(ClientOnboardingRequest dto) {
        return verifyOtp(dto.getEmail(), dto.getOtp())
            .then(createAuthUserAndOrganization(dto.getEmail(), dto.getPassword(), dto.getFirstName(), dto.getLastName(), dto.getPhoneNumber(), dto.getCompanyName(), dto.getCompanyDescription()))
            .flatMap(allInfo -> {
                log.info("Étape 5/6 (Client): Sauvegarde du profil Client pour l'utilisateur ID: {}", allInfo.user().getId());
                return createClientProfile(allInfo.user().getId(), allInfo.organisation().getOrganizationId(), dto, allInfo.user())
                    .then(buildFinalResponse(allInfo.loginResponse()));
            });
    }

    /**
     * Crée un profil Driver pour un utilisateur **EXISTANT**.
     * Réutilise l'organisation principale de l'utilisateur ou en crée une par défaut si aucune n'existe.
     * @param userId L'ID de l'utilisateur existant.
     * @param dto Les données du profil chauffeur.
     * @param userBearerToken Le token JWT de l'utilisateur.
     * @return Le DriverProfile créé.
     */
    public Mono<DriverProfile> createDriverProfileForExistingUser(UUID userId, DriverOnboardingRequest dto, String userBearerToken) {
        log.info("Création du profil Driver pour un utilisateur existant: {}", userId);
        // Récupérer le contexte utilisateur existant pour trouver l'organisation ID
        return profileService.getUserSessionContext(userId, userBearerToken, publicKey)
            .flatMap(context -> {
                UUID organizationId = context.getOrganisation() != null ? context.getOrganisation().getOrganizationId() : null;
                if (organizationId == null) {
                    log.warn("L'utilisateur {} n'a pas d'organisation existante. Création d'une organisation par défaut pour le nouveau profil chauffeur.", userId);
                    OrganisationCreationRequest orgRequest = OrganisationCreationRequest.builder()
                        .longName(dto.getFirstName() + " " + dto.getLastName() + "'s Driving Services")
                        .email(dto.getEmail()) // Utiliser l'email du DTO pour l'organisation
                        .build();
                    // Nécessite un token M2M pour appeler le service d'organisation
                    return authService.getClientCredentialsToken(oauthClientId, oauthClientSecret)
                        .flatMap(m2mToken -> organisationService.createOrganisation(orgRequest, "Bearer " + m2mToken.getAccessToken(), publicKey))
                        .map(OrganisationDto::getOrganizationId);
                }
                return Mono.just(organizationId);
            })
            .flatMap(orgId -> {
                // Créer un UserInfo factice pour la création de profil, car l'utilisateur existe déjà
                LoginResponse.UserInfo dummyUser = new LoginResponse.UserInfo();
                dummyUser.setId(userId);
                dummyUser.setFirstName(dto.getFirstName());
                dummyUser.setLastName(dto.getLastName());
                dummyUser.setPhoneNumber(dto.getPhoneNumber()); // Utiliser le numéro du DTO
                dummyUser.setEmail(dto.getEmail());

                return createDriverProfile(userId, orgId, dto, dummyUser);
            });
    }

    /**
     * Crée un profil Client pour un utilisateur **EXISTANT**.
     * Réutilise l'organisation principale de l'utilisateur ou en crée une par défaut si aucune n'existe.
     * @param userId L'ID de l'utilisateur existant.
     * @param dto Les données du profil client.
     * @param userBearerToken Le token JWT de l'utilisateur.
     * @return Le ClientProfile créé.
     */
    public Mono<ClientProfile> createClientProfileForExistingUser(UUID userId, ClientOnboardingRequest dto, String userBearerToken) {
        log.info("Création du profil Client pour un utilisateur existant: {}", userId);
        return profileService.getUserSessionContext(userId, userBearerToken, publicKey)
            .flatMap(context -> {
                UUID organizationId = context.getOrganisation() != null ? context.getOrganisation().getOrganizationId() : null;
                if (organizationId == null) {
                     log.warn("L'utilisateur {} n'a pas d'organisation existante. Création d'une organisation par défaut pour le nouveau profil client.", userId);
                    OrganisationCreationRequest orgRequest = OrganisationCreationRequest.builder()
                        .longName(dto.getCompanyName().isEmpty() ? (dto.getFirstName() + " " + dto.getLastName() + "'s Client Account") : dto.getCompanyName())
                        .email(dto.getEmail()) // Utiliser l'email du DTO pour l'organisation
                        .build();
                     return authService.getClientCredentialsToken(oauthClientId, oauthClientSecret)
                        .flatMap(m2mToken -> organisationService.createOrganisation(orgRequest, "Bearer " + m2mToken.getAccessToken(), publicKey))
                        .map(OrganisationDto::getOrganizationId);
                }
                return Mono.just(organizationId);
            })
            .flatMap(orgId -> {
                LoginResponse.UserInfo dummyUser = new LoginResponse.UserInfo();
                dummyUser.setId(userId);
                dummyUser.setFirstName(dto.getFirstName());
                dummyUser.setLastName(dto.getLastName());
                dummyUser.setPhoneNumber(dto.getPhoneNumber()); // Utiliser le numéro du DTO
                dummyUser.setEmail(dto.getEmail());

                return createClientProfile(userId, orgId, dto, dummyUser);
            });
    }


    /**
     * Helper privé pour créer un DriverProfile dans la DB.
     */
    private Mono<DriverProfile> createDriverProfile(UUID userId, UUID organizationId, DriverOnboardingRequest dto, LoginResponse.UserInfo user) {
        DriverProfile profile = new DriverProfile();
        profile.setId(UUID.randomUUID());
        profile.setUserId(userId);
        profile.setOrganisationId(organizationId);
        profile.setFirstName(user.getFirstName());
        profile.setLastName(user.getLastName());
        profile.setPhoneNumber(user.getPhoneNumber());
        profile.setLicenseNumber(dto.getLicenseNumber());
        profile.setVehicleDetails(dto.getVehicleDetails());
        return driverProfileRepository.save(profile);
    }

    /**
     * Helper privé pour créer un ClientProfile dans la DB.
     */
    private Mono<ClientProfile> createClientProfile(UUID userId, UUID organizationId, ClientOnboardingRequest dto, LoginResponse.UserInfo user) {
        ClientProfile profile = new ClientProfile();
        profile.setId(UUID.randomUUID());
        profile.setUserId(userId);
        profile.setOrganisationId(organizationId);
        profile.setFirstName(dto.getFirstName());
        profile.setLastName(dto.getLastName());
        profile.setCompanyName(dto.getCompanyName());
        profile.setContactEmail(dto.getEmail());
        profile.setPhoneNumber(user.getPhoneNumber()); // Utiliser le téléphone de l'utilisateur Auth pour la cohérence
        return clientProfileRepository.save(profile);
    }


    /**
     * Méthode privée pour vérifier la validité d'un OTP. (Inchangée)
     */
    private Mono<Void> verifyOtp(String email, String otp) {
        log.info("▶️ Étape 1/6: Vérification de l'OTP {} pour l'email {}", otp, email);

        return otpVerificationRepository.findById(email)
            .switchIfEmpty(
                Mono.defer(() -> {
                    log.error("❌ Aucune demande de vérification trouvée pour l'email : {}", email);
                    return Mono.error(new IllegalStateException("Aucune demande de vérification trouvée pour cet email."));
                })
            )
            .flatMap(verification -> {
                if (verification.getExpiresAt().isBefore(Instant.now())) {
                    log.warn("❌ Tentative avec un OTP expiré pour {}", email);
                    return otpVerificationRepository.delete(verification)
                        .then(Mono.error(new IllegalStateException("Le code de vérification a expiré.")));
                }
                if (!verification.getOtpCode().equals(otp)) {
                    log.warn("❌ Tentative avec un OTP invalide pour {}", email);
                    return Mono.error(new IllegalStateException("Le code de vérification est invalide."));
                }

                log.info("✅ OTP validé pour {}. Suppression de l'entrée.", email);
                return otpVerificationRepository.delete(verification);
            });
    }

    /**
     * Gère la connexion de l'utilisateur (déjà créé à l'étape /api/register)
     * et la création de son organisation via l'API externe réelle. (Inchangée)
     */

    
    //Version originale
    /*private Mono<AllInfo> createAuthUserAndOrganization(String email, String password, String firstName, String lastName, String phoneNumber, String companyName, String companyDescription) {
        LoginRequest loginRequest = new LoginRequest(email, password);

        return authService.getClientCredentialsToken(oauthClientId, oauthClientSecret)
            .doOnSuccess(tokenResponse -> log.info("Étape 2/6: Token de service M2M obtenu."))
            .flatMap(m2mTokenResponse -> {
                String m2mBearerToken = "Bearer " + m2mTokenResponse.getAccessToken();

                //On commentes l'utilisation de m2mBearerToken
                
                return authService.loginUser(loginRequest, m2mBearerToken)
                    .switchIfEmpty(Mono.error(new RuntimeException("Échec de la connexion de l'utilisateur déjà enregistré pour " + email + ". Vérifiez les identifiants.")))
                    .doOnSuccess(loginResponse -> log.info("Étape 3/6: Connexion de l'utilisateur {} réussie. (ID: {})", loginResponse.getUser().getUsername(), loginResponse.getUser().getId()))
                    .flatMap(loginResponse -> {
                        LoginResponse.UserInfo registeredUser = loginResponse.getUser();
                        String userBearerToken = "Bearer " + loginResponse.getAccessToken().getToken();

                        String finalCompanyName = companyName.trim().isEmpty() ?
                                                    (firstName.trim() + " " + lastName.trim() + "'s Business") :
                                                    companyName.trim();
                        String finalCompanyDescription = companyDescription.trim().isEmpty() ?
                                                    ("Freelance services for " + (finalCompanyName.contains("'s Business") ? firstName : finalCompanyName)) :
                                                    companyDescription.trim();

                        OrganisationCreationRequest orgRequest = OrganisationCreationRequest.builder()
                                .longName(finalCompanyName)
                                .shortName(generateShortName(finalCompanyName))
                                .description(finalCompanyDescription)
                                .email(email)
                                .build();

                        log.info("Étape 4/6: Création de l'organisation pour l'utilisateur {} via l'API externe.", email);
                        return organisationService.createOrganisation(orgRequest, userBearerToken, publicKey)
                            .map(createdOrg -> {
                                log.info("✅ Organisation '{}' (provenance: {}) créée. Données: {}",
                                    createdOrg.getLongName(),
                                    organisationService.getClass().getSimpleName(),
                                    createdOrg);
                                return new AllInfo(registeredUser, createdOrg, loginResponse);
                            });
                    });
            });
    }
    */



    //On commentes l'utilisation de m2mBearerToken

    private Mono<AllInfo> createAuthUserAndOrganization(String email, String password, String firstName, String lastName, String phoneNumber, String companyName, String companyDescription) {
        LoginRequest loginRequest = new LoginRequest(email, password);

                return authService.loginUser(loginRequest, "jdjdjdkdke")
                    .switchIfEmpty(Mono.error(new RuntimeException("Échec de la connexion de l'utilisateur déjà enregistré pour " + email + ". Vérifiez les identifiants.")))
                    .doOnSuccess(loginResponse -> log.info("Étape 3/6: Connexion de l'utilisateur {} réussie. (ID: {})", loginResponse.getUser().getUsername(), loginResponse.getUser().getId()))
                    .flatMap(loginResponse -> {
                        LoginResponse.UserInfo registeredUser = loginResponse.getUser();
                        String userBearerToken = "Bearer " + loginResponse.getAccessToken().getToken();

                        String finalCompanyName = companyName.trim().isEmpty() ?
                                                    (firstName.trim() + " " + lastName.trim() + "'s Business") :
                                                    companyName.trim();
                        String finalCompanyDescription = companyDescription.trim().isEmpty() ?
                                                    ("Freelance services for " + (finalCompanyName.contains("'s Business") ? firstName : finalCompanyName)) :
                                                    companyDescription.trim();

                        OrganisationCreationRequest orgRequest = OrganisationCreationRequest.builder()
                                .longName(finalCompanyName)
                                .shortName(generateShortName(finalCompanyName))
                                .description(finalCompanyDescription)
                                .email(email)
                                .build();

                        log.info("Étape 4/6: Création de l'organisation pour l'utilisateur {} via l'API externe.", email);
                        return organisationService.createOrganisation(orgRequest, userBearerToken, publicKey)
                            .map(createdOrg -> {
                                log.info("✅ Organisation '{}' (provenance: {}) créée. Données: {}",
                                    createdOrg.getLongName(),
                                    organisationService.getClass().getSimpleName(),
                                    createdOrg);
                                return new AllInfo(registeredUser, createdOrg, loginResponse);
                            });
                    });
            
    }
    
    /**
     * Construit la réponse finale à envoyer au frontend. (Inchangée)
     */
    private Mono<OnboardingResponse> buildFinalResponse(LoginResponse loginResponse) {
        UUID userId = loginResponse.getUser().getId();
        String userBearerToken = "Bearer " + loginResponse.getAccessToken().getToken();
        log.info("Étape 6/6: Construction du contexte de session final pour l'utilisateur ID: {}", userId);

        return profileService.getUserSessionContext(userId, userBearerToken, null)
            .map(userContext -> {
                log.info("Backend DEBUG: Final UserContext before sending to frontend. Roles: {}", userContext.getRoles());
                return OnboardingResponse.builder()
                    .token(loginResponse.getAccessToken().getToken())
                    .profile(userContext)
                    .chatSession(null)
                    .build();
            });
    }

    private String generateShortName(String longName) { // (Inchangée)
        if (longName == null || longName.trim().isEmpty()) return "NA";
        String cleanedName = longName.trim();
        StringBuilder initials = new StringBuilder();
        for (String s : cleanedName.split("\\s+")) {
            if (!s.isEmpty()) initials.append(s.charAt(0));
        }
        String shortName = initials.toString().toUpperCase();
        return shortName.length() < 2 ? cleanedName.substring(0, Math.min(cleanedName.length(), 3)).toUpperCase() : shortName;
    }
}// END OF FILE: src/main/java/com/freelance/driver_backend/service/OnboardingService.java

//---> PATH: /home/mbogneng-junior/freelance-driver_Sylladb/backend/src/main/java/com/freelance/driver_backend/service/ProfileService.java



package com.freelance.driver_backend.service;

import com.freelance.driver_backend.dto.UserSessionContextDto;
import com.freelance.driver_backend.dto.external.OrganisationDto;
import com.freelance.driver_backend.model.ClientProfile;
import com.freelance.driver_backend.model.DriverProfile;
import com.freelance.driver_backend.repository.ClientProfileRepository;
import com.freelance.driver_backend.repository.DriverProfileRepository;
import com.freelance.driver_backend.service.external.OrganisationService;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;
import reactor.core.publisher.Mono;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.UUID;
import java.net.URI;
import java.net.URISyntaxException;

@Service
@Slf4j
@RequiredArgsConstructor
public class ProfileService {

    private final DriverProfileRepository driverProfileRepository;
    private final ClientProfileRepository clientProfileRepository;
    private final OrganisationService organisationService;
    private final StorageService storageService;

    public Mono<UserSessionContextDto> getUserSessionContext(UUID userId, String userBearerToken, String publicKey) {
        log.info("ProfileService: Recherche du contexte pour l'utilisateur ID: {}", userId);

        Mono<DriverProfile> driverProfileMono = driverProfileRepository.findByUserId(userId)
                .doOnNext(
                        dp -> log.info("DEBUG_CONTEXT: findByUserId(DRIVER) a retourné un profil. ID: {}", dp.getId()))
                .switchIfEmpty(Mono.defer(() -> {
                    log.warn("DEBUG_CONTEXT: findByUserId(DRIVER) a retourné vide. Retourne DriverProfile vide.");
                    return Mono.just(new DriverProfile());
                }));

        Mono<ClientProfile> clientProfileMono = clientProfileRepository.findByUserId(userId)
                .doOnNext(
                        cp -> log.info("DEBUG_CONTEXT: findByUserId(CLIENT) a retourné un profil. ID: {}", cp.getId()))
                .switchIfEmpty(Mono.defer(() -> {
                    log.warn("DEBUG_CONTEXT: findByUserId(CLIENT) a retourné vide. Retourne ClientProfile vide.");
                    return Mono.just(new ClientProfile());
                }));

        return Mono.zip(driverProfileMono, clientProfileMono)
                .flatMap(tuple -> {
                    DriverProfile driverProfile = tuple.getT1();
                    ClientProfile clientProfile = tuple.getT2();

                    List<UserSessionContextDto.UserRole> roles = new ArrayList<>();
                    OrganisationDto primaryOrganisation = null;

                    log.info("DEBUG_CONTEXT: driverProfile.getId() obtenu dans tuple: {}", driverProfile.getId());
                    log.info("DEBUG_CONTEXT: clientProfile.getId() obtenu dans tuple: {}", clientProfile.getId());

                    if (driverProfile != null && driverProfile.getId() != null) {
                        roles.add(UserSessionContextDto.UserRole.DRIVER);
                        if (driverProfile.getOrganisationId() != null) {
                            primaryOrganisation = createMockOrganisationDto(driverProfile.getOrganisationId(),
                                    driverProfile.getFirstName() + "'s Driving Business");
                        }
                    }
                    if (clientProfile != null && clientProfile.getId() != null) {
                        roles.add(UserSessionContextDto.UserRole.CLIENT);
                        if (primaryOrganisation == null && clientProfile.getOrganisationId() != null) {
                            primaryOrganisation = createMockOrganisationDto(clientProfile.getOrganisationId(),
                                    clientProfile.getCompanyName());
                        }
                    }

                    if (roles.isEmpty()) {
                        roles.add(UserSessionContextDto.UserRole.NO_PROFILE);
                        log.warn(
                                "ProfileService: Aucun profil (driver ou client) trouvé pour l'utilisateur {}. Renvoi du statut NO_PROFILE.",
                                userId);
                    } else {
                        log.info("ProfileService: Profil(s) trouvé(s) pour l'utilisateur {}. Rôles: {}", userId, roles);
                    }

                    return Mono.just(UserSessionContextDto.builder()
                            .userId(userId)
                            .roles(roles)
                            .driverProfile(
                                    driverProfile != null && driverProfile.getId() != null ? driverProfile : null)
                            .clientProfile(
                                    clientProfile != null && clientProfile.getId() != null ? clientProfile : null)
                            .organisation(primaryOrganisation)
                            .build());
                });
    }

    private OrganisationDto createMockOrganisationDto(UUID orgId, String name) {
        OrganisationDto orgDto = new OrganisationDto();
        orgDto.setOrganizationId(orgId);
        orgDto.setLongName(name);
        orgDto.setStatus("ACTIVE");
        return orgDto;
    }

    public Mono<UUID> findOrganisationIdByUserId(UUID userId) {
        log.info("Recherche de l'ID d'organisation pour l'utilisateur ID: {}", userId);
        return driverProfileRepository.findByUserId(userId)
                .map(DriverProfile::getOrganisationId)
                .switchIfEmpty(Mono.defer(() -> clientProfileRepository.findByUserId(userId)
                        .map(ClientProfile::getOrganisationId)))
                .switchIfEmpty(Mono.error(new RuntimeException(
                        "Aucun profil (conducteur ou client) trouvé pour l'utilisateur " + userId)));
    }

    public Mono<DriverProfile> findDriverById(UUID driverId) {
        log.info("Recherche du profil pour le chauffeur ID: {}", driverId);
        return driverProfileRepository.findByUserId(driverId)
                .doOnNext(dp -> log.info("✅ Profil DRIVER trouvé par findDriverById pour userId: {}. Détails: {}",
                        driverId, dp))
                .doOnError(e -> log.error("❌ Erreur lors de la recherche du profil DRIVER pour userId {}: {}", driverId,
                        e.getMessage()))
                .switchIfEmpty(Mono.defer(() -> {
                    log.warn("⚠️ Aucun profil DRIVER trouvé par findDriverById pour userId: {}. (Mono.empty)",
                            driverId);
                    return Mono.empty();
                }));
    }

    public Mono<ClientProfile> findClientById(UUID clientId) {
        log.info("Recherche du profil pour le client ID: {}", clientId);
        return clientProfileRepository.findByUserId(clientId)
                .doOnNext(cp -> log.info("✅ Profil CLIENT trouvé par findClientById pour userId: {}. Détails: {}",
                        clientId, cp))
                .doOnError(e -> log.error("❌ Erreur lors de la recherche du profil CLIENT pour userId {}: {}", clientId,
                        e.getMessage()))
                .switchIfEmpty(Mono.defer(() -> {
                    log.warn("⚠️ Aucun profil CLIENT trouvé par findClientById pour userId: {}. (Mono.empty)",
                            clientId);
                    return Mono.empty();
                }));
    }

    // --- LOGIQUE DE MISE À JOUR POUR LES CHAMPS COMMUNS ---
    private <T extends DriverProfile> Mono<T> updateCommonDriverFields(T existingProfile, DriverProfile updatedData) {
        if (updatedData.getFirstName() != null)
            existingProfile.setFirstName(updatedData.getFirstName());
        if (updatedData.getLastName() != null)
            existingProfile.setLastName(updatedData.getLastName());
        if (updatedData.getPhoneNumber() != null)
            existingProfile.setPhoneNumber(updatedData.getPhoneNumber());
        if (updatedData.getNickname() != null)
            existingProfile.setNickname(updatedData.getNickname());
        if (updatedData.getBirthDate() != null)
            existingProfile.setBirthDate(updatedData.getBirthDate());
        if (updatedData.getNationality() != null)
            existingProfile.setNationality(updatedData.getNationality());
        if (updatedData.getGender() != null)
            existingProfile.setGender(updatedData.getGender());
        if (updatedData.getLanguage() != null)
            existingProfile.setLanguage(updatedData.getLanguage());
        // Note: profileImageUrl est géré par updateAvatarUrl, pas ici directement.
        return Mono.just(existingProfile);
    }

    private <T extends ClientProfile> Mono<T> updateCommonClientFields(T existingProfile, ClientProfile updatedData) {
        if (updatedData.getFirstName() != null)
            existingProfile.setFirstName(updatedData.getFirstName());
        if (updatedData.getLastName() != null)
            existingProfile.setLastName(updatedData.getLastName());
        if (updatedData.getPhoneNumber() != null)
            existingProfile.setPhoneNumber(updatedData.getPhoneNumber());
        if (updatedData.getNickname() != null)
            existingProfile.setNickname(updatedData.getNickname());
        if (updatedData.getBirthDate() != null)
            existingProfile.setBirthDate(updatedData.getBirthDate());
        if (updatedData.getNationality() != null)
            existingProfile.setNationality(updatedData.getNationality());
        if (updatedData.getGender() != null)
            existingProfile.setGender(updatedData.getGender());
        if (updatedData.getLanguage() != null)
            existingProfile.setLanguage(updatedData.getLanguage());
        // Note: profileImageUrl est géré par updateAvatarUrl, pas ici directement.
        // contactEmail, companyName sont spécifiques au Client, et déjà gérés dans
        // updateClientProfile
        return Mono.just(existingProfile);
    }

    public Mono<UserSessionContextDto> updateDriverProfile(UUID userId, DriverProfile updatedData) {
        return driverProfileRepository.findByUserId(userId)
                .flatMap(existingDriverProfile -> {
                    log.info("Mise à jour du profil DRIVER pour l'utilisateur ID: {}", userId);

                    // 1. Mettre à jour les champs communs dans le DriverProfile existant
                    // Puis mettre à jour les champs spécifiques au Driver
                    return updateCommonDriverFields(existingDriverProfile, updatedData)
                            .flatMap(profile -> {
                                if (updatedData.getBiography() != null)
                                    profile.setBiography(updatedData.getBiography());
                                if (updatedData.getVehicleDetails() != null)
                                    profile.setVehicleDetails(updatedData.getVehicleDetails());
                                if (updatedData.getLicenseNumber() != null)
                                    profile.setLicenseNumber(updatedData.getLicenseNumber());
                                return driverProfileRepository.save(profile)
                                        .doOnSuccess(
                                                dp -> log.info("✅ DriverProfile mis à jour pour userId: {}", userId))
                                        .doOnError(e -> log.error(
                                                "❌ Échec de la mise à jour du DriverProfile pour userId {}: {}", userId,
                                                e.getMessage()));
                            })
                            // 2. Synchroniser les champs communs vers le ClientProfile (s'il existe)
                            .then(clientProfileRepository.findByUserId(userId)
                                    .flatMap(existingClientProfile -> updateCommonClientFields(existingClientProfile,
                                            new ClientProfile() {
                                                { // Crée un ClientProfile "factice" avec les données de updatedData
                                                  // pour la synchronisation
                                                    setFirstName(updatedData.getFirstName());
                                                    setLastName(updatedData.getLastName());
                                                    setPhoneNumber(updatedData.getPhoneNumber());
                                                    setNickname(updatedData.getNickname());
                                                    setBirthDate(updatedData.getBirthDate());
                                                    setNationality(updatedData.getNationality());
                                                    setGender(updatedData.getGender());
                                                    setLanguage(updatedData.getLanguage());
                                                }
                                            })
                                            .flatMap(profile -> clientProfileRepository.save(profile))
                                            .doOnSuccess(cp -> log.info(
                                                    "✅ ClientProfile synchronisé depuis DriverProfile pour userId: {}",
                                                    userId))
                                            .doOnError(e -> log.error(
                                                    "❌ Échec de la synchronisation du ClientProfile depuis DriverProfile pour userId {}: {}",
                                                    userId, e.getMessage())))
                                    .then() // Transformer en Mono<Void>
                                    .switchIfEmpty(Mono.defer(() -> {
                                        log.info("Pas de ClientProfile à synchroniser pour l'utilisateur {}.", userId);
                                        return Mono.empty();
                                    })))
                            // 3. Après toutes les mises à jour, récupérer le contexte complet
                            .then(Mono.defer(() -> getUserSessionContext(userId, null, null)));
                })
                .switchIfEmpty(Mono.defer(() -> { // Gérer le cas où aucun DriverProfile n'est trouvé
                    log.warn("Tentative de mise à jour DriverProfile pour userId {} mais aucun DriverProfile trouvé.",
                            userId);
                    return Mono
                            .error(new IllegalStateException("DriverProfile non trouvé pour l'utilisateur " + userId));
                }));
    }

    public Mono<UserSessionContextDto> updateClientProfile(UUID userId, ClientProfile updatedData) { // Changement du
                                                                                                     // type de retour
        return clientProfileRepository.findByUserId(userId)
                .flatMap(existingClientProfile -> {
                    log.info("Mise à jour du profil CLIENT pour l'utilisateur ID: {}", userId);

                    // 1. Mettre à jour les champs communs dans le ClientProfile existant
                    // Puis mettre à jour les champs spécifiques au Client
                    return updateCommonClientFields(existingClientProfile, updatedData)
                            .flatMap(profile -> {
                                if (updatedData.getCompanyName() != null)
                                    profile.setCompanyName(updatedData.getCompanyName());
                                if (updatedData.getContactEmail() != null)
                                    profile.setContactEmail(updatedData.getContactEmail());
                                return clientProfileRepository.save(profile)
                                        .doOnSuccess(
                                                cp -> log.info("✅ ClientProfile mis à jour pour userId: {}", userId))
                                        .doOnError(e -> log.error(
                                                "❌ Échec de la mise à jour du ClientProfile pour userId {}: {}", userId,
                                                e.getMessage()));
                            })
                            // 2. Synchroniser les champs communs vers le DriverProfile (s'il existe)
                            .then(driverProfileRepository.findByUserId(userId)
                                    .flatMap(existingDriverProfile -> updateCommonDriverFields(existingDriverProfile,
                                            new DriverProfile() {
                                                { // Crée un DriverProfile "factice" avec les données de updatedData
                                                  // pour la synchronisation
                                                    setFirstName(updatedData.getFirstName());
                                                    setLastName(updatedData.getLastName());
                                                    setPhoneNumber(updatedData.getPhoneNumber());
                                                    setNickname(updatedData.getNickname());
                                                    setBirthDate(updatedData.getBirthDate());
                                                    setNationality(updatedData.getNationality());
                                                    setGender(updatedData.getGender());
                                                    setLanguage(updatedData.getLanguage());
                                                }
                                            })
                                            .flatMap(profile -> driverProfileRepository.save(profile))
                                            .doOnSuccess(dp -> log.info(
                                                    "✅ DriverProfile synchronisé depuis ClientProfile pour userId: {}",
                                                    userId))
                                            .doOnError(e -> log.error(
                                                    "❌ Échec de la synchronisation du DriverProfile depuis ClientProfile pour userId {}: {}",
                                                    userId, e.getMessage())))
                                    .then() // Transformer en Mono<Void>
                                    .switchIfEmpty(Mono.defer(() -> {
                                        log.info("Pas de DriverProfile à synchroniser pour l'utilisateur {}.", userId);
                                        return Mono.empty();
                                    })))
                            // 3. Après toutes les mises à jour, récupérer le contexte complet
                            .then(Mono.defer(() -> getUserSessionContext(userId, null, null)));
                })
                .switchIfEmpty(Mono.defer(() -> { // Gérer le cas où aucun ClientProfile n'est trouvé
                    log.warn("Tentative de mise à jour ClientProfile pour userId {} mais aucun ClientProfile trouvé.",
                            userId);
                    return Mono
                            .error(new IllegalStateException("ClientProfile non trouvé pour l'utilisateur " + userId));
                }));
    }

    /**
     * Met à jour l'URL de l'avatar pour TOUS les profils (Driver et Client) de
     * l'utilisateur spécifié,
     * S'ILS EXISTENT.
     * Si un ancien avatar existe (sur n'importe quel profil), il est supprimé du
     * stockage externe.
     *
     * @param userId       L'ID de l'utilisateur.
     * @param newAvatarUrl L'URL publique du nouvel avatar.
     * @return Un Mono<UserSessionContextDto> contenant le contexte mis à jour de
     *         l'utilisateur.
     */
    public Mono<UserSessionContextDto> updateAvatarUrl(UUID userId, String newAvatarUrl) {
        // Étape 1: Déterminer l'ancienne URI de l'avatar pour la suppression (peut
        // provenir de n'importe quel profil)
        Mono<Void> deleteOldAvatarAction = findProfileByUserId(userId) // Obtient le premier profil trouvé
                .flatMap(profile -> {
                    String oldUrl = getAvatarUrlFromProfile(profile);
                    if (oldUrl != null && !oldUrl.isEmpty() && !oldUrl.equals(newAvatarUrl)) {
                        log.info("Ancien avatar trouvé pour suppression : {}", oldUrl);
                        String oldUri = extractUriFromUrl(oldUrl); // Assurez-vous que oldUri est le bon chemin pour la
                                                                   // suppression
                        if (oldUri != null) {
                            return storageService.deleteFile(oldUri)
                                    .onErrorResume(e -> {
                                        log.error("Échec de la suppression de l'ancien avatar {}: {}", oldUri,
                                                e.getMessage());
                                        return Mono.empty(); // Ne pas bloquer la mise à jour si la suppression échoue
                                    });
                        }
                    }
                    return Mono.empty(); // Pas d'ancien avatar ou le même avatar, pas de suppression nécessaire
                })
                .then(); // Attendre la fin de l'action de suppression (peut être vide)

        // Étape 2: Mettre à jour le DriverProfile (s'il existe)
        Mono<Void> updateDriverAvatarMono = driverProfileRepository.findByUserId(userId)
                .flatMap(driverProfile -> {
                    driverProfile.setProfileImageUrl(newAvatarUrl);
                    return driverProfileRepository.save(driverProfile)
                            .doOnSuccess(dp -> log.info("✅ DriverProfile.profileImageUrl mis à jour pour userId: {}",
                                    userId))
                            .doOnError(e -> log.error(
                                    "❌ Échec de la mise à jour DriverProfile.profileImageUrl pour userId {}: {}",
                                    userId, e.getMessage()))
                            .then(); // Transformer en Mono<Void>
                })
                .switchIfEmpty(Mono.defer(() -> { // S'il n'y a pas de DriverProfile, renvoyer un Mono<Void> vide
                    log.info(
                            "Pas de DriverProfile trouvé pour l'utilisateur {}. Pas de mise à jour de l'avatar Driver.",
                            userId);
                    return Mono.empty();
                }));

        // Étape 3: Mettre à jour le ClientProfile (s'il existe)
        Mono<Void> updateClientAvatarMono = clientProfileRepository.findByUserId(userId)
                .flatMap(clientProfile -> {
                    clientProfile.setProfileImageUrl(newAvatarUrl);
                    return clientProfileRepository.save(clientProfile)
                            .doOnSuccess(cp -> log.info("✅ ClientProfile.profileImageUrl mis à jour pour userId: {}",
                                    userId))
                            .doOnError(e -> log.error(
                                    "❌ Échec de la mise à jour ClientProfile.profileImageUrl pour userId {}: {}",
                                    userId, e.getMessage()))
                            .then(); // Transformer en Mono<Void>
                })
                .switchIfEmpty(Mono.defer(() -> { // S'il n'y a pas de ClientProfile, renvoyer un Mono<Void> vide
                    log.info(
                            "Pas de ClientProfile trouvé pour l'utilisateur {}. Pas de mise à jour de l'avatar Client.",
                            userId);
                    return Mono.empty();
                }));

        // Étape 4: Exécuter la suppression et les mises à jour de profils en parallèle
        // Puis, récupérer le contexte complet
        return deleteOldAvatarAction
                .then(Mono.when(updateDriverAvatarMono, updateClientAvatarMono)) // Exécute les deux mises à jour en
                                                                                 // parallèle
                .then(Mono.defer(() -> { // Utilise Mono.defer pour s'assurer que getUserSessionContext est appelé après
                                         // les mises à jour
                    log.info(
                            "✅ Avatar mis à jour pour l'utilisateur ID: {}. Récupération du contexte de session mis à jour.",
                            userId);
                    return getUserSessionContext(userId, null, null); // userBearerToken et publicKey ne sont pas
                                                                      // nécessaires pour getUserSessionContext si les
                                                                      // appels sous-jacents gèrent leur propre auth (ou
                                                                      // mock)
                }))
                .switchIfEmpty(Mono.error(new IllegalStateException(
                        "Aucun profil (Driver ou Client) trouvé ou mis à jour pour l'utilisateur ID: " + userId)))
                .doOnError(e -> log.error("❌ Erreur finale dans updateAvatarUrl pour userId {}: {}", userId,
                        e.getMessage()));
    }

    public String extractUriFromUrl(String fullUrl) {
        try {
            URI uri = new URI(fullUrl);
            String path = uri.getPath();

            String mediaServiceSegment = "/media-service";
            int servicePathIndex = path.indexOf(mediaServiceSegment);
            if (servicePathIndex != -1) {
                return path.substring(servicePathIndex + mediaServiceSegment.length());
            } else {
                log.warn(
                        "L'URL '{}' ne semble pas provenir du service de médias externe. La suppression ne sera pas tentée via l'API externe.",
                        fullUrl);
                return null;
            }
        } catch (URISyntaxException e) {
            log.error("URL invalide, impossible d'extraire l'URI: {}", fullUrl, e);
            return null;
        }
    }

    public Mono<Object> findProfileByUserId(UUID userId) {
        return driverProfileRepository.findByUserId(userId)
                .cast(Object.class)
                .switchIfEmpty(Mono.defer(() -> clientProfileRepository.findByUserId(userId).cast(Object.class)));
    }

    public String getAuthorFirstNameFromProfile(Object profile) {
        if (profile instanceof DriverProfile) {
            return ((DriverProfile) profile).getFirstName();
        } else if (profile instanceof ClientProfile) {
            return ((ClientProfile) profile).getFirstName();
        }
        return "Utilisateur";
    }

    public String getAuthorLastNameFromProfile(Object profile) {
        if (profile instanceof DriverProfile) {
            return ((DriverProfile) profile).getLastName();
        } else if (profile instanceof ClientProfile) {
            return ((ClientProfile) profile).getLastName();
        }
        return "Anonyme";
    }

    public String getAvatarUrlFromProfile(Object profile) {
        if (profile instanceof DriverProfile) {
            return ((DriverProfile) profile).getProfileImageUrl();
        } else if (profile instanceof ClientProfile) {
            return ((ClientProfile) profile).getProfileImageUrl();
        }
        return null;
    }

    /**
     * Met à jour l'URL de l'avatar pour TOUS les profils (Driver et Client) de
     * l'utilisateur spécifié,
     * S'ILS EXISTENT.
     * Si un ancien avatar existe (sur n'importe quel profil), il est supprimé du
     * stockage externe.
     *
     * @param userId       L'ID de l'utilisateur.
     * @param newAvatarUrl L'URL publique du nouvel avatar.
     * @return Un Mono<UserSessionContextDto> contenant le contexte mis à jour de
     *         l'utilisateur.
     */

}// END OF FILE: src/main/java/com/freelance/driver_backend/service/ProfileService.java

//---> PATH: /home/mbogneng-junior/freelance-driver_Sylladb/backend/src/main/java/com/freelance/driver_backend/service/resource/MockResourceServiceImpl.java

package com.freelance.driver_backend.service.resource;

import com.freelance.driver_backend.model.Resource;
import com.freelance.driver_backend.model.ResourceKey;
import com.freelance.driver_backend.repository.ClientProfileRepository;
import com.freelance.driver_backend.repository.ResourceRepository;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.context.annotation.Profile;
import org.springframework.stereotype.Service;
import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;
import java.time.Instant;
import java.util.Map;
import java.util.UUID;


@Service
@RequiredArgsConstructor
@Slf4j
public class MockResourceServiceImpl implements ResourceService {

    private final ResourceRepository resourceRepository;
     private final ClientProfileRepository clientProfileRepository; 

     @Override
     public Mono<Resource> createResource(Resource resourceFromController) {
         log.warn("[MOCK] Creating new resource. Data received from controller: {}", resourceFromController.getName());
         
         // ==============================================================================
         //                         LA CORRECTION FINALE EST ICI
         // ==============================================================================
         // On s'assure de copier TOUS les champs pertinents de l'objet reçu du contrôleur
         // avant de le sauvegarder.
         
         Resource resourceToSave = new Resource();
         
         // Copie de la clé et des IDs
         resourceToSave.setKey(resourceFromController.getKey());
         
         // Copie des champs principaux
         resourceToSave.setName(resourceFromController.getName());
         resourceToSave.setStorageCondition(resourceFromController.getStorageCondition());
         resourceToSave.setLongDescription(resourceFromController.getLongDescription());
         resourceToSave.setShortDescription(resourceFromController.getShortDescription());
         resourceToSave.setBasePrice(resourceFromController.getBasePrice());
         resourceToSave.setSkuCode(resourceFromController.getSkuCode());
         resourceToSave.setExpiresAt(resourceFromController.getExpiresAt());
 
         // Copie des métadonnées (LE PLUS IMPORTANT)
         resourceToSave.setMetadata(resourceFromController.getMetadata());
 
         // Logique du Mock : on force le statut à "publiée"
         resourceToSave.setState("AVAILABLE");
         log.warn("[MOCK] Forcing resource state to 'AVAILABLE'.");
         
         // Timestamps
         resourceToSave.setCreatedAt(Instant.now());
         resourceToSave.setUpdatedAt(Instant.now());
 
         log.warn("[MOCK] Final object being saved to DB: {}", resourceToSave);
         
         return resourceRepository.save(resourceToSave);
     }
 

    // Le reste des méthodes est inchangé et fonctionnera correctement
    // car le service lira depuis la même base de données "mock" (Cassandra/ScyllaDB en l'occurrence).
    
   
    @Override
    public Flux<Resource> getResourcesByCategory(String categoryId) {
        log.warn("[MOCK] Fetching all resources for category {} and starting enrichment process.", categoryId);
        return resourceRepository.findByKeyCategoryId(categoryId)
                .flatMap(this::enrichResourceWithClientDetails);
    }
    
    private Mono<Resource> enrichResourceWithClientDetails(Resource resource) {
        if (resource.getMetadata() == null || resource.getMetadata().get("clientId") == null) {
            log.warn("!!!! [ENRICH] Annonce ID {} - ÉCHEC : Pas de clientId dans les métadonnées.", resource.getResourceId());
            return Mono.just(resource);
        }

        try {
            String clientIdStr = resource.getMetadata().get("clientId");
            UUID clientId = UUID.fromString(clientIdStr);
            log.info(">>>> [ENRICH] Annonce ID {} - Trouvé clientId : {}. Recherche du profil client...", resource.getResourceId(), clientId);
            
            // On cherche le profil et on loggue ce qu'on trouve (ou pas)
            return clientProfileRepository.findByUserId(clientId)
                .flatMap(clientProfile -> {
                    // ==============================================================================
                    //                         LOG DE VÉRIFICATION
                    // ==============================================================================
                    log.info(">>>> [ENRICH] Annonce ID {} - SUCCÈS : Profil trouvé pour clientId {}. Numéro de téléphone en BDD : '{}'", resource.getResourceId(), clientId, clientProfile.getPhoneNumber());
                    // ==============================================================================
                    
                    Map<String, String> metadata = resource.getMetadata();
                    metadata.put("clientName", clientProfile.getCompanyName());
                    metadata.put("clientPhoneNumber", clientProfile.getPhoneNumber());
                    resource.setMetadata(metadata);
                    return Mono.just(resource);
                })
                // Ce bloc est exécuté si `findByUserId` ne trouve RIEN
                .defaultIfEmpty(resource)
                .doOnSuccess(result -> {
                    // Ce log s'exécutera que le profil soit trouvé ou non.
                    // Il nous montrera si le numéro a été ajouté.
                    if (result.getMetadata().get("clientPhoneNumber") == null || result.getMetadata().get("clientPhoneNumber").isEmpty()) {
                        log.warn("!!!! [ENRICH] Annonce ID {} - FIN : Enrichissement terminé, MAIS le numéro de téléphone est TOUJOURS manquant. Le profil n'a probablement pas été trouvé en BDD.", resource.getResourceId());
                    }
                });

        } catch (IllegalArgumentException e) {
            log.error("!!!! [ENRICH] Le clientId '{}' pour l'annonce {} n'est pas un UUID valide.", resource.getMetadata().get("clientId"), resource.getResourceId());
            return Mono.just(resource);
        }
    }
    // On fait de même pour la recherche par organisation
    @Override
    public Flux<Resource> getResourcesByOrganisationAndCategory(UUID organisationId, String categoryId) {
        log.warn("[MOCK] Fetching resources for org {} and category {} and ENRICHING them.", organisationId, categoryId);
        return resourceRepository.findByKeyOrganizationIdAndKeyCategoryId(organisationId, categoryId)
                .flatMap(this::enrichResourceWithClientDetails);
    }

    /**
     * Méthode privée (copiée du contrôleur) pour enrichir une ressource.
     * C'est maintenant le RÔLE du service de le faire.
     */
    


    @Override
    public Mono<Resource> getResourceById(ResourceKey key) {
        log.warn("[MOCK] Fetching resource by composite key: {}", key);
        return resourceRepository.findById(key);
    }

    @Override
    public Mono<Resource> updateResource(ResourceKey key, Resource updatedResource) {
        log.warn("[MOCK] Updating resource with key: {}", key);
        return resourceRepository.findById(key)
                .flatMap(existingResource -> {
                    existingResource.setName(updatedResource.getName());
                    // ... mettez à jour les autres champs si nécessaire
                    existingResource.setState(updatedResource.getState());
                    existingResource.setUpdatedAt(Instant.now());
                    return resourceRepository.save(existingResource);
                });
    }

    @Override
    public Mono<Void> deleteResource(ResourceKey key) {
        log.warn("[MOCK] Deleting resource with key: {}", key);
        return resourceRepository.deleteById(key);
    }
}// END OF FILE: src/main/java/com/freelance/driver_backend/service/resource/MockResourceServiceImpl.java

//---> PATH: /home/mbogneng-junior/freelance-driver_Sylladb/backend/src/main/java/com/freelance/driver_backend/service/resource/ResourceService.java

package com.freelance.driver_backend.service.resource;

import com.freelance.driver_backend.model.Resource;
import com.freelance.driver_backend.model.ResourceKey; // <-- Nouvel import
import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;
import java.util.UUID;

public interface ResourceService {

    // Ces méthodes ne changent pas car elles filtrent sur des listes
    Flux<Resource> getResourcesByOrganisationAndCategory(UUID organisationId, String categoryId);
    Flux<Resource> getResourcesByCategory(String categoryId);

    // Cette méthode ne change pas car elle ne concerne que la création
    Mono<Resource> createResource(Resource resource);

    // --- MODIFICATIONS ICI ---
    // Pour trouver, mettre à jour ou supprimer une ressource spécifique, on a besoin de sa clé complète
    Mono<Resource> getResourceById(ResourceKey key);
    Mono<Resource> updateResource(ResourceKey key, Resource resource);
    Mono<Void> deleteResource(ResourceKey key);
}// END OF FILE: src/main/java/com/freelance/driver_backend/service/resource/ResourceService.java

//---> PATH: /home/mbogneng-junior/freelance-driver_Sylladb/backend/src/main/java/com/freelance/driver_backend/service/ResourceService.java

package com.freelance.driver_backend.service;

import com.freelance.driver_backend.dto.CreateProductRequest;
import com.freelance.driver_backend.model.Product;
import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;
import java.util.UUID;

public interface ResourceService {
    Mono<Product> createProduct(UUID organizationId, CreateProductRequest request, String bearerToken, String publicKey);
    Flux<Product> getProductsByCategory(UUID organizationId, UUID categoryId, String bearerToken, String publicKey);
    Mono<Product> updateProduct(UUID organizationId, UUID productId, CreateProductRequest request, String bearerToken, String publicKey);
    Mono<Void> deleteProduct(UUID organizationId, UUID productId, String bearerToken, String publicKey);
}// END OF FILE: src/main/java/com/freelance/driver_backend/service/ResourceService.java

//---> PATH: /home/mbogneng-junior/freelance-driver_Sylladb/backend/src/main/java/com/freelance/driver_backend/service/SocketIOService.java

// src/main/java/com/freelance/driver_backend/service/SocketIOService.java

package com.freelance.driver_backend.service;

import com.corundumstudio.socketio.SocketIOServer;
import jakarta.annotation.PostConstruct;
import jakarta.annotation.PreDestroy;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;

@Service
@Slf4j
@RequiredArgsConstructor
public class SocketIOService {

    private final SocketIOServer server;

    // Cette méthode est appelée automatiquement par Spring après la création du bean.
    @PostConstruct
    private void startServer() {
        server.start();
        log.info("✅ Serveur Socket.IO démarré sur le port {}.", server.getConfiguration().getPort());
    }

    // Cette méthode est appelée lorsque l'application s'arrête.
    @PreDestroy
    private void stopServer() {
        server.stop();
        log.info("🛑 Serveur Socket.IO arrêté.");
    }
    
    // Vous pouvez ajouter ici des méthodes pour envoyer des événements si vous le souhaitez,
    // mais il est souvent plus simple d'injecter directement le SocketIOServer dans les contrôleurs.
}// END OF FILE: src/main/java/com/freelance/driver_backend/service/SocketIOService.java

//---> PATH: /home/mbogneng-junior/freelance-driver_Sylladb/backend/src/main/java/com/freelance/driver_backend/service/StorageService.java

package com.freelance.driver_backend.service;

import com.freelance.driver_backend.dto.external.UploadMediaResponse;
import org.springframework.http.codec.multipart.FilePart;
import reactor.core.publisher.Mono;
import java.util.UUID;

/**
 * Interface définissant les opérations pour un service de stockage de fichiers.
 */
public interface StorageService {

    /**
     * Sauvegarde un fichier et renvoie la réponse complète du service de médias, y compris son URL publique et son URI interne.
     * Le service gérera l'obtention de son propre token d'authentification M2M.
     *
     * @param serviceContext     Le contexte de service pour l'API externe (ex: "product", "resource").
     * @param frontendLogicalType Le type logique du frontend (ex: "avatars", "vehicles", "documents").
     * @param uploaderUserId     L'ID de l'utilisateur qui téléverse le fichier (utilisé pour la structuration du chemin).
     * @param targetResourceId   L'ID de la ressource à laquelle ce fichier est associé (ex: l'ID de l'utilisateur, l'ID du véhicule).
     * @param originalFileName   Le nom de fichier original.
     * @param file               Le fichier à sauvegarder.
     * @return Un Mono contenant l'objet UploadMediaResponse avec l'URL publique et l'URI interne du fichier sauvegardé.
     */
    Mono<UploadMediaResponse> saveFile(String serviceContext, String frontendLogicalType, UUID uploaderUserId, UUID targetResourceId, String originalFileName, FilePart file);

    /**
     * Supprime un fichier en utilisant son URI interne retourné par le service de médias.
     * Le service gérera l'obtention de son propre token d'authentification M2M.
     *
     * @param mediaUri           L'URI interne du fichier (ex: "/product/image/avatars/user-id/filename.jpg").
     * @return Un Mono<Void> qui se termine lorsque la suppression est terminée.
     */
    Mono<Void> deleteFile(String mediaUri);
}// END OF FILE: src/main/java/com/freelance/driver_backend/service/StorageService.java

//---> PATH: /home/mbogneng-junior/freelance-driver_Sylladb/backend/src/main/java/com/freelance/driver_backend/util/JwtUtil.java

package com.freelance.driver_backend.util;

import org.springframework.security.oauth2.jwt.Jwt;
import java.util.Map;
import java.util.UUID;

public class JwtUtil {

    public static UUID getUserIdFromToken(Jwt jwt) {
        if (jwt == null) {
            throw new IllegalArgumentException("JWT token cannot be null");
        }
        
        Map<String, Object> userClaim = jwt.getClaim("user");
        if (userClaim == null) {
            throw new IllegalStateException("User claim is missing from the token.");
        }
        
        String userIdString = (String) userClaim.get("id");
        if (userIdString == null) {
            throw new IllegalStateException("User ID is missing from the user claim.");
        }
        
        return UUID.fromString(userIdString);
    }
}// END OF FILE: src/main/java/com/freelance/driver_backend/util/JwtUtil.java

//---> PATH: /home/mbogneng-junior/freelance-driver_Sylladb/backend/src/main/resources/application.properties

# ===============================================
# IDENTIFICATION DE L'APPLICATION
# ===============================================
spring.application.name=driver-backend

# ===============================================
# CONFIGURATION DU SERVEUR WEB
# ===============================================
server.port=8080

# ===============================================
# PROFIL ACTIF
# ===============================================


# ===============================================
# CONFIGURATION DES MICROSERVICES EXTERNES
# ===============================================
# ==============================
# MICROSERVICES URLS
# ==============================
microservices.auth-service.url=${MICROSERVICES_AUTH_SERVICE_URL:https://gateway.yowyob.com/auth-service}
microservices.organisation-service.url=${MICROSERVICES_ORGANISATION_SERVICE_URL:https://gateway.yowyob.com/organization-service}
microservices.chat-service.url=${MICROSERVICES_CHAT_SERVICE_URL:http://88.198.150.195:8613}
microservices.notification-service.url=${MICROSERVICES_NOTIFICATION_SERVICE_URL:https://gateway.yowyob.com/notification-service}
microservices.resource-service.url=${MICROSERVICES_RESOURCE_SERVICE_URL:https://gateway.yowyob.com/resource-service}
microservices.media-service.url=${MICROSERVICES_MEDIA_SERVICE_URL:https://gateway.yowyob.com/media-service}
# ==============================
# FREELANCE DRIVER CONFIG
# ==============================
freelancedriver.api.public-key=${FREELANCE_DRIVER_API_PUBLIC_KEY:api_1752647119025_8d6e5340.ieGsWPxnE9eY0xBQ7n8htlTiQP3n4009}
freelancedriver.chat.project-id=${FREELANCE_DRIVER_CHAT_PROJECT_ID:25cf4dfd-e847-4b59-91c7-034aa5afc200}

# ==============================
# OAUTH2 CLIENT CONFIG
# ==============================
freelancedriver.oauth2.client-id=${FREELANCE_DRIVER_OAUTH2_CLIENT_ID:test-client}
freelancedriver.oauth2.client-secret=${FREELANCE_DRIVER_OAUTH2_CLIENT_SECRET:secret}
freelancedriver.oauth2.token-url=${FREELANCE_DRIVER_OAUTH2_TOKEN_URL:${MICROSERVICES_AUTH_SERVICE_URL:https://gateway.yowyob.com/auth-service}/oauth/token}

# ==============================
# OAUTH2 RESOURCE SERVER
# ==============================
spring.security.oauth2.resourceserver.jwt.jwk-set-uri=${SPRING_SECURITY_OAUTH2_RESOURCESERVER_JWK_URI:${MICROSERVICES_AUTH_SERVICE_URL:https://gateway.yowyob.com/auth-service}/openid/.well-known/jwks.json}

# ==============================
# DEVTOOLS
# ==============================
spring.devtools.restart.enabled=${SPRING_DEVTOOLS_RESTART_ENABLED:true}

# ==============================
# CASSANDRA CONFIG
# ==============================
spring.data.cassandra.request.timeout=${SPRING_DATA_CASSANDRA_REQUEST_TIMEOUT:20s}
spring.data.cassandra.connection.connect-timeout=${SPRING_DATA_CASSANDRA_CONNECTION_CONNECT_TIMEOUT:20s}
spring.data.cassandra.connection.init-query-timeout=${SPRING_DATA_CASSANDRA_CONNECTION_INIT_QUERY_TIMEOUT:20s}
spring.data.cassandra.contact-points=${SPRING_DATA_CASSANDRA_CONTACT_POINTS:127.0.0.1}
spring.data.cassandra.port=${SPRING_DATA_CASSANDRA_PORT:9042}
spring.data.cassandra.datacenter:${SPRING_DATA_CASSANDRA_DATACENTER:datacenter1}
spring.data.cassandra.keyspace:${SPRING_DATA_CASSANDRA_KEYSPACE:freelancebd}

# ==============================
# MAIL CONFIG
# ==============================
spring.mail.host=${SPRING_MAIL_HOST:smtp.gmail.com}
spring.mail.port=${SPRING_MAIL_PORT:587}
spring.mail.username=${SPRING_MAIL_USERNAME:mbognengj@gmail.com}
spring.mail.password=${SPRING_MAIL_PASSWORD:fmpjyadvpepfvcws}
spring.mail.properties.mail.smtp.auth=${SPRING_MAIL_PROPERTIES_MAIL_SMTP_AUTH:true}
spring.mail.properties.mail.smtp.starttls.enable=${SPRING_MAIL_PROPERTIES_MAIL_SMTP_STARTTLS_ENABLE:true}
spring.mail.properties.mail.debug=${SPRING_MAIL_PROPERTIES_MAIL_DEBUG:true}

# ==============================
# MINIO CONFIG
# ==============================
minio.endpoint=${MINIO_ENDPOINT:http://192.168.43.204:9000}
minio.access-key=${MINIO_ACCESS_KEY:junioradmin}
minio.secret-key=${MINIO_SECRET_KEY:YourStrongPassword2025}
minio.bucket-name=${MINIO_BUCKET_NAME:freelance-driver}

# ==============================
# SOCKET.IO CONFIG
# ==============================
socketio.server.host=${SOCKETIO_SERVER_HOST:0.0.0.0}
socketio.server.port=${SOCKETIO_SERVER_PORT:9092}
freelancedriver.firebase.project-id=${FREELANCE_DRIVER_FIREBASE_PROJECT_ID:freelance-driver-app}// END OF FILE: src/main/resources/application.properties

//---> PATH: /home/mbogneng-junior/freelance-driver_Sylladb/backend/src/main/resources/firebase-service-account-key .example

{
  "type": "service_account",
  "project_id": "freelance-driver-app",
  "private_key_id": "076ad5670c7bb359ad16b5ba0c7db9f943c98abb",
  "private_key": "-----BEGIN PRIVATE KEY-----\nMIIEvAIBADANBgkqhkiG9w0BAQEFAASCBKYwggSiAgEAAoIBAQCsMuciyPPHLxSj\noOMn5cePlVib5toOdJC0udSBCsealLXLjDKMdkmTiVsfjmPPt2dgUt0tDqH2C8xj\nR5nvRJZiHBJWDhSzSlrCDZR4xTJ71kxQy5EeqR2JjM2zK4QevzGImNYSfTh8daHD\nE+dTc/yGRxW3VREsMNRfBp12oPF/yW7Sakk0Y5eQIKnRWxiB2OJVfJkhPwejLrEK\nAhVaGpclaVqqCYufIwXOmfVqTCSEmXmxhr8DfeZFRZkEB6fXSaVC+2+FwjEHwvJt\nmSnnV7dsI+XGXLaIaKhXfY4UBnOZYIQmImpu55TrRjJ3JSlktEkln3DBdIopUc4A\niGWIt9NXAgMBAAECggEAHjm7H3x1adeGQGh7puOq4TWePZNKYDIuukJKHjJ1sdj7\nhhSARO54YLjB8WqNc4bmUt6IqyF/5U/R2vVU/E4mNWdnAorrMENTZe97Sa2XfGwz\nrhTlTqPxptS7wIDZaoo12Bu3q7wmH5aIQ9UpDBl2UF2G3szEPGT/ygQ/vHRon3zC\nfoySBq+4Pxuwe3AVGYgmSq/sdMXSWgT+vyO3UB7JM1+0mLGE6bxhOBt6G48/4AjY\n9oeYyEQu0fVDMrOAwwjqOzUOdkASsYcmYpILk06o25Nyj7BKryvmpAh3Ir8Scp3c\n0LOto6XBwmD6T8jroX9ccv7mpY5f7PAqXSadwMGS/QKBgQDmCiZssITBqNncj5OJ\nFR6m8K0jXSmfDYErhdllkDrHWTp0b8eh/BED0fb3TCKlBBeBZ9VdTHmMiv0LCJy+\n6/MKSMTcc1ucjbgdtBjXVMHKUy8c7yrmkaXadY1Aj8K9FhYuri5184sES2sbqT0x\nS+VwCtPt00D37ntjkLmNZjLI1QKBgQC/obsNesNXlPXIourPVgAf+vnq6xPnU0Zm\nuYZsB0saSiS62G/gSNtaSpl8QNN3FWeniqa55lor50HRvEoV+6WI5KoxH/EI/F2j\n8FCNBrl8CptMOctskRozQzhYwBFY/F41UjLy4iqsX01y2kCCSRl9T0javwACRbIO\nlkknqaaBewKBgCZckPXVJf5pmxM1+kOE+xyZzDW2hodYqC7K3msad0LhNWdPcLop\nn+jELewljS15ljXlS+aIJ0jxsKsTX5hTHq+bXQDqV9+unoKNkwrtvndwEc5AcCYN\nKdxZeBnJH4+KzF4ye9r9pzQrI4x0V5kN8BAULi1d6lquMXN0Ig1beqKVAoGAKSiX\ngGGpqxn3YEx9mmKiTDwfiXFMKRcdu9qFIJbAbrkWAnuSK936Hv5+0M0rnhwe00FY\nZf0vyNY2sNF8KBSQjUJvu3Vc081AX4GyC1gyZo3wpQKUypCvy+rYI1e9YhtyMImj\nH7+r4rHldJGj4VfJ/bwVrcXwPoyxnahxte8eMBkCgYAS4gfwXi5qM3hryMLLdaLl\nCHeRKuqRj/Ug5DPMcdffIp8GDK6xhzbNFTytScx29wlgaE0g7Dm9bmS7N+0RpnWs\ngQeO2NFnhHot0yvslC2l0EaLAkMkHV8gkUFVXaqycHS1z+rl62S1upEdLUnNI8M9\nhjD59wE6MIzTmVanSjt/+g==\n-----END PRIVATE KEY-----\n",
  "client_email": "firebase-adminsdk-fbsvc@freelance-driver-app.iam.gserviceaccount.com",
  "client_id": "104451789079889408455",
  "auth_uri": "https://accounts.google.com/o/oauth2/auth",
  "token_uri": "https://oauth2.googleapis.com/token",
  "auth_provider_x509_cert_url": "https://www.googleapis.com/oauth2/v1/certs",
  "client_x509_cert_url": "https://www.googleapis.com/robot/v1/metadata/x509/firebase-adminsdk-fbsvc%40freelance-driver-app.iam.gserviceaccount.com",
  "universe_domain": "googleapis.com"
}
// END OF FILE: src/main/resources/firebase-service-account-key .example

//---> PATH: /home/mbogneng-junior/freelance-driver_Sylladb/backend/src/main/resources/firebase-service-account-key.example

{
  "type": "service_account",
  "project_id": "freelance-driver-app",
  "private_key_id": "076ad5670c7bb359ad16b5ba0c7db9f943c98abb",
  "private_key": "-----BEGIN PRIVATE KEY-----\nMIIEvAIBADANBgkqhkiG9w0BAQEFAASCBKYwggSiAgEAAoIBAQCsMuciyPPHLxSj\noOMn5cePlVib5toOdJC0udSBCsealLXLjDKMdkmTiVsfjmPPt2dgUt0tDqH2C8xj\nR5nvRJZiHBJWDhSzSlrCDZR4xTJ71kxQy5EeqR2JjM2zK4QevzGImNYSfTh8daHD\nE+dTc/yGRxW3VREsMNRfBp12oPF/yW7Sakk0Y5eQIKnRWxiB2OJVfJkhPwejLrEK\nAhVaGpclaVqqCYufIwXOmfVqTCSEmXmxhr8DfeZFRZkEB6fXSaVC+2+FwjEHwvJt\nmSnnV7dsI+XGXLaIaKhXfY4UBnOZYIQmImpu55TrRjJ3JSlktEkln3DBdIopUc4A\niGWIt9NXAgMBAAECggEAHjm7H3x1adeGQGh7puOq4TWePZNKYDIuukJKHjJ1sdj7\nhhSARO54YLjB8WqNc4bmUt6IqyF/5U/R2vVU/E4mNWdnAorrMENTZe97Sa2XfGwz\nrhTlTqPxptS7wIDZaoo12Bu3q7wmH5aIQ9UpDBl2UF2G3szEPGT/ygQ/vHRon3zC\nfoySBq+4Pxuwe3AVGYgmSq/sdMXSWgT+vyO3UB7JM1+0mLGE6bxhOBt6G48/4AjY\n9oeYyEQu0fVDMrOAwwjqOzUOdkASsYcmYpILk06o25Nyj7BKryvmpAh3Ir8Scp3c\n0LOto6XBwmD6T8jroX9ccv7mpY5f7PAqXSadwMGS/QKBgQDmCiZssITBqNncj5OJ\nFR6m8K0jXSmfDYErhdllkDrHWTp0b8eh/BED0fb3TCKlBBeBZ9VdTHmMiv0LCJy+\n6/MKSMTcc1ucjbgdtBjXVMHKUy8c7yrmkaXadY1Aj8K9FhYuri5184sES2sbqT0x\nS+VwCtPt00D37ntjkLmNZjLI1QKBgQC/obsNesNXlPXIourPVgAf+vnq6xPnU0Zm\nuYZsB0saSiS62G/gSNtaSpl8QNN3FWeniqa55lor50HRvEoV+6WI5KoxH/EI/F2j\n8FCNBrl8CptMOctskRozQzhYwBFY/F41UjLy4iqsX01y2kCCSRl9T0javwACRbIO\nlkknqaaBewKBgCZckPXVJf5pmxM1+kOE+xyZzDW2hodYqC7K3msad0LhNWdPcLop\nn+jELewljS15ljXlS+aIJ0jxsKsTX5hTHq+bXQDqV9+unoKNkwrtvndwEc5AcCYN\nKdxZeBnJH4+KzF4ye9r9pzQrI4x0V5kN8BAULi1d6lquMXN0Ig1beqKVAoGAKSiX\ngGGpqxn3YEx9mmKiTDwfiXFMKRcdu9qFIJbAbrkWAnuSK936Hv5+0M0rnhwe00FY\nZf0vyNY2sNF8KBSQjUJvu3Vc081AX4GyC1gyZo3wpQKUypCvy+rYI1e9YhtyMImj\nH7+r4rHldJGj4VfJ/bwVrcXwPoyxnahxte8eMBkCgYAS4gfwXi5qM3hryMLLdaLl\nCHeRKuqRj/Ug5DPMcdffIp8GDK6xhzbNFTytScx29wlgaE0g7Dm9bmS7N+0RpnWs\ngQeO2NFnhHot0yvslC2l0EaLAkMkHV8gkUFVXaqycHS1z+rl62S1upEdLUnNI8M9\nhjD59wE6MIzTmVanSjt/+g==\n-----END PRIVATE KEY-----\n",
  "client_email": "firebase-adminsdk-fbsvc@freelance-driver-app.iam.gserviceaccount.com",
  "client_id": "104451789079889408455",
  "auth_uri": "https://accounts.google.com/o/oauth2/auth",
  "token_uri": "https://oauth2.googleapis.com/token",
  "auth_provider_x509_cert_url": "https://www.googleapis.com/oauth2/v1/certs",
  "client_x509_cert_url": "https://www.googleapis.com/robot/v1/metadata/x509/firebase-adminsdk-fbsvc%40freelance-driver-app.iam.gserviceaccount.com",
  "universe_domain": "googleapis.com"
}
// END OF FILE: src/main/resources/firebase-service-account-key.example

//---> PATH: /home/mbogneng-junior/freelance-driver_Sylladb/backend/src/main/resources/firebase-service-account-key.json

{
  "type": "service_account",
  "project_id": "freelance-driver-app",
  "private_key_id": "076ad5670c7bb359ad16b5ba0c7db9f943c98abb",
  "private_key": "-----BEGIN PRIVATE KEY-----\nMIIEvAIBADANBgkqhkiG9w0BAQEFAASCBKYwggSiAgEAAoIBAQCsMuciyPPHLxSj\noOMn5cePlVib5toOdJC0udSBCsealLXLjDKMdkmTiVsfjmPPt2dgUt0tDqH2C8xj\nR5nvRJZiHBJWDhSzSlrCDZR4xTJ71kxQy5EeqR2JjM2zK4QevzGImNYSfTh8daHD\nE+dTc/yGRxW3VREsMNRfBp12oPF/yW7Sakk0Y5eQIKnRWxiB2OJVfJkhPwejLrEK\nAhVaGpclaVqqCYufIwXOmfVqTCSEmXmxhr8DfeZFRZkEB6fXSaVC+2+FwjEHwvJt\nmSnnV7dsI+XGXLaIaKhXfY4UBnOZYIQmImpu55TrRjJ3JSlktEkln3DBdIopUc4A\niGWIt9NXAgMBAAECggEAHjm7H3x1adeGQGh7puOq4TWePZNKYDIuukJKHjJ1sdj7\nhhSARO54YLjB8WqNc4bmUt6IqyF/5U/R2vVU/E4mNWdnAorrMENTZe97Sa2XfGwz\nrhTlTqPxptS7wIDZaoo12Bu3q7wmH5aIQ9UpDBl2UF2G3szEPGT/ygQ/vHRon3zC\nfoySBq+4Pxuwe3AVGYgmSq/sdMXSWgT+vyO3UB7JM1+0mLGE6bxhOBt6G48/4AjY\n9oeYyEQu0fVDMrOAwwjqOzUOdkASsYcmYpILk06o25Nyj7BKryvmpAh3Ir8Scp3c\n0LOto6XBwmD6T8jroX9ccv7mpY5f7PAqXSadwMGS/QKBgQDmCiZssITBqNncj5OJ\nFR6m8K0jXSmfDYErhdllkDrHWTp0b8eh/BED0fb3TCKlBBeBZ9VdTHmMiv0LCJy+\n6/MKSMTcc1ucjbgdtBjXVMHKUy8c7yrmkaXadY1Aj8K9FhYuri5184sES2sbqT0x\nS+VwCtPt00D37ntjkLmNZjLI1QKBgQC/obsNesNXlPXIourPVgAf+vnq6xPnU0Zm\nuYZsB0saSiS62G/gSNtaSpl8QNN3FWeniqa55lor50HRvEoV+6WI5KoxH/EI/F2j\n8FCNBrl8CptMOctskRozQzhYwBFY/F41UjLy4iqsX01y2kCCSRl9T0javwACRbIO\nlkknqaaBewKBgCZckPXVJf5pmxM1+kOE+xyZzDW2hodYqC7K3msad0LhNWdPcLop\nn+jELewljS15ljXlS+aIJ0jxsKsTX5hTHq+bXQDqV9+unoKNkwrtvndwEc5AcCYN\nKdxZeBnJH4+KzF4ye9r9pzQrI4x0V5kN8BAULi1d6lquMXN0Ig1beqKVAoGAKSiX\ngGGpqxn3YEx9mmKiTDwfiXFMKRcdu9qFIJbAbrkWAnuSK936Hv5+0M0rnhwe00FY\nZf0vyNY2sNF8KBSQjUJvu3Vc081AX4GyC1gyZo3wpQKUypCvy+rYI1e9YhtyMImj\nH7+r4rHldJGj4VfJ/bwVrcXwPoyxnahxte8eMBkCgYAS4gfwXi5qM3hryMLLdaLl\nCHeRKuqRj/Ug5DPMcdffIp8GDK6xhzbNFTytScx29wlgaE0g7Dm9bmS7N+0RpnWs\ngQeO2NFnhHot0yvslC2l0EaLAkMkHV8gkUFVXaqycHS1z+rl62S1upEdLUnNI8M9\nhjD59wE6MIzTmVanSjt/+g==\n-----END PRIVATE KEY-----\n",
  "client_email": "firebase-adminsdk-fbsvc@freelance-driver-app.iam.gserviceaccount.com",
  "client_id": "104451789079889408455",
  "auth_uri": "https://accounts.google.com/o/oauth2/auth",
  "token_uri": "https://oauth2.googleapis.com/token",
  "auth_provider_x509_cert_url": "https://www.googleapis.com/oauth2/v1/certs",
  "client_x509_cert_url": "https://www.googleapis.com/robot/v1/metadata/x509/firebase-adminsdk-fbsvc%40freelance-driver-app.iam.gserviceaccount.com",
  "universe_domain": "googleapis.com"
}
// END OF FILE: src/main/resources/firebase-service-account-key.json

//---> PATH: /home/mbogneng-junior/freelance-driver_Sylladb/backend/src/test/java/com/freelance/driver_backend/DriverBackendApplicationTests.java

package com.freelance.driver_backend;

import org.junit.jupiter.api.Test;
import org.springframework.boot.test.context.SpringBootTest;

@SpringBootTest
class DriverBackendApplicationTests {

	@Test
	void contextLoads() {
	}

}
// END OF FILE: src/test/java/com/freelance/driver_backend/DriverBackendApplicationTests.java

