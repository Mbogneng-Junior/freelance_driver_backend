Project Context From: /home/mbogneng-junior/freelance-driver_Sylladb/backend
Generated On: dim. 18 janv. 2026 14:37:17 WAT
===============================================
Ignored Directory Patterns: .* node_modules vendor build dist target __pycache__ .next cache target storage
Ignored File Patterns: *.log *.jar *.pdf *.class *.sqlite project_context.txt package-lock.json yarn.lock composer.lock *.ico pnpm-lock.yaml
===============================================

//---> PATH: /home/mbogneng-junior/freelance-driver_Sylladb/backend/aws/install

#!/bin/sh
# Copyright 2012-2019 Amazon.com, Inc. or its affiliates. All Rights Reserved.
#
# Licensed under the Apache License, Version 2.0 (the "License"). You
# may not use this file except in compliance with the License. A copy of
# the License is located at
#
#     http://aws.amazon.com/apache2.0/
#
# or in the "license" file accompanying this file. This file is
# distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF
# ANY KIND, either express or implied. See the License for the specific
# language governing permissions and limitations under the License.

usage() {
  cat 1>&2 <<EOF
Installs the AWS CLI v2

USAGE:
    install [FLAGS] [OPTIONS]

FLAGS:
    -u, --update              Updates the AWS CLI v2 if a different version
                              is previously installed. By default, this script
                              will not update the AWS CLI if a previous
                              installation is detected.

    -h, --help                Prints help information

OPTIONS:
    -i, --install-dir <path>  The directory to install the AWS CLI v2. By
                              default, this directory is: /usr/local/aws-cli

    -b, --bin-dir <path>      The directory to store symlinks to executables
                              for the AWS CLI v2. By default, the directory
                              used is: /usr/local/bin
EOF
}

parse_commandline() {
  while test $# -gt 0
  do
    key="$1"
	case "$key" in
	  -i|--install-dir)
	    PARSED_INSTALL_DIR="$2"
		shift
	   ;;
	  -b|--bin-dir)
	    PARSED_BIN_DIR="$2"
		shift
	   ;;
	  -u|--update)
	    PARSED_UPGRADE="yes"
	  ;;
	  -h|--help)
	    usage
        exit 0
	  ;;
	  *)
	   die "Got an unexpected argument: $1"
	  ;;
    esac
	shift
  done
}

set_global_vars() {
  ROOT_INSTALL_DIR=${PARSED_INSTALL_DIR:-/usr/local/aws-cli}
  BIN_DIR=${PARSED_BIN_DIR:-/usr/local/bin}
  UPGRADE=${PARSED_UPGRADE:-no}

  EXE_NAME="aws"
  COMPLETER_EXE_NAME="aws_completer"
  INSTALLER_DIR="$( cd "$( dirname "$0" )" >/dev/null 2>&1 && pwd )"
  INSTALLER_DIST_DIR="$INSTALLER_DIR/dist"
  INSTALLER_EXE="$INSTALLER_DIST_DIR/$EXE_NAME"
  AWS_EXE_VERSION=$($INSTALLER_EXE --version | cut -d ' ' -f 1 | cut -d '/' -f 2)

  INSTALL_DIR="$ROOT_INSTALL_DIR/v2/$AWS_EXE_VERSION"
  INSTALL_DIR="$INSTALL_DIR"
  INSTALL_DIST_DIR="$INSTALL_DIR/dist"
  INSTALL_BIN_DIR="$INSTALL_DIR/bin"
  INSTALL_AWS_EXE="$INSTALL_BIN_DIR/$EXE_NAME"
  INSTALL_AWS_COMPLETER_EXE="$INSTALL_BIN_DIR/$COMPLETER_EXE_NAME"

  CURRENT_INSTALL_DIR="$ROOT_INSTALL_DIR/v2/current"
  CURRENT_AWS_EXE="$CURRENT_INSTALL_DIR/bin/$EXE_NAME"
  CURRENT_AWS_COMPLETER_EXE="$CURRENT_INSTALL_DIR/bin/$COMPLETER_EXE_NAME"

  BIN_AWS_EXE="$BIN_DIR/$EXE_NAME"
  BIN_AWS_COMPLETER_EXE="$BIN_DIR/$COMPLETER_EXE_NAME"
}

create_install_dir() {
  mkdir -p "$INSTALL_DIR" || exit 1
  {
    setup_install_dist &&
    setup_install_bin &&
    create_current_symlink
  } || {
    rm -rf "$INSTALL_DIR"
    exit 1
  }
}

check_preexisting_install() {
  if [ -L "$CURRENT_INSTALL_DIR" ] && [ "$UPGRADE" = "no" ]
  then
    die "Found preexisting AWS CLI installation: $CURRENT_INSTALL_DIR. Please rerun install script with --update flag."
  fi
  if [ -d "$INSTALL_DIR" ]
  then
    echo "Found same AWS CLI version: $INSTALL_DIR. Skipping install."
    exit 0
  fi
}

setup_install_dist() {
  cp -r "$INSTALLER_DIST_DIR" "$INSTALL_DIST_DIR"
}

setup_install_bin() {
  mkdir -p "$INSTALL_BIN_DIR"
  ln -s "../dist/$EXE_NAME" "$INSTALL_AWS_EXE"
  ln -s "../dist/$COMPLETER_EXE_NAME" "$INSTALL_AWS_COMPLETER_EXE"
}

create_current_symlink() {
  ln -snf "$INSTALL_DIR" "$CURRENT_INSTALL_DIR"
}

create_bin_symlinks() {
  mkdir -p "$BIN_DIR"
  ln -sf "$CURRENT_AWS_EXE" "$BIN_AWS_EXE"
  ln -sf "$CURRENT_AWS_COMPLETER_EXE" "$BIN_AWS_COMPLETER_EXE"
}

die() {
	err_msg="$1"
	echo "$err_msg" >&2
	exit 1
}

main() {
  parse_commandline "$@"
  set_global_vars
  check_preexisting_install
  create_install_dir
  create_bin_symlinks
  echo "You can now run: $BIN_AWS_EXE --version"
  exit 0
}

main "$@" || exit 1
// END OF FILE: aws/install

//---> PATH: /home/mbogneng-junior/freelance-driver_Sylladb/backend/aws/README.md

# AWS CLI v2

This bundle contains a built executable of the AWS CLI v2.

## Installation

To install the AWS CLI v2, run the `install` script:
```
$ sudo ./install 
You can now run: /usr/local/bin/aws --version
```
This will install the AWS CLI v2 at `/usr/local/bin/aws`.  Assuming
`/usr/local/bin` is on your `PATH`, you can now run:
```
$ aws --version
```


### Installing without sudo

If you don't have ``sudo`` permissions or want to install the AWS
CLI v2 only for the current user, run the `install` script with the `-b`
and `-i` options:
```
$ ./install -i ~/.local/aws-cli -b ~/.local/bin
``` 
This will install the AWS CLI v2 in `~/.local/aws-cli` and create
symlinks for `aws` and `aws_completer` in `~/.local/bin`. For more
information about these options, run the `install` script with `-h`:
```
$ ./install -h
```

### Updating

If you run the `install` script and there is a previously installed version
of the AWS CLI v2, the script will error out. To update to the version included
in this bundle, run the `install` script with `--update`:
```
$ sudo ./install --update
```


### Removing the installation

To remove the AWS CLI v2, delete the its installation and symlinks:
```
$ sudo rm -rf /usr/local/aws-cli
$ sudo rm /usr/local/bin/aws
$ sudo rm /usr/local/bin/aws_completer
```
Note if you installed the AWS CLI v2 using the `-b` or `-i` options, you will
need to remove the installation and the symlinks in the directories you
specified.
// END OF FILE: aws/README.md

//---> PATH: /home/mbogneng-junior/freelance-driver_Sylladb/backend/aws/THIRD_PARTY_LICENSES

** botocore; version 2 -- https://github.com/boto/botocore/tree/v2
Botocore
Copyright 2012-2017 Amazon.com, Inc. or its affiliates. All Rights Reserved.

----

Botocore includes a vendorized copy of the requests python library to ease
installation.

Requests License
================

Copyright 2013 Kenneth Reitz

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.


The requests library also includes some vendorized python libraries to ease
installation.

Urllib3 License
===============

This is the MIT license: http://www.opensource.org/licenses/mit-license.php

Copyright 2008-2011 Andrey Petrov and contributors (see CONTRIBUTORS.txt),
Modifications copyright 2012 Kenneth Reitz.

Permission is hereby granted, free of charge, to any person obtaining a copy of
this
software and associated documentation files (the "Software"), to deal in the
Software
without restriction, including without limitation the rights to use, copy,
modify, merge,
publish, distribute, sublicense, and/or sell copies of the Software, and to
permit persons
to whom the Software is furnished to do so, subject to the following
conditions:

The above copyright notice and this permission notice shall be included in all
copies or
substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED,
INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
PARTICULAR
PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
BE LIABLE
FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
TORT OR
OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE
OR OTHER
DEALINGS IN THE SOFTWARE.

Chardet License
===============

This library is free software; you can redistribute it and/or
modify it under the terms of the GNU Lesser General Public
License as published by the Free Software Foundation; either
version 2.1 of the License, or (at your option) any later version.

This library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public
License along with this library; if not, write to the Free Software
Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
02110-1301  USA

Bundle of CA Root Certificates
==============================

This library is free software; you can redistribute it and/or
modify it under the terms of the GNU Lesser General Public
License as published by the Free Software Foundation; either
version 2.1 of the License, or (at your option) any later version.

This library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public
License along with this library; if not, write to the Free Software
Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
02110-1301
** s3transfer; version 0 -- https://github.com/boto/s3transfer
s3transfer
Copyright 2016 Amazon.com, Inc. or its affiliates. All Rights Reserved.

Apache License

Version 2.0, January 2004

http://www.apache.org/licenses/ TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND
DISTRIBUTION

   1. Definitions.

      "License" shall mean the terms and conditions for use, reproduction, and
      distribution as defined by Sections 1 through 9 of this document.

      "Licensor" shall mean the copyright owner or entity authorized by the
      copyright owner that is granting the License.

      "Legal Entity" shall mean the union of the acting entity and all other
      entities that control, are controlled by, or are under common control
      with that entity. For the purposes of this definition, "control" means
      (i) the power, direct or indirect, to cause the direction or management
      of such entity, whether by contract or otherwise, or (ii) ownership of
      fifty percent (50%) or more of the outstanding shares, or (iii)
      beneficial ownership of such entity.

      "You" (or "Your") shall mean an individual or Legal Entity exercising
      permissions granted by this License.

      "Source" form shall mean the preferred form for making modifications,
      including but not limited to software source code, documentation source,
      and configuration files.

      "Object" form shall mean any form resulting from mechanical
      transformation or translation of a Source form, including but not limited
      to compiled object code, generated documentation, and conversions to
      other media types.

      "Work" shall mean the work of authorship, whether in Source or Object
      form, made available under the License, as indicated by a copyright
      notice that is included in or attached to the work (an example is
      provided in the Appendix below).

      "Derivative Works" shall mean any work, whether in Source or Object form,
      that is based on (or derived from) the Work and for which the editorial
      revisions, annotations, elaborations, or other modifications represent,
      as a whole, an original work of authorship. For the purposes of this
      License, Derivative Works shall not include works that remain separable
      from, or merely link (or bind by name) to the interfaces of, the Work and
      Derivative Works thereof.

      "Contribution" shall mean any work of authorship, including the original
      version of the Work and any modifications or additions to that Work or
      Derivative Works thereof, that is intentionally submitted to Licensor for
      inclusion in the Work by the copyright owner or by an individual or Legal
      Entity authorized to submit on behalf of the copyright owner. For the
      purposes of this definition, "submitted" means any form of electronic,
      verbal, or written communication sent to the Licensor or its
      representatives, including but not limited to communication on electronic
      mailing lists, source code control systems, and issue tracking systems
      that are managed by, or on behalf of, the Licensor for the purpose of
      discussing and improving the Work, but excluding communication that is
      conspicuously marked or otherwise designated in writing by the copyright
      owner as "Not a Contribution."

      "Contributor" shall mean Licensor and any individual or Legal Entity on
      behalf of whom a Contribution has been received by Licensor and
      subsequently incorporated within the Work.

   2. Grant of Copyright License. Subject to the terms and conditions of this
   License, each Contributor hereby grants to You a perpetual, worldwide,
   non-exclusive, no-charge, royalty-free, irrevocable copyright license to
   reproduce, prepare Derivative Works of, publicly display, publicly perform,
   sublicense, and distribute the Work and such Derivative Works in Source or
   Object form.

   3. Grant of Patent License. Subject to the terms and conditions of this
   License, each Contributor hereby grants to You a perpetual, worldwide,
   non-exclusive, no-charge, royalty-free, irrevocable (except as stated in
   this section) patent license to make, have made, use, offer to sell, sell,
   import, and otherwise transfer the Work, where such license applies only to
   those patent claims licensable by such Contributor that are necessarily
   infringed by their Contribution(s) alone or by combination of their
   Contribution(s) with the Work to which such Contribution(s) was submitted.
   If You institute patent litigation against any entity (including a
   cross-claim or counterclaim in a lawsuit) alleging that the Work or a
   Contribution incorporated within the Work constitutes direct or contributory
   patent infringement, then any patent licenses granted to You under this
   License for that Work shall terminate as of the date such litigation is
   filed.

   4. Redistribution. You may reproduce and distribute copies of the Work or
   Derivative Works thereof in any medium, with or without modifications, and
   in Source or Object form, provided that You meet the following conditions:

      (a) You must give any other recipients of the Work or Derivative Works a
      copy of this License; and

      (b) You must cause any modified files to carry prominent notices stating
      that You changed the files; and

      (c) You must retain, in the Source form of any Derivative Works that You
      distribute, all copyright, patent, trademark, and attribution notices
      from the Source form of the Work, excluding those notices that do not
      pertain to any part of the Derivative Works; and

      (d) If the Work includes a "NOTICE" text file as part of its
      distribution, then any Derivative Works that You distribute must include
      a readable copy of the attribution notices contained within such NOTICE
      file, excluding those notices that do not pertain to any part of the
      Derivative Works, in at least one of the following places: within a
      NOTICE text file distributed as part of the Derivative Works; within the
      Source form or documentation, if provided along with the Derivative
      Works; or, within a display generated by the Derivative Works, if and
      wherever such third-party notices normally appear. The contents of the
      NOTICE file are for informational purposes only and do not modify the
      License. You may add Your own attribution notices within Derivative Works
      that You distribute, alongside or as an addendum to the NOTICE text from
      the Work, provided that such additional attribution notices cannot be
      construed as modifying the License.

      You may add Your own copyright statement to Your modifications and may
      provide additional or different license terms and conditions for use,
      reproduction, or distribution of Your modifications, or for any such
      Derivative Works as a whole, provided Your use, reproduction, and
      distribution of the Work otherwise complies with the conditions stated in
      this License.

   5. Submission of Contributions. Unless You explicitly state otherwise, any
   Contribution intentionally submitted for inclusion in the Work by You to the
   Licensor shall be under the terms and conditions of this License, without
   any additional terms or conditions. Notwithstanding the above, nothing
   herein shall supersede or modify the terms of any separate license agreement
   you may have executed with Licensor regarding such Contributions.

   6. Trademarks. This License does not grant permission to use the trade
   names, trademarks, service marks, or product names of the Licensor, except
   as required for reasonable and customary use in describing the origin of the
   Work and reproducing the content of the NOTICE file.

   7. Disclaimer of Warranty. Unless required by applicable law or agreed to in
   writing, Licensor provides the Work (and each Contributor provides its
   Contributions) on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
   KIND, either express or implied, including, without limitation, any
   warranties or conditions of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or
   FITNESS FOR A PARTICULAR PURPOSE. You are solely responsible for determining
   the appropriateness of using or redistributing the Work and assume any risks
   associated with Your exercise of permissions under this License.

   8. Limitation of Liability. In no event and under no legal theory, whether
   in tort (including negligence), contract, or otherwise, unless required by
   applicable law (such as deliberate and grossly negligent acts) or agreed to
   in writing, shall any Contributor be liable to You for damages, including
   any direct, indirect, special, incidental, or consequential damages of any
   character arising as a result of this License or out of the use or inability
   to use the Work (including but not limited to damages for loss of goodwill,
   work stoppage, computer failure or malfunction, or any and all other
   commercial damages or losses), even if such Contributor has been advised of
   the possibility of such damages.

   9. Accepting Warranty or Additional Liability. While redistributing the Work
   or Derivative Works thereof, You may choose to offer, and charge a fee for,
   acceptance of support, warranty, indemnity, or other liability obligations
   and/or rights consistent with this License. However, in accepting such
   obligations, You may act only on Your own behalf and on Your sole
   responsibility, not on behalf of any other Contributor, and only if You
   agree to indemnify, defend, and hold each Contributor harmless for any
   liability incurred by, or claims asserted against, such Contributor by
   reason of your accepting any such warranty or additional liability. END OF
   TERMS AND CONDITIONS

APPENDIX: How to apply the Apache License to your work.

To apply the Apache License to your work, attach the following boilerplate
notice, with the fields enclosed by brackets "[]" replaced with your own
identifying information. (Don't include the brackets!) The text should be
enclosed in the appropriate comment syntax for the file format. We also
recommend that a file or class name and description of purpose be included on
the same "printed page" as the copyright notice for easier identification
within third-party archives.

Copyright [yyyy] [name of copyright owner]

Licensed under the Apache License, Version 2.0 (the "License");

you may not use this file except in compliance with the License.

You may obtain a copy of the License at

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software

distributed under the License is distributed on an "AS IS" BASIS,

WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.

See the License for the specific language governing permissions and

limitations under the License.

* For botocore see also this required NOTICE:
    Botocore
    Copyright 2012-2017 Amazon.com, Inc. or its affiliates. All Rights
    Reserved.

    ----

    Botocore includes a vendorized copy of the requests python library to ease
    installation.

    Requests License
    ================

    Copyright 2013 Kenneth Reitz

       Licensed under the Apache License, Version 2.0 (the "License");
       you may not use this file except in compliance with the License.
       You may obtain a copy of the License at

           http://www.apache.org/licenses/LICENSE-2.0

       Unless required by applicable law or agreed to in writing, software
       distributed under the License is distributed on an "AS IS" BASIS,
       WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       See the License for the specific language governing permissions and
       limitations under the License.


    The requests library also includes some vendorized python libraries to ease
    installation.

    Urllib3 License
    ===============

    This is the MIT license: http://www.opensource.org/licenses/mit-license.php

    Copyright 2008-2011 Andrey Petrov and contributors (see CONTRIBUTORS.txt),
    Modifications copyright 2012 Kenneth Reitz.

    Permission is hereby granted, free of charge, to any person obtaining a
    copy of this
    software and associated documentation files (the "Software"), to deal in
    the Software
    without restriction, including without limitation the rights to use, copy,
    modify, merge,
    publish, distribute, sublicense, and/or sell copies of the Software, and to
    permit persons
    to whom the Software is furnished to do so, subject to the following
    conditions:

    The above copyright notice and this permission notice shall be included in
    all copies or
    substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
    IMPLIED,
    INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR
    A PARTICULAR
    PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
    HOLDERS BE LIABLE
    FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF
    CONTRACT, TORT OR
    OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
    USE OR OTHER
    DEALINGS IN THE SOFTWARE.

    Chardet License
    ===============

    This library is free software; you can redistribute it and/or
    modify it under the terms of the GNU Lesser General Public
    License as published by the Free Software Foundation; either
    version 2.1 of the License, or (at your option) any later version.

    This library is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
    Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public
    License along with this library; if not, write to the Free Software
    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
    02110-1301  USA

    Bundle of CA Root Certificates
    ==============================

    This library is free software; you can redistribute it and/or
    modify it under the terms of the GNU Lesser General Public
    License as published by the Free Software Foundation; either
    version 2.1 of the License, or (at your option) any later version.

    This library is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
    Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public
    License along with this library; if not, write to the Free Software
    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
    02110-1301
* For s3transfer see also this required NOTICE:
    s3transfer
    Copyright 2016 Amazon.com, Inc. or its affiliates. All Rights Reserved.

------

** colorama; version 0.4.2 -- https://pypi.org/project/colorama/
Copyright (c) 2010 Jonathan Hartley
All rights reserved.

Copyright (c) 2010 Jonathan Hartley
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

* Redistributions of source code must retain the above copyright notice, this
  list of conditions and the following disclaimer.

* Redistributions in binary form must reproduce the above copyright notice,
  this list of conditions and the following disclaimer in the documentation
  and/or other materials provided with the distribution.

* Neither the name of the copyright holders, nor those of its contributors
  may be used to endorse or promote products derived from this software without
  specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

------

** prompt-toolkit; version 2.0.10 --
https://github.com/prompt-toolkit/python-prompt-toolkit/tree/2.0.10
Copyright (c) 2014, Jonathan Slenders
All rights reserved.

Copyright (c) 2014, Jonathan Slenders
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification,
are permitted provided that the following conditions are met:

* Redistributions of source code must retain the above copyright notice, this
  list of conditions and the following disclaimer.

* Redistributions in binary form must reproduce the above copyright notice,
this
  list of conditions and the following disclaimer in the documentation and/or
  other materials provided with the distribution.

* Neither the name of the {organization} nor the names of its
  contributors may be used to endorse or promote products derived from
  this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

------

** dateutil; version 2.8.0 -- https://github.com/dateutil/dateutil/tree/2.8.0
Copyright 2017- Paul Ganssle <paul@ganssle.io>
Copyright 2017- dateutil contributors (see AUTHORS file)

Copyright 2017- Paul Ganssle <paul@ganssle.io>
Copyright 2017- dateutil contributors (see AUTHORS file)

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.

The above license applies to all contributions after 2017-12-01, as well as
all contributions that have been re-licensed (see AUTHORS file for the list of
contributors who have re-licensed their code).
--------------------------------------------------------------------------------
dateutil - Extensions to the standard Python datetime module.

Copyright (c) 2003-2011 - Gustavo Niemeyer <gustavo@niemeyer.net>
Copyright (c) 2012-2014 - Tomi Pievil√§inen <tomi.pievilainen@iki.fi>
Copyright (c) 2014-2016 - Yaron de Leeuw <me@jarondl.net>
Copyright (c) 2015-     - Paul Ganssle <paul@ganssle.io>
Copyright (c) 2015-     - dateutil contributors (see AUTHORS file)

All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

    * Redistributions of source code must retain the above copyright notice,
      this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright notice,
      this list of conditions and the following disclaimer in the documentation
      and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the names of its
      contributors may be used to endorse or promote products derived from
      this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

The above BSD License Applies to all code, even that also covered by Apache
2.0.

------

** Pyintaller 3.5; version 3.5 --
https://github.com/pyinstaller/pyinstaller/tree/v3.5
Copyright (c) 2010-2020, PyInstaller Development Team
Copyright (c) 2005-2009, Giovanni Bajo
Based on previous work under copyright (c) 2002 McMillan Enterprises, Inc.

    * Package Pyintaller 3.5's source code may be found at:
      https://files.pythonhosted.org/packages/e2/c9/0b44b2ea87ba36395483a672fddd07e6a9cb2b8d3c4a28d7ae76c7e7e1e5/PyInstaller-3.5.tar.gz

================================
 The PyInstaller licensing terms
================================


Copyright (c) 2010-2020, PyInstaller Development Team
Copyright (c) 2005-2009, Giovanni Bajo
Based on previous work under copyright (c) 2002 McMillan Enterprises, Inc.


PyInstaller is licensed under the terms of the GNU General Public License
as published by the Free Software Foundation; either version 2 of the License,
or (at your option) any later version.


Bootloader Exception
--------------------

In addition to the permissions in the GNU General Public License, the
authors give you unlimited permission to link or embed compiled bootloader
and related files into combinations with other programs, and to distribute
those combinations without any restriction coming from the use of those
files. (The General Public License restrictions do apply in other respects;
for example, they cover modification of the files, and distribution when
not linked into a combined executable.)


Bootloader and Related Files
----------------------------

Bootloader and related files are files which are embedded within the
final executable. This includes files in directories:

./bootloader/
./PyInstaller/loader


About the PyInstaller Development Team
--------------------------------------

The PyInstaller Development Team is the set of contributors
to the PyInstaller project. A full list with details is kept
in the documentation directory, in the file
``doc/CREDITS.rst``.

The core team that coordinates development on GitHub can be found here:
https://github.com/pyinstaller/pyinstaller.  As of 2015, it consists of:

* Hartmut Goebel
* Martin Zibricky
* David Vierra
* David Cortesi


Our Copyright Policy
--------------------

PyInstaller uses a shared copyright model. Each contributor maintains copyright
over their contributions to PyInstaller. But, it is important to note that
these
contributions are typically only changes to the repositories. Thus,
the PyInstaller source code, in its entirety is not the copyright of any single
person or institution.  Instead, it is the collective copyright of the entire
PyInstaller Development Team.  If individual contributors want to maintain
a record of what changes/contributions they have specific copyright on, they
should indicate their copyright in the commit message of the change, when they
commit the change to the PyInstaller repository.

With this in mind, the following banner should be used in any source code file
to indicate the copyright and license terms:


#-----------------------------------------------------------------------------
# Copyright (c) 2005-2020, PyInstaller Development Team.
#
# Distributed under the terms of the GNU General Public License (version 2
# or later) with exception for distributing the bootloader.
#
# The full license is in the file COPYING.txt, distributed with this software.
#
# SPDX-License-Identifier: (GPL-2.0-or-later WITH Bootloader-exception)
#-----------------------------------------------------------------------------



GNU General Public License
--------------------------

https://gnu.org/licenses/gpl-2.0.html


		    GNU GENERAL PUBLIC LICENSE
		       Version 2, June 1991

 Copyright (C) 1989, 1991 Free Software Foundation, Inc.
 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA
 Everyone is permitted to copy and distribute verbatim copies
 of this license document, but changing it is not allowed.

			    Preamble

  The licenses for most software are designed to take away your
freedom to share and change it.  By contrast, the GNU General Public
License is intended to guarantee your freedom to share and change free
software--to make sure the software is free for all its users.  This
General Public License applies to most of the Free Software
Foundation's software and to any other program whose authors commit to
using it.  (Some other Free Software Foundation software is covered by
the GNU Library General Public License instead.)  You can apply it to
your programs, too.

  When we speak of free software, we are referring to freedom, not
price.  Our General Public Licenses are designed to make sure that you
have the freedom to distribute copies of free software (and charge for
this service if you wish), that you receive source code or can get it
if you want it, that you can change the software or use pieces of it
in new free programs; and that you know you can do these things.

  To protect your rights, we need to make restrictions that forbid
anyone to deny you these rights or to ask you to surrender the rights.
These restrictions translate to certain responsibilities for you if you
distribute copies of the software, or if you modify it.

  For example, if you distribute copies of such a program, whether
gratis or for a fee, you must give the recipients all the rights that
you have.  You must make sure that they, too, receive or can get the
source code.  And you must show them these terms so they know their
rights.

  We protect your rights with two steps: (1) copyright the software, and
(2) offer you this license which gives you legal permission to copy,
distribute and/or modify the software.

  Also, for each author's protection and ours, we want to make certain
that everyone understands that there is no warranty for this free
software.  If the software is modified by someone else and passed on, we
want its recipients to know that what they have is not the original, so
that any problems introduced by others will not reflect on the original
authors' reputations.

  Finally, any free program is threatened constantly by software
patents.  We wish to avoid the danger that redistributors of a free
program will individually obtain patent licenses, in effect making the
program proprietary.  To prevent this, we have made it clear that any
patent must be licensed for everyone's free use or not licensed at all.

  The precise terms and conditions for copying, distribution and
modification follow.

		    GNU GENERAL PUBLIC LICENSE
   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION

  0. This License applies to any program or other work which contains
a notice placed by the copyright holder saying it may be distributed
under the terms of this General Public License.  The "Program", below,
refers to any such program or work, and a "work based on the Program"
means either the Program or any derivative work under copyright law:
that is to say, a work containing the Program or a portion of it,
either verbatim or with modifications and/or translated into another
language.  (Hereinafter, translation is included without limitation in
the term "modification".)  Each licensee is addressed as "you".

Activities other than copying, distribution and modification are not
covered by this License; they are outside its scope.  The act of
running the Program is not restricted, and the output from the Program
is covered only if its contents constitute a work based on the
Program (independent of having been made by running the Program).
Whether that is true depends on what the Program does.

  1. You may copy and distribute verbatim copies of the Program's
source code as you receive it, in any medium, provided that you
conspicuously and appropriately publish on each copy an appropriate
copyright notice and disclaimer of warranty; keep intact all the
notices that refer to this License and to the absence of any warranty;
and give any other recipients of the Program a copy of this License
along with the Program.

You may charge a fee for the physical act of transferring a copy, and
you may at your option offer warranty protection in exchange for a fee.

  2. You may modify your copy or copies of the Program or any portion
of it, thus forming a work based on the Program, and copy and
distribute such modifications or work under the terms of Section 1
above, provided that you also meet all of these conditions:

    a) You must cause the modified files to carry prominent notices
    stating that you changed the files and the date of any change.

    b) You must cause any work that you distribute or publish, that in
    whole or in part contains or is derived from the Program or any
    part thereof, to be licensed as a whole at no charge to all third
    parties under the terms of this License.

    c) If the modified program normally reads commands interactively
    when run, you must cause it, when started running for such
    interactive use in the most ordinary way, to print or display an
    announcement including an appropriate copyright notice and a
    notice that there is no warranty (or else, saying that you provide
    a warranty) and that users may redistribute the program under
    these conditions, and telling the user how to view a copy of this
    License.  (Exception: if the Program itself is interactive but
    does not normally print such an announcement, your work based on
    the Program is not required to print an announcement.)

These requirements apply to the modified work as a whole.  If
identifiable sections of that work are not derived from the Program,
and can be reasonably considered independent and separate works in
themselves, then this License, and its terms, do not apply to those
sections when you distribute them as separate works.  But when you
distribute the same sections as part of a whole which is a work based
on the Program, the distribution of the whole must be on the terms of
this License, whose permissions for other licensees extend to the
entire whole, and thus to each and every part regardless of who wrote it.

Thus, it is not the intent of this section to claim rights or contest
your rights to work written entirely by you; rather, the intent is to
exercise the right to control the distribution of derivative or
collective works based on the Program.

In addition, mere aggregation of another work not based on the Program
with the Program (or with a work based on the Program) on a volume of
a storage or distribution medium does not bring the other work under
the scope of this License.

  3. You may copy and distribute the Program (or a work based on it,
under Section 2) in object code or executable form under the terms of
Sections 1 and 2 above provided that you also do one of the following:

    a) Accompany it with the complete corresponding machine-readable
    source code, which must be distributed under the terms of Sections
    1 and 2 above on a medium customarily used for software interchange; or,

    b) Accompany it with a written offer, valid for at least three
    years, to give any third party, for a charge no more than your
    cost of physically performing source distribution, a complete
    machine-readable copy of the corresponding source code, to be
    distributed under the terms of Sections 1 and 2 above on a medium
    customarily used for software interchange; or,

    c) Accompany it with the information you received as to the offer
    to distribute corresponding source code.  (This alternative is
    allowed only for noncommercial distribution and only if you
    received the program in object code or executable form with such
    an offer, in accord with Subsection b above.)

The source code for a work means the preferred form of the work for
making modifications to it.  For an executable work, complete source
code means all the source code for all modules it contains, plus any
associated interface definition files, plus the scripts used to
control compilation and installation of the executable.  However, as a
special exception, the source code distributed need not include
anything that is normally distributed (in either source or binary
form) with the major components (compiler, kernel, and so on) of the
operating system on which the executable runs, unless that component
itself accompanies the executable.

If distribution of executable or object code is made by offering
access to copy from a designated place, then offering equivalent
access to copy the source code from the same place counts as
distribution of the source code, even though third parties are not
compelled to copy the source along with the object code.

  4. You may not copy, modify, sublicense, or distribute the Program
except as expressly provided under this License.  Any attempt
otherwise to copy, modify, sublicense or distribute the Program is
void, and will automatically terminate your rights under this License.
However, parties who have received copies, or rights, from you under
this License will not have their licenses terminated so long as such
parties remain in full compliance.

  5. You are not required to accept this License, since you have not
signed it.  However, nothing else grants you permission to modify or
distribute the Program or its derivative works.  These actions are
prohibited by law if you do not accept this License.  Therefore, by
modifying or distributing the Program (or any work based on the
Program), you indicate your acceptance of this License to do so, and
all its terms and conditions for copying, distributing or modifying
the Program or works based on it.

  6. Each time you redistribute the Program (or any work based on the
Program), the recipient automatically receives a license from the
original licensor to copy, distribute or modify the Program subject to
these terms and conditions.  You may not impose any further
restrictions on the recipients' exercise of the rights granted herein.
You are not responsible for enforcing compliance by third parties to
this License.

  7. If, as a consequence of a court judgment or allegation of patent
infringement or for any other reason (not limited to patent issues),
conditions are imposed on you (whether by court order, agreement or
otherwise) that contradict the conditions of this License, they do not
excuse you from the conditions of this License.  If you cannot
distribute so as to satisfy simultaneously your obligations under this
License and any other pertinent obligations, then as a consequence you
may not distribute the Program at all.  For example, if a patent
license would not permit royalty-free redistribution of the Program by
all those who receive copies directly or indirectly through you, then
the only way you could satisfy both it and this License would be to
refrain entirely from distribution of the Program.

If any portion of this section is held invalid or unenforceable under
any particular circumstance, the balance of the section is intended to
apply and the section as a whole is intended to apply in other
circumstances.

It is not the purpose of this section to induce you to infringe any
patents or other property right claims or to contest validity of any
such claims; this section has the sole purpose of protecting the
integrity of the free software distribution system, which is
implemented by public license practices.  Many people have made
generous contributions to the wide range of software distributed
through that system in reliance on consistent application of that
system; it is up to the author/donor to decide if he or she is willing
to distribute software through any other system and a licensee cannot
impose that choice.

This section is intended to make thoroughly clear what is believed to
be a consequence of the rest of this License.

  8. If the distribution and/or use of the Program is restricted in
certain countries either by patents or by copyrighted interfaces, the
original copyright holder who places the Program under this License
may add an explicit geographical distribution limitation excluding
those countries, so that distribution is permitted only in or among
countries not thus excluded.  In such case, this License incorporates
the limitation as if written in the body of this License.

  9. The Free Software Foundation may publish revised and/or new versions
of the General Public License from time to time.  Such new versions will
be similar in spirit to the present version, but may differ in detail to
address new problems or concerns.

Each version is given a distinguishing version number.  If the Program
specifies a version number of this License which applies to it and "any
later version", you have the option of following the terms and conditions
either of that version or of any later version published by the Free
Software Foundation.  If the Program does not specify a version number of
this License, you may choose any version ever published by the Free Software
Foundation.

  10. If you wish to incorporate parts of the Program into other free
programs whose distribution conditions are different, write to the author
to ask for permission.  For software which is copyrighted by the Free
Software Foundation, write to the Free Software Foundation; we sometimes
make exceptions for this.  Our decision will be guided by the two goals
of preserving the free status of all derivatives of our free software and
of promoting the sharing and reuse of software generally.

			    NO WARRANTY

  11. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY
FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW.  EXCEPT WHEN
OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES
PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED
OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS
TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE
PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING,
REPAIR OR CORRECTION.

  12. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR
REDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES,
INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING
OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED
TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY
YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER
PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE
POSSIBILITY OF SUCH DAMAGES.

		     END OF TERMS AND CONDITIONS

------

** six; version 1.14.0 -- https://github.com/benjaminp/six/tree/1.14.0
Copyright (c) 2010-2020 Benjamin Peterson

Copyright (c) 2010-2020 Benjamin Peterson

Permission is hereby granted, free of charge, to any person obtaining a copy of
this software and associated documentation files (the "Software"), to deal in
the Software without restriction, including without limitation the rights to
use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
of
the Software, and to permit persons to whom the Software is furnished to do so,
subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS
FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

------

** urllib3; version 1.25.8 -- https://github.com/urllib3/urllib3/tree/1.25.8
Copyright (c) 2008-2019 Andrey Petrov and contributors (see CONTRIBUTORS.txt)

MIT License

Copyright (c) 2008-2019 Andrey Petrov and contributors (see CONTRIBUTORS.txt)

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

------

** setuptools; version 45.2.0 --
https://github.com/pypa/setuptools/tree/v45.2.0
Copyright (C) 2016 Jason R Coombs <jaraco@jaraco.com>

Permission is hereby granted, free of charge, to any person obtaining a copy of
this software and associated documentation files (the "Software"), to deal in
the Software without restriction, including without limitation the rights to
use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
of the Software, and to permit persons to whom the Software is furnished to do
so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

------

** wcwidth; version 0.1.8 -- https://github.com/jquast/wcwidth/tree/0.1.8
Copyright (c) 2014 Jeff Quast <contact@jeffquast.com>

The MIT License (MIT)

Copyright (c) 2014 Jeff Quast <contact@jeffquast.com>

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

------

** jmespath; version 0.9.4 --
https://github.com/jmespath/jmespath.py/tree/0.9.4
Copyright (c) 2013 Amazon.com, Inc. or its affiliates.  All Rights Reserved

Copyright (c) 2013 Amazon.com, Inc. or its affiliates.  All Rights Reserved

Permission is hereby granted, free of charge, to any person obtaining a
copy of this software and associated documentation files (the
"Software"), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish, dis-
tribute, sublicense, and/or sell copies of the Software, and to permit
persons to whom the Software is furnished to do so, subject to the fol-
lowing conditions:

The above copyright notice and this permission notice shall be included
in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABIL-
ITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT
SHALL THE AUTHOR BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
IN THE SOFTWARE.

------

** ruamel.yaml; version 0.15.100 --
https://sourceforge.net/p/ruamel-yaml/code/ci/default/tree/
Copyright (c) 2014-2019 Anthon van der Neut, Ruamel bvba

 The MIT License (MIT)

 Copyright (c) 2014-2020 Anthon van der Neut, Ruamel bvba

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in
 all copies or substantial portions of the Software.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 SOFTWARE.

------

** OpenSSL; version 1.0.2s --
https://github.com/openssl/openssl/tree/OpenSSL_1_0_1s
Copyright (c) 1998-2011 The OpenSSL Project.  All rights reserved.
Copyright (C) 1995-1998 Eric Young (eay@cryptsoft.com)

LICENSE ISSUES
  ==============

  The OpenSSL toolkit stays under a double license, i.e. both the conditions of
  the OpenSSL License and the original SSLeay license apply to the toolkit.
  See below for the actual license texts.

  OpenSSL License
  ---------------

/* ====================================================================
 * Copyright (c) 1998-2017 The OpenSSL Project.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. All advertising materials mentioning features or use of this
 *    software must display the following acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit. (http://www.openssl.org/)"
 *
 * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
 *    endorse or promote products derived from this software without
 *    prior written permission. For written permission, please contact
 *    openssl-core@openssl.org.
 *
 * 5. Products derived from this software may not be called "OpenSSL"
 *    nor may "OpenSSL" appear in their names without prior written
 *    permission of the OpenSSL Project.
 *
 * 6. Redistributions of any form whatsoever must retain the following
 *    acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit (http://www.openssl.org/)"
 *
 * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
 * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE.
 * ====================================================================
 *
 * This product includes cryptographic software written by Eric Young
 * (eay@cryptsoft.com).  This product includes software written by Tim
 * Hudson (tjh@cryptsoft.com).
 *
 */

 Original SSLeay License
 -----------------------

/* Copyright (C) 1995-1998 Eric Young (eay@cryptsoft.com)
 * All rights reserved.
 *
 * This package is an SSL implementation written
 * by Eric Young (eay@cryptsoft.com).
 * The implementation was written so as to conform with Netscapes SSL.
 *
 * This library is free for commercial and non-commercial use as long as
 * the following conditions are aheared to.  The following conditions
 * apply to all code found in this distribution, be it the RC4, RSA,
 * lhash, DES, etc., code; not just the SSL code.  The SSL documentation
 * included with this distribution is covered by the same copyright terms
 * except that the holder is Tim Hudson (tjh@cryptsoft.com).
 *
 * Copyright remains Eric Young's, and as such any Copyright notices in
 * the code are not to be removed.
 * If this package is used in a product, Eric Young should be given attribution
 * as the author of the parts of the library used.
 * This can be in the form of a textual message at program startup or
 * in documentation (online or textual) provided with the package.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *    "This product includes cryptographic software written by
 *     Eric Young (eay@cryptsoft.com)"
 *    The word 'cryptographic' can be left out if the rouines from the library
 *    being used are not cryptographic related :-).
 * 4. If you include any Windows specific code (or a derivative thereof) from
 * the apps directory (application code) you must include an acknowledgement:
 * "This product includes software written by Tim Hudson (tjh@cryptsoft.com)"
 *
 * THIS SOFTWARE IS PROVIDED BY ERIC YOUNG ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * The licence and distribution terms for any publically available version or
 * derivative of this code cannot be changed.  i.e. this code cannot simply be
 * copied and put under another distribution licence
 * [including the GNU Public Licence.]
 */

------

** Python 3.9.11; version 3.9.11 -- https://github.com/python/cpython/tree/v3.9.11
Copyright ¬© 2001-2020 Python Software Foundation. All rights reserved.

PYTHON SOFTWARE FOUNDATION LICENSE VERSION 2
--------------------------------------------

1. This LICENSE AGREEMENT is between the Python Software Foundation
("PSF"), and the Individual or Organization ("Licensee") accessing and
otherwise using this software ("Python") in source or binary form and
its associated documentation.

2. Subject to the terms and conditions of this License Agreement, PSF hereby
grants Licensee a nonexclusive, royalty-free, world-wide license to reproduce,
analyze, test, perform and/or display publicly, prepare derivative works,
distribute, and otherwise use Python alone or in any derivative version,
provided, however, that PSF's License Agreement and PSF's notice of copyright,
i.e., "Copyright (c) 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009,
2010,
2011, 2012, 2013, 2014, 2015, 2016, 2017, 2018, 2019, 2020 Python Software
Foundation;
All Rights Reserved" are retained in Python alone or in any derivative version
prepared by Licensee.

3. In the event Licensee prepares a derivative work that is based on
or incorporates Python or any part thereof, and wants to make
the derivative work available to others as provided herein, then
Licensee hereby agrees to include in any such work a brief summary of
the changes made to Python.

4. PSF is making Python available to Licensee on an "AS IS"
basis.  PSF MAKES NO REPRESENTATIONS OR WARRANTIES, EXPRESS OR
IMPLIED.  BY WAY OF EXAMPLE, BUT NOT LIMITATION, PSF MAKES NO AND
DISCLAIMS ANY REPRESENTATION OR WARRANTY OF MERCHANTABILITY OR FITNESS
FOR ANY PARTICULAR PURPOSE OR THAT THE USE OF PYTHON WILL NOT
INFRINGE ANY THIRD PARTY RIGHTS.

5. PSF SHALL NOT BE LIABLE TO LICENSEE OR ANY OTHER USERS OF PYTHON
FOR ANY INCIDENTAL, SPECIAL, OR CONSEQUENTIAL DAMAGES OR LOSS AS
A RESULT OF MODIFYING, DISTRIBUTING, OR OTHERWISE USING PYTHON,
OR ANY DERIVATIVE THEREOF, EVEN IF ADVISED OF THE POSSIBILITY THEREOF.

6. This License Agreement will automatically terminate upon a material
breach of its terms and conditions.

7. Nothing in this License Agreement shall be deemed to create any
relationship of agency, partnership, or joint venture between PSF and
Licensee.  This License Agreement does not grant permission to use PSF
trademarks or trade name in a trademark sense to endorse or promote
products or services of Licensee, or any third party.

8. By copying, installing or otherwise using Python, Licensee
agrees to be bound by the terms and conditions of this License
Agreement.



------

** docutils; version 0.15.2 --
https://sourceforge.net/p/docutils/code/HEAD/tree/trunk/docutils/
:Author: David Goodger
:Contact: goodger@python.org
:Date: $Date: 2015-05-08 15:56:32 +0000 (Fri, 08 May 2015) $
:Web site: http://docutils.sourceforge.net/
:Copyright: This document has been placed in the public domain.

==================
 Copying Docutils
==================

:Author: David Goodger
:Contact: goodger@python.org
:Date: $Date: 2015-05-08 15:56:32 +0000 (Fri, 08 May 2015) $
:Web site: http://docutils.sourceforge.net/
:Copyright: This document has been placed in the public domain.

Most of the files included in this project have been placed in the
public domain, and therefore have no license requirements and no
restrictions on copying or usage; see the `Public Domain Dedication`_
below.  There are a few exceptions_, listed below.
Files in the Sandbox_ are not distributed with Docutils releases and
may have different license terms.


Public Domain Dedication
========================

The persons who have associated their work with this project (the
"Dedicator": David Goodger and the many contributors to the Docutils
project) hereby dedicate the entire copyright, less the exceptions_
listed below, in the work of authorship known as "Docutils" identified
below (the "Work") to the public domain.

The primary repository for the Work is the Internet World Wide Web
site <http://docutils.sourceforge.net/>.  The Work consists of the
files within the "docutils" module of the Docutils project Subversion
repository (Internet host docutils.svn.sourceforge.net, filesystem path
/svnroot/docutils), whose Internet web interface is located at
<http://docutils.svn.sourceforge.net/viewvc/docutils/>.  Files dedicated to the
public domain may be identified by the inclusion, near the beginning
of each file, of a declaration of the form::

    Copyright: This document/module/DTD/stylesheet/file/etc. has been
               placed in the public domain.

Dedicator makes this dedication for the benefit of the public at large
and to the detriment of Dedicator's heirs and successors.  Dedicator
intends this dedication to be an overt act of relinquishment in
perpetuity of all present and future rights under copyright law,
whether vested or contingent, in the Work.  Dedicator understands that
such relinquishment of all rights includes the relinquishment of all
rights to enforce (by lawsuit or otherwise) those copyrights in the
Work.

Dedicator recognizes that, once placed in the public domain, the Work
may be freely reproduced, distributed, transmitted, used, modified,
built upon, or otherwise exploited by anyone for any purpose,
commercial or non-commercial, and in any way, including by methods
that have not yet been invented or conceived.

(This dedication is derived from the text of the `Creative Commons
Public Domain Dedication`. [#]_)

.. [#] Creative Commons has `retired this legal tool`__ and does not
   recommend that it be applied to works: This tool is based on United
   States law and may not be applicable outside the US. For dedicating new
   works to the public domain, Creative Commons recommend the replacement
   Public Domain Dedication CC0_ (CC zero, "No Rights Reserved"). So does
   the Free Software Foundation in its license-list_.

   __  http://creativecommons.org/retiredlicenses
   .. _CC0: http://creativecommons.org/about/cc0

Exceptions
==========

The exceptions to the `Public Domain Dedication`_ above are:

* docutils/writers/s5_html/themes/default/iepngfix.htc:

      IE5.5+ PNG Alpha Fix v1.0 by Angus Turnbull
      <http://www.twinhelix.com>.  Free usage permitted as long as
      this notice remains intact.

* docutils/utils/math/__init__.py,
  docutils/utils/math/latex2mathml.py,
  docutils/writers/xetex/__init__.py,
  docutils/writers/latex2e/docutils-05-compat.sty,
  docs/user/docutils-05-compat.sty.txt,
  docutils/utils/error_reporting.py,
  docutils/test/transforms/test_smartquotes.py:

  Copyright ¬© G√ºnter Milde.
  Released under the terms of the `2-Clause BSD license`_
  (`local copy <licenses/BSD-2-Clause.txt>`__).

* docutils/utils/smartquotes.py

  Copyright ¬© 2011 G√ºnter Milde,
  based on `SmartyPants`_ ¬© 2003 John Gruber
  (released under a 3-Clause BSD license included in the file)
  and smartypants.py ¬© 2004, 2007 Chad Miller.
  Released under the terms of the `2-Clause BSD license`_
  (`local copy <licenses/BSD-2-Clause.txt>`__).

  .. _SmartyPants: http://daringfireball.net/projects/smartypants/

* docutils/utils/math/math2html.py,
  docutils/writers/html4css1/math.css

  Copyright ¬© Alex Fern√°ndez
  These files are part of eLyXer_, released under the `GNU
  General Public License`_ version 3 or later. The author relicensed
  them for Docutils under the terms of the `2-Clause BSD license`_
  (`local copy <licenses/BSD-2-Clause.txt>`__).

  .. _eLyXer: http://www.nongnu.org/elyxer/

* docutils/utils/roman.py, copyright by Mark Pilgrim, released under the
  `Python 2.1.1 license`_ (`local copy`__).

  __ licenses/python-2-1-1.txt

* tools/editors/emacs/rst.el, copyright by Free Software Foundation,
  Inc., released under the `GNU General Public License`_ version 3 or
  later (`local copy`__).

  __ licenses/gpl-3-0.txt

The `2-Clause BSD license`_ and the Python licenses are OSI-approved_
and GPL-compatible_.

Plaintext versions of all the linked-to licenses are provided in the
licenses_ directory.

.. _sandbox: http://docutils.sourceforge.net/sandbox/README.html
.. _licenses: licenses/
.. _Python 2.1.1 license: http://www.python.org/2.1.1/license.html
.. _GNU General Public License: http://www.gnu.org/copyleft/gpl.html
.. _2-Clause BSD license: http://www.spdx.org/licenses/BSD-2-Clause
.. _OSI-approved: http://opensource.org/licenses/
.. _license-list:
.. _GPL-compatible: http://www.gnu.org/licenses/license-list.html// END OF FILE: aws/THIRD_PARTY_LICENSES

//---> PATH: /home/mbogneng-junior/freelance-driver_Sylladb/backend/cors.xml

<CORSConfiguration>
  <CORSRule>
    <AllowedOrigin>*</AllowedOrigin>
    <AllowedMethod>GET</AllowedMethod>
    <AllowedMethod>PUT</AllowedMethod>
    <AllowedMethod>POST</AllowedMethod>
    <AllowedMethod>DELETE</AllowedMethod>
    <AllowedHeader>*</AllowedHeader>
  </CORSRule>
</CORSConfiguration>
// END OF FILE: cors.xml

//---> PATH: /home/mbogneng-junior/freelance-driver_Sylladb/backend/docker-compose.yml

version: '3.8' # AJOUT√â : Bonne pratique et n√©cessaire pour la gestion des ressources

services:
  scylla-db:
    image: scylladb/scylla:latest
    container_name: scylla-node-prod # MODIFI√â : Nom plus appropri√© pour le d√©ploiement
    ports:
      - "9042:9042"
    
    # AJOUT√â : Section cruciale pour garantir l'allocation de m√©moire par Docker
    deploy:
      resources:
        limits:
          memory: 1G
        reservations:
          memory: 1G
          
    # MODIFI√â : On retire "--memory 1G" car Docker g√®re maintenant la m√©moire
    command: --smp 1 --developer-mode 1 
    
    volumes:
      - scylla_data:/var/lib/scylla
    networks: # AJOUT√â : Pour la communication entre conteneurs
      - freelance-net

  # AJOUT√â : Le service MinIO pour avoir une configuration compl√®te
 

volumes:
  scylla_data:

# AJOUT√â : D√©finition du r√©seau partag√©
networks:
  freelance-net:
    driver: bridge// END OF FILE: docker-compose.yml

//---> PATH: /home/mbogneng-junior/freelance-driver_Sylladb/backend/docker/docker-compose-stack.yml

services:
  # SERVER: CONFIG SERVER -----------------------------------------------------------
  freelance-driver-service:
    image: ${IMAGE_TAG}
    environment:
      - SPRING_PROFILES_ACTIVE=dev-resource-mock
      - MICROSERVICES_AUTH_SERVICE_URL=https://gateway.yowyob.com/auth-service
      - MICROSERVICES_ORGANISATION_SERVICE_URL=https://gateway.yowyob.com/organization-service
      - MICROSERVICES_CHAT_SERVICE_URL=http://88.198.150.195:8613
      - MICROSERVICES_NOTIFICATION_SERVICE_URL=https://gateway.yowyob.com/notification-service
      - MICROSERVICES_RESOURCE_SERVICE_URL=https://gateway.yowyob.com/resource-service
      - MICROSERVICES_MEDIA_SERVICE_URL=https://gateway.yowyob.com/media-service
      - FREELANCE_DRIVER_API_PUBLIC_KEY=api_1752647119025_8d6e5340.ieGsWPxnE9eY0xBQ7n8htlTiQP3n4009
      - FREELANCE_DRIVER_CHAT_PROJECT_ID=25cf4dfd-e847-4b59-91c7-034aa5afc200
      - FREELANCE_DRIVER_OAUTH2_CLIENT_ID=test-client
      - FREELANCE_DRIVER_OAUTH2_CLIENT_SECRET=secret
      - FREELANCE_DRIVER_OAUTH2_TOKEN_URL=https://gateway.yowyob.com/auth-service/oauth/token
      - SPRING_SECURITY_OAUTH2_RESOURCESERVER_JWK_URI=https://gateway.yowyob.com/auth-service/openid/.well-known/jwks.json
      - SPRING_DEVTOOLS_RESTART_ENABLED=true
      - SPRING_DATA_CASSANDRA_REQUEST_TIMEOUT=20s
      - SPRING_DATA_CASSANDRA_CONNECTION_CONNECT_TIMEOUT=20s
      - SPRING_DATA_CASSANDRA_CONNECTION_INIT_QUERY_TIMEOUT=20s
      - SPRING_MAIL_HOST=smtp.gmail.com
      - SPRING_MAIL_PORT=587
      - SPRING_MAIL_USERNAME=mbognengj@gmail.com
      - SPRING_MAIL_PASSWORD=fmpjyadvpepfvcws
      - SPRING_MAIL_PROPERTIES_MAIL_SMTP_AUTH=true
      - SPRING_MAIL_PROPERTIES_MAIL_SMTP_STARTTLS_ENABLE=true
      - SPRING_MAIL_PROPERTIES_MAIL_DEBUG=true
      - MINIO_ENDPOINT=http://192.168.43.204:9000
      - MINIO_ACCESS_KEY=junioradmin
      - MINIO_SECRET_KEY=YourStrongPassword2025
      - MINIO_BUCKET_NAME=freelance-driver
      - SOCKETIO_SERVER_HOST=0.0.0.0
      - SOCKETIO_SERVER_PORT=8081
      - SPRING_DATA_CASSANDRA_DATACENTER=DC1
      - SPRING_DATA_CASSANDRA_KEYSPACE=${FREELANCE_DRIVER_KEYSPACE}
      - SPRING_DATA_CASSANDRA_CONTACT_POINTS=${SCYLLA_DB_CONTACT_POINTS}
      - SPRING_DATA_CASSANDRA_PORT=9042
    ports:
      - target: 8080
        published: ${FREELANCE_DRIVER_SERVICE_PORT}
        protocol: tcp
        mode: host
      - target: 8081
        published: ${FREELANCE_DRIVER_WS_PORT}
        protocol: tcp
        mode: host
    networks:
      - openia-main-network

networks:
  openia-main-network:
    external: true
// END OF FILE: docker/docker-compose-stack.yml

//---> PATH: /home/mbogneng-junior/freelance-driver_Sylladb/backend/docker/docker-compose.yml

services:
  organization-service:
    image: yowyob/organization-service
    container_name: yowyob-organization-service
    build:
      context: ../
      dockerfile: docker/Dockerfile
    environment:
      - CONFIG_SERVER_URL=${CONFIG_SERVER_URL}
    networks:
      - openia-main-network
    ports:
      - 8089:8080
# NETWORKS ------------------------------------------------------------------------
networks:
  openia-main-network:
    external: true// END OF FILE: docker/docker-compose.yml

//---> PATH: /home/mbogneng-junior/freelance-driver_Sylladb/backend/docker/Dockerfile

FROM openjdk:21-slim

ARG JAVA_OPTS
ARG SPRING_PROFILES_ACTIVE=development

ENV JAVA_OPTS=$JAVA_OPTS
ENV SPRING_PROFILES_ACTIVE=$SPRING_PROFILES_ACTIVE
ENV SERVICE_NAME=freelance-driver-service
ARG JAR_FILE=target/*.jar
ADD ${JAR_FILE} ${SERVICE_NAME}.jar

EXPOSE 8080 8081

ENTRYPOINT ["sh", "-c", "java $JAVA_OPTS -DSPRING_PROFILES_ACTIVE=$SPRING_PROFILES_ACTIVE -jar $SERVICE_NAME.jar"]
// END OF FILE: docker/Dockerfile

//---> PATH: /home/mbogneng-junior/freelance-driver_Sylladb/backend/Dockerfile

# --- Stage 1: Build a lightweight production JAR ---
FROM maven:3.9-eclipse-temurin-21 AS builder
WORKDIR /app

# Copy only necessary maven wrapper files first for better caching
COPY .mvn .mvn
COPY mvnw pom.xml ./

# Download dependencies. This layer is cached as long as pom.xml doesn't change.
RUN ./mvnw dependency:go-offline

# Copy the rest of the source code
COPY src ./src

# Build the application JAR
RUN ./mvnw clean package -DskipTests


# --- Stage 2: Create a minimal and secure final image ---
FROM eclipse-temurin:21-jre-alpine

# Set arguments for user and group
ARG APP_GROUP=yowyob
ARG APP_USER=yowyob

WORKDIR /app

# Create a non-root user for security
RUN addgroup -S $APP_GROUP && adduser -S $APP_USER -G $APP_GROUP

# Copy the built JAR from the builder stage with the correct owner
COPY --from=builder --chown=$APP_USER:$APP_GROUP /app/target/*.jar app.jar

# Switch to the non-root user
USER $APP_USER:$APP_GROUP


# Expose ports for the application API and WebSocket server
EXPOSE 8080 9092

# Entrypoint to run the application
# Using exec form is a best practice for signal handling
ENTRYPOINT ["java", "-jar", "/app/app.jar"]// END OF FILE: Dockerfile

//---> PATH: /home/mbogneng-junior/freelance-driver_Sylladb/backend/.env

# Ce fichier est auto-g√©n√©r√© par init_application.sh
SYSTEM_ORGANIZATION_ID=73ba467d-9b2e-481a-827e-edbddc4f775d
SMTP_SETTING_ID=bf1cc922-3e8c-4dd5-b6fb-7a69c0ba0250
FIREBASE_SETTING_ID=c3389947-110e-4f79-925c-ce19072a6e2a
DESIGN_EMAIL_OTP_ID=d11ef854-3b00-44aa-b4ad-c889806664c4
TEMPLATE_EMAIL_OTP_ID=99f0fa9f-80bd-4e54-8385-a3e0dee99770
TEMPLATE_PUSH_NEW_PLANNING_ID=c4af6e04-2dd8-4e58-9895-140cf3f6fa96
TEMPLATE_PUSH_NEW_ANNOUNCEMENT_ID=d77bd848-e94c-4a6d-985c-e1d7688928d6
TEMPLATE_PUSH_ANNOUNCEMENT_ACCEPTED_ID=1a7b8f5c-2d3e-4f6a-8b9c-0a1b2c3d4e5f
TEMPLATE_PUSH_ANNOUNCEMENT_CONFIRMED_ID=4a1b2c3d-4e5f-6a7b-8c9d-0e1f2a3b4c5d
TEMPLATE_PUSH_POSTULATION_CANCELLED_ID=b1c2d3e4-f5a6-7b8c-9d0e-1f2a3b4c5d6e
TEMPLATE_PUSH_PLANNING_BOOKING_REQUESTED_TO_DRIVER_ID=0a1b2c3d-4e5f-6a7b-8c9d-0e1f2a3b4c5d
TEMPLATE_PUSH_PLANNING_BOOKING_ACCEPTED_TO_CLIENT_ID=f1e2d3c4-b5a6-7890-1234-567890abcde0
TEMPLATE_PUSH_PLANNING_RESERVATION_CANCELLED_ID=1b2c3d4e-5f6a-7b8c-9d0e-1f2a3b4c5d6e// END OF FILE: .env

//---> PATH: /home/mbogneng-junior/freelance-driver_Sylladb/backend/.gitattributes

/mvnw text eol=lf
*.cmd text eol=crlf
// END OF FILE: .gitattributes

//---> PATH: /home/mbogneng-junior/freelance-driver_Sylladb/backend/.gitignore

HELP.md
target/
build/
.mvn/wrapper/maven-wrapper.jar
!**/src/main/**/target/
!**/src/test/**/target/
!**/src/main/**/build/
!**/src/test/**/build/
aws/

### STS ###
.apt_generated
.classpath
.factorypath
.project
.settings
.springBeans
.sts4-cache

### IntelliJ IDEA ###
.idea/
*.iws
*.iml
*.ipr

### NetBeans ###
/nbproject/private/
/nbbuild/
/dist/
/nbdist/
/.nb-gradle/

### VS Code ###
.vscode/

# OS files
.DS_Store
Thumbs.db

# Logs
*.log

# Gradle
.gradle/

# Maven
.mvn/

# Firebase/Secrets
/src/main/resources/firebase-service-account-key.json

// END OF FILE: .gitignore

//---> PATH: /home/mbogneng-junior/freelance-driver_Sylladb/backend/gitlab-ci/build.gitlab-ci.yml

build:
  stage: build
  tags: [yowyob]
  script:
    - cp src/main/resources/firebase-service-account-key.example src/main/resources/firebase-service-account-key.json
    - mvn $MAVEN_CLI_OPTS compile// END OF FILE: gitlab-ci/build.gitlab-ci.yml

//---> PATH: /home/mbogneng-junior/freelance-driver_Sylladb/backend/gitlab-ci/ci_settings.xml

<settings xmlns="http://maven.apache.org/SETTINGS/1.1.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://maven.apache.org/SETTINGS/1.1.0 http://maven.apache.org/xsd/settings-1.1.0.xsd">
  <servers>
    <server>
      <id>gitlab-maven</id>
      <username>${CI_INC_GROUP_DEPLOY_USER}</username>
      <password>${CI_INC_GROUP_DEPLOY_TOKEN}</password>
      <configuration>
        <authenticationInfo>
          <userName>${CI_INC_GROUP_DEPLOY_USER}</userName>
          <password>${CI_INC_GROUP_DEPLOY_TOKEN}</password>
        </authenticationInfo>
        <httpHeaders>
          <property>
            <name>${CI_INC_GROUP_DEPLOY_USER}</name>
            <value>${CI_INC_GROUP_DEPLOY_TOKEN}</value>
          </property>
        </httpHeaders>
      </configuration>
    </server>
  </servers>
</settings>// END OF FILE: gitlab-ci/ci_settings.xml

//---> PATH: /home/mbogneng-junior/freelance-driver_Sylladb/backend/gitlab-ci/deploy.gitlab-ci.yml

deploy:
  stage: deploy
  tags: [yowyob-cmd]
  dependencies:
    - docker-build
  before_script:
    - echo "$CI_REGISTRY_PASSWORD" | docker login "$CI_REGISTRY" -u "$CI_REGISTRY_USER" --password-stdin
  script:
    - docker pull "$IMAGE_TAG" || true
    - docker service rm "${SERVICE_STACK_NAME}_freelance-driver" || true
    - docker stack deploy -c docker/docker-compose-stack.yml "$SERVICE_STACK_NAME" --with-registry-auth
  rules:
    - if: '$CI_COMMIT_REF_NAME == "master"'
      variables:
        DEPLOYMENT_ENVIRONMENT: "production"
        ENVIRONMENT: "production"
    - when: always

// END OF FILE: gitlab-ci/deploy.gitlab-ci.yml

//---> PATH: /home/mbogneng-junior/freelance-driver_Sylladb/backend/gitlab-ci/docker-build.gitlab-ci.yml

docker-build:
  stage: docker-build
  tags: [yowyob-cmd]
  dependencies:
    - package
  script:
    - echo "Deploying to $SPRING_PROFILES_ACTIVE environment..."
    - echo "$CI_REGISTRY_PASSWORD" | docker login $CI_REGISTRY -u "$CI_REGISTRY_USER" --password-stdin
    - docker rmi "$IMAGE_TAG" || true
    - >-
      docker buildx build .
      --file docker/Dockerfile
      --no-cache
      --build-arg JAVA_OPTS="$JAVA_OPTS"
      --build-arg SPRING_PROFILES_ACTIVE="$SPRING_PROFILES_ACTIVE"
      --tag $IMAGE_TAG
      --push
    - docker image prune --force
    - echo "Deployment complete"
  rules:
    - if: '$CI_COMMIT_REF_NAME == "master"'
      variables:
        SPRING_PROFILES_ACTIVE: "production"// END OF FILE: gitlab-ci/docker-build.gitlab-ci.yml

//---> PATH: /home/mbogneng-junior/freelance-driver_Sylladb/backend/gitlab-ci/general.gitlab-ci.yml

variables:
  ENV_NAME: $CI_COMMIT_BRANCH
  GIT_STRATEGY: clone
  GIT_SUBMODULE_STRATEGY: recursive
  SPRING_PROFILES_ACTIVE: production
  MAVEN_OPTS: >-
    -Dmaven.repo.local=.m2/repository
  MAVEN_CLI_OPTS: >-
    -DskipTests
    -s gitlab-ci/ci_settings.xml

before_script:
  - |
    echo "Attempting to remove packages with groupId $REMOVE_GROUP_ID from Maven cache"
    if [ -d ".m2/repository/${REMOVE_GROUP_ID//./\/}" ]; then
      find .m2/repository/${REMOVE_GROUP_ID//./\/} -type d -exec rm -rf {} + 2>/dev/null || true
      echo "Packages removed successfully"
    else
      echo "Directory .m2/repository/${REMOVE_GROUP_ID//./\/} not found. Nothing to remove."
    fi
 

image: maven:latest
cache:
  paths:
    - .m2/repository

stages:
  - build
  - package
  - docker-build
  - deploy// END OF FILE: gitlab-ci/general.gitlab-ci.yml

//---> PATH: /home/mbogneng-junior/freelance-driver_Sylladb/backend/gitlab-ci/package.gitlab-ci.yml

package:
  stage: package
  tags: [yowyob]
  dependencies:
    - build
  script:
    - cp src/main/resources/firebase-service-account-key.example src/main/resources/firebase-service-account-key.json
    - mvn $MAVEN_CLI_OPTS clean compile install
    - mvn $MAVEN_CLI_OPTS deploy -DretryFailedDeploymentCount=3
  artifacts:
    paths:
      - target/*.jar
  only:
    - master
    - dev// END OF FILE: gitlab-ci/package.gitlab-ci.yml

//---> PATH: /home/mbogneng-junior/freelance-driver_Sylladb/backend/.gitlab-ci.yml

include:
  - local: "/gitlab-ci/general.gitlab-ci.yml"
  - local: "/gitlab-ci/build.gitlab-ci.yml"
  - local: "/gitlab-ci/docker-build.gitlab-ci.yml"
  - local: "/gitlab-ci/package.gitlab-ci.yml"
  - local: "/gitlab-ci/deploy.gitlab-ci.yml"
// END OF FILE: .gitlab-ci.yml

//---> PATH: /home/mbogneng-junior/freelance-driver_Sylladb/backend/init_application.sh

#!/bin/bash

# ==============================================================================
#           SCRIPT D'INITIALISATION DE L'ENVIRONNEMENT FREELANCE DRIVER
# Ce script configure une organisation syst√®me par d√©faut et tous les templates
# de notification n√©cessaires au fonctionnement de l'application.
#
# USAGE :
# 1. Assurez-vous que vos conteneurs Docker (ScyllaDB, MinIO) sont en cours d'ex√©cution.
# 2. Assurez-vous que votre backend Spring Boot est en cours d'ex√©cution sur le port 8080.
# 3. Rendez ce script ex√©cutable une fois avec : chmod +x init_application.sh
# 4. Ex√©cutez ce script depuis la racine de votre projet : ./init_application.sh
# ==============================================================================

echo "üöÄ D√©marrage du script d'initialisation de l'application..."

# --- CONFIGURATION PRINCIPALE ---
# On utilise des UUIDs constants et pr√©d√©finis.
# Ces IDs DOIVENT correspondre √† ceux d√©finis dans le code Java (ex: NotificationTriggerService).
SYS_ORG_ID="73ba467d-9b2e-481a-827e-edbddc4f775d"
SMTP_SETTING_ID="bf1cc922-3e8c-4dd5-b6fb-7a69c0ba0250"
FIREBASE_SETTING_ID="c3389947-110e-4f79-925c-ce19072a6e2a"

DESIGN_EMAIL_OTP_ID="d11ef854-3b00-44aa-b4ad-c889806664c4"
TEMPLATE_EMAIL_OTP_ID="99f0fa9f-80bd-4e54-8385-a3e0dee99770"

TEMPLATE_PUSH_NEW_PLANNING_ID="c4af6e04-2dd8-4e58-9895-140cf3f6fa96"
TEMPLATE_PUSH_NEW_ANNOUNCEMENT_ID="d77bd848-e94c-4a6d-985c-e1d7688928d6"
TEMPLATE_PUSH_ANNOUNCEMENT_ACCEPTED_ID="1a7b8f5c-2d3e-4f6a-8b9c-0a1b2c3d4e5f"

API_BASE_URL="http://localhost:8080"
ENV_FILE=".env"

# --- FONCTIONS UTILITAIRES ---
log_step() { echo -e "\nüî∑ --- √âTAPE $1: $2 ---"; }
# Fonction pour afficher la r√©ponse JSON de mani√®re lisible (n√©cessite l'outil 'jq')
log_response() { 
    if command -v jq &> /dev/null; then
        echo -e "  ‚û°Ô∏è  R√©ponse:\n$(echo "$1" | jq .)\n"
    else
        echo -e "  ‚û°Ô∏è  R√©ponse (brute):\n$1\n"
    fi
}
log_success() { echo -e "‚úÖ $1"; }
log_error() { echo -e "‚ùå ERREUR: $1"; exit 1; }

# ==============================================================================
#                         D√âBUT DU SCRIPT
# ==============================================================================

log_step 1 "Cr√©ation du fichier de configuration .env..."
rm -f $ENV_FILE
touch $ENV_FILE
{
    echo "# Ce fichier est auto-g√©n√©r√© par init_application.sh"
    echo "SYSTEM_ORGANIZATION_ID=$SYS_ORG_ID"
    echo "SMTP_SETTING_ID=$SMTP_SETTING_ID"
    echo "FIREBASE_SETTING_ID=$FIREBASE_SETTING_ID"
    echo "DESIGN_EMAIL_OTP_ID=$DESIGN_EMAIL_OTP_ID"
    echo "TEMPLATE_EMAIL_OTP_ID=$TEMPLATE_EMAIL_OTP_ID"
    echo "TEMPLATE_PUSH_NEW_PLANNING_ID=$TEMPLATE_PUSH_NEW_PLANNING_ID"
    echo "TEMPLATE_PUSH_NEW_ANNOUNCEMENT_ID=$TEMPLATE_PUSH_NEW_ANNOUNCEMENT_ID"
    echo "TEMPLATE_PUSH_ANNOUNCEMENT_ACCEPTED_ID=$TEMPLATE_PUSH_ANNOUNCEMENT_ACCEPTED_ID"
} >> $ENV_FILE
log_success "Fichier .env cr√©√© avec toutes les IDs de configuration."

# --- INSERTION DIRECTE EN BASE DE DONN√âES ---
log_step 2 "Insertion de l'organisation 'Syst√®me' dans la base de donn√©es..."
docker exec -it scylla-node-dev cqlsh -e "INSERT INTO freelancebd.mock_organisations (organization_id, long_name, description) VALUES ($SYS_ORG_ID, 'System Default', 'Organisation par d√©faut pour les templates globaux');"
if [ $? -ne 0 ]; then log_error "√âchec de l'insertion de l'organisation syst√®me dans ScyllaDB."; fi
log_success "Organisation 'Syst√®me' ins√©r√©e/mise √† jour dans la base de donn√©es."

# --- CR√âATION DES TEMPLATES VIA L'API ---
log_step 3 "Configuration des templates de notification via l'API..."

# 3.1 Cr√©ation du Setting SMTP
SMTP_PAYLOAD="{ \"id\": \"$SMTP_SETTING_ID\", \"host\": \"smtp.gmail.com\", \"port\": 587, \"encryption\": \"TLS\", \"username\": \"mbognengj@gmail.com\", \"password\": \"VOTRE_MOT_DE_PASSE_APPLICATION_GMAIL\", \"sender_email\": \"mbognengj@gmail.com\", \"sender_name\": \"Freelance Driver App\" }"
echo "  Requ√™te POST vers /smtp-settings"
SMTP_RESPONSE=$(curl -s -X POST "${API_BASE_URL}/api/mock-notifications/${SYS_ORG_ID}/smtp-settings" -H "Content-Type: application/json" -d "$SMTP_PAYLOAD")
log_response "$SMTP_RESPONSE"
log_success "Template SMTP cr√©√©/mis √† jour."

# 3.2 Cr√©ation du Setting Firebase
FIREBASE_KEY_JSON=$(cat src/main/resources/firebase-service-account-key.json | tr -d '\n\r' | sed 's/"/\\"/g')
FIREBASE_PAYLOAD="{ \"id\": \"$FIREBASE_SETTING_ID\", \"projectId\": \"freelance-driver-app\", \"privateKey\": \"$FIREBASE_KEY_JSON\" }"
echo "  Requ√™te POST vers /firebase-settings"
FIREBASE_RESPONSE=$(curl -s -X POST "${API_BASE_URL}/api/mock-notifications/${SYS_ORG_ID}/firebase-settings" -H "Content-Type: application/json" -d "$FIREBASE_PAYLOAD")
log_response "$FIREBASE_RESPONSE"
log_success "Template Firebase cr√©√©/mis √† jour."

# 3.3 Cr√©ation du Design de l'email OTP
DESIGN_OTP_PAYLOAD="{ \"id\": \"$DESIGN_EMAIL_OTP_ID\", \"title\": \"Email OTP\", \"subject\": \"Votre code de v√©rification : [[\${otpCode}]]\", \"html\": \"<!DOCTYPE html><html xmlns:th=\\\"http://www.thymeleaf.org\\\"><body><h1>Bonjour <span th:text=\\\"\${firstName}\\\"></span>,</h1><p>Votre code de v√©rification est :</p><h2 style='color: #007AFF;' th:text=\\\"\${otpCode}\\\"></h2></body></html>\" }"
echo "  Requ√™te POST vers /design-templates (OTP)"
DESIGN_OTP_RESPONSE=$(curl -s -X POST "${API_BASE_URL}/api/mock-notifications/${SYS_ORG_ID}/design-templates" -H "Content-Type: application/json" -d "$DESIGN_OTP_PAYLOAD")
log_response "$DESIGN_OTP_RESPONSE"
log_success "DesignTemplate (OTP) cr√©√©/mis √† jour."

# 3.4 Cr√©ation de l'EmailTemplate (R√®gle d'envoi OTP)
EMAIL_OTP_PAYLOAD="{ \"id\": \"$TEMPLATE_EMAIL_OTP_ID\", \"setting_id\": \"$SMTP_SETTING_ID\", \"design_template_id\": \"$DESIGN_EMAIL_OTP_ID\", \"title\": \"R√®gle envoi OTP\" }"
echo "  Requ√™te POST vers /email-templates (OTP)"
EMAIL_OTP_RESPONSE=$(curl -s -X POST "${API_BASE_URL}/api/mock-notifications/${SYS_ORG_ID}/email-templates" -H "Content-Type: application/json" -d "$EMAIL_OTP_PAYLOAD")
log_response "$EMAIL_OTP_RESPONSE"
log_success "EmailTemplate (OTP) cr√©√©/mis √† jour."

# 3.5 Cr√©ation des PushTemplates
PUSH_NEW_PLANNING_PAYLOAD="{ \"id\": \"$TEMPLATE_PUSH_NEW_PLANNING_ID\", \"settingId\": \"$FIREBASE_SETTING_ID\", \"title\": \"Nouveau planning disponible !\", \"body\": \"Le chauffeur {{driverName}} propose un trajet vers {{destination}} √† {{cost}} FCFA.\" }"
echo "  Requ√™te POST vers /push-templates (New Planning)"
PUSH_NEW_PLANNING_RESPONSE=$(curl -s -X POST "${API_BASE_URL}/api/mock-notifications/${SYS_ORG_ID}/push-templates" -H "Content-Type: application/json" -d "$PUSH_NEW_PLANNING_PAYLOAD")
log_response "$PUSH_NEW_PLANNING_RESPONSE"
log_success "PushTemplate (New Planning) cr√©√©/mis √† jour."

PUSH_NEW_ANNOUNCEMENT_PAYLOAD="{ \"id\": \"$TEMPLATE_PUSH_NEW_ANNOUNCEMENT_ID\", \"settingId\": \"$FIREBASE_SETTING_ID\", \"title\": \"Nouvelle course client !\", \"body\": \"Un client a post√© un nouveau trajet : {{tripTitle}}\" }"
echo "  Requ√™te POST vers /push-templates (New Announcement)"
PUSH_NEW_ANNOUNCEMENT_RESPONSE=$(curl -s -X POST "${API_BASE_URL}/api/mock-notifications/${SYS_ORG_ID}/push-templates" -H "Content-Type: application/json" -d "$PUSH_NEW_ANNOUNCEMENT_PAYLOAD")
log_response "$PUSH_NEW_ANNOUNCEMENT_RESPONSE"
log_success "PushTemplate (New Announcement) cr√©√©/mis √† jour."

PUSH_ACCEPTED_PAYLOAD="{ \"id\": \"$TEMPLATE_PUSH_ANNOUNCEMENT_ACCEPTED_ID\", \"settingId\": \"$FIREBASE_SETTING_ID\", \"title\": \"Votre course a un chauffeur !\", \"body\": \"Le chauffeur {{driverName}} a accept√© votre trajet \\\"{{tripTitle}}\\\". Appuyez pour voir son profil.\" }"
echo "  Requ√™te POST vers /push-templates (Announcement Accepted)"
PUSH_ACCEPTED_RESPONSE=$(curl -s -X POST "${API_BASE_URL}/api/mock-notifications/${SYS_ORG_ID}/push-templates" -H "Content-Type: application/json" -d "$PUSH_ACCEPTED_PAYLOAD")
log_response "$PUSH_ACCEPTED_RESPONSE"
log_success "PushTemplate (Announcement Accepted) cr√©√©/mis √† jour."


echo -e "\nüéâ --- INITIALISATION TERMIN√âE ---"
echo "Le fichier '$ENV_FILE' a √©t√© cr√©√©/mis √† jour avec succ√®s."
echo "Veuillez RED√âMARRER votre backend Java pour qu'il prenne en compte les nouvelles variables d'environnement."// END OF FILE: init_application.sh

//---> PATH: /home/mbogneng-junior/freelance-driver_Sylladb/backend/mvnw

#!/bin/sh
# ----------------------------------------------------------------------------
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.
# ----------------------------------------------------------------------------

# ----------------------------------------------------------------------------
# Apache Maven Wrapper startup batch script, version 3.3.2
#
# Optional ENV vars
# -----------------
#   JAVA_HOME - location of a JDK home dir, required when download maven via java source
#   MVNW_REPOURL - repo url base for downloading maven distribution
#   MVNW_USERNAME/MVNW_PASSWORD - user and password for downloading maven
#   MVNW_VERBOSE - true: enable verbose log; debug: trace the mvnw script; others: silence the output
# ----------------------------------------------------------------------------

set -euf
[ "${MVNW_VERBOSE-}" != debug ] || set -x

# OS specific support.
native_path() { printf %s\\n "$1"; }
case "$(uname)" in
CYGWIN* | MINGW*)
  [ -z "${JAVA_HOME-}" ] || JAVA_HOME="$(cygpath --unix "$JAVA_HOME")"
  native_path() { cygpath --path --windows "$1"; }
  ;;
esac

# set JAVACMD and JAVACCMD
set_java_home() {
  # For Cygwin and MinGW, ensure paths are in Unix format before anything is touched
  if [ -n "${JAVA_HOME-}" ]; then
    if [ -x "$JAVA_HOME/jre/sh/java" ]; then
      # IBM's JDK on AIX uses strange locations for the executables
      JAVACMD="$JAVA_HOME/jre/sh/java"
      JAVACCMD="$JAVA_HOME/jre/sh/javac"
    else
      JAVACMD="$JAVA_HOME/bin/java"
      JAVACCMD="$JAVA_HOME/bin/javac"

      if [ ! -x "$JAVACMD" ] || [ ! -x "$JAVACCMD" ]; then
        echo "The JAVA_HOME environment variable is not defined correctly, so mvnw cannot run." >&2
        echo "JAVA_HOME is set to \"$JAVA_HOME\", but \"\$JAVA_HOME/bin/java\" or \"\$JAVA_HOME/bin/javac\" does not exist." >&2
        return 1
      fi
    fi
  else
    JAVACMD="$(
      'set' +e
      'unset' -f command 2>/dev/null
      'command' -v java
    )" || :
    JAVACCMD="$(
      'set' +e
      'unset' -f command 2>/dev/null
      'command' -v javac
    )" || :

    if [ ! -x "${JAVACMD-}" ] || [ ! -x "${JAVACCMD-}" ]; then
      echo "The java/javac command does not exist in PATH nor is JAVA_HOME set, so mvnw cannot run." >&2
      return 1
    fi
  fi
}

# hash string like Java String::hashCode
hash_string() {
  str="${1:-}" h=0
  while [ -n "$str" ]; do
    char="${str%"${str#?}"}"
    h=$(((h * 31 + $(LC_CTYPE=C printf %d "'$char")) % 4294967296))
    str="${str#?}"
  done
  printf %x\\n $h
}

verbose() { :; }
[ "${MVNW_VERBOSE-}" != true ] || verbose() { printf %s\\n "${1-}"; }

die() {
  printf %s\\n "$1" >&2
  exit 1
}

trim() {
  # MWRAPPER-139:
  #   Trims trailing and leading whitespace, carriage returns, tabs, and linefeeds.
  #   Needed for removing poorly interpreted newline sequences when running in more
  #   exotic environments such as mingw bash on Windows.
  printf "%s" "${1}" | tr -d '[:space:]'
}

# parse distributionUrl and optional distributionSha256Sum, requires .mvn/wrapper/maven-wrapper.properties
while IFS="=" read -r key value; do
  case "${key-}" in
  distributionUrl) distributionUrl=$(trim "${value-}") ;;
  distributionSha256Sum) distributionSha256Sum=$(trim "${value-}") ;;
  esac
done <"${0%/*}/.mvn/wrapper/maven-wrapper.properties"
[ -n "${distributionUrl-}" ] || die "cannot read distributionUrl property in ${0%/*}/.mvn/wrapper/maven-wrapper.properties"

case "${distributionUrl##*/}" in
maven-mvnd-*bin.*)
  MVN_CMD=mvnd.sh _MVNW_REPO_PATTERN=/maven/mvnd/
  case "${PROCESSOR_ARCHITECTURE-}${PROCESSOR_ARCHITEW6432-}:$(uname -a)" in
  *AMD64:CYGWIN* | *AMD64:MINGW*) distributionPlatform=windows-amd64 ;;
  :Darwin*x86_64) distributionPlatform=darwin-amd64 ;;
  :Darwin*arm64) distributionPlatform=darwin-aarch64 ;;
  :Linux*x86_64*) distributionPlatform=linux-amd64 ;;
  *)
    echo "Cannot detect native platform for mvnd on $(uname)-$(uname -m), use pure java version" >&2
    distributionPlatform=linux-amd64
    ;;
  esac
  distributionUrl="${distributionUrl%-bin.*}-$distributionPlatform.zip"
  ;;
maven-mvnd-*) MVN_CMD=mvnd.sh _MVNW_REPO_PATTERN=/maven/mvnd/ ;;
*) MVN_CMD="mvn${0##*/mvnw}" _MVNW_REPO_PATTERN=/org/apache/maven/ ;;
esac

# apply MVNW_REPOURL and calculate MAVEN_HOME
# maven home pattern: ~/.m2/wrapper/dists/{apache-maven-<version>,maven-mvnd-<version>-<platform>}/<hash>
[ -z "${MVNW_REPOURL-}" ] || distributionUrl="$MVNW_REPOURL$_MVNW_REPO_PATTERN${distributionUrl#*"$_MVNW_REPO_PATTERN"}"
distributionUrlName="${distributionUrl##*/}"
distributionUrlNameMain="${distributionUrlName%.*}"
distributionUrlNameMain="${distributionUrlNameMain%-bin}"
MAVEN_USER_HOME="${MAVEN_USER_HOME:-${HOME}/.m2}"
MAVEN_HOME="${MAVEN_USER_HOME}/wrapper/dists/${distributionUrlNameMain-}/$(hash_string "$distributionUrl")"

exec_maven() {
  unset MVNW_VERBOSE MVNW_USERNAME MVNW_PASSWORD MVNW_REPOURL || :
  exec "$MAVEN_HOME/bin/$MVN_CMD" "$@" || die "cannot exec $MAVEN_HOME/bin/$MVN_CMD"
}

if [ -d "$MAVEN_HOME" ]; then
  verbose "found existing MAVEN_HOME at $MAVEN_HOME"
  exec_maven "$@"
fi

case "${distributionUrl-}" in
*?-bin.zip | *?maven-mvnd-?*-?*.zip) ;;
*) die "distributionUrl is not valid, must match *-bin.zip or maven-mvnd-*.zip, but found '${distributionUrl-}'" ;;
esac

# prepare tmp dir
if TMP_DOWNLOAD_DIR="$(mktemp -d)" && [ -d "$TMP_DOWNLOAD_DIR" ]; then
  clean() { rm -rf -- "$TMP_DOWNLOAD_DIR"; }
  trap clean HUP INT TERM EXIT
else
  die "cannot create temp dir"
fi

mkdir -p -- "${MAVEN_HOME%/*}"

# Download and Install Apache Maven
verbose "Couldn't find MAVEN_HOME, downloading and installing it ..."
verbose "Downloading from: $distributionUrl"
verbose "Downloading to: $TMP_DOWNLOAD_DIR/$distributionUrlName"

# select .zip or .tar.gz
if ! command -v unzip >/dev/null; then
  distributionUrl="${distributionUrl%.zip}.tar.gz"
  distributionUrlName="${distributionUrl##*/}"
fi

# verbose opt
__MVNW_QUIET_WGET=--quiet __MVNW_QUIET_CURL=--silent __MVNW_QUIET_UNZIP=-q __MVNW_QUIET_TAR=''
[ "${MVNW_VERBOSE-}" != true ] || __MVNW_QUIET_WGET='' __MVNW_QUIET_CURL='' __MVNW_QUIET_UNZIP='' __MVNW_QUIET_TAR=v

# normalize http auth
case "${MVNW_PASSWORD:+has-password}" in
'') MVNW_USERNAME='' MVNW_PASSWORD='' ;;
has-password) [ -n "${MVNW_USERNAME-}" ] || MVNW_USERNAME='' MVNW_PASSWORD='' ;;
esac

if [ -z "${MVNW_USERNAME-}" ] && command -v wget >/dev/null; then
  verbose "Found wget ... using wget"
  wget ${__MVNW_QUIET_WGET:+"$__MVNW_QUIET_WGET"} "$distributionUrl" -O "$TMP_DOWNLOAD_DIR/$distributionUrlName" || die "wget: Failed to fetch $distributionUrl"
elif [ -z "${MVNW_USERNAME-}" ] && command -v curl >/dev/null; then
  verbose "Found curl ... using curl"
  curl ${__MVNW_QUIET_CURL:+"$__MVNW_QUIET_CURL"} -f -L -o "$TMP_DOWNLOAD_DIR/$distributionUrlName" "$distributionUrl" || die "curl: Failed to fetch $distributionUrl"
elif set_java_home; then
  verbose "Falling back to use Java to download"
  javaSource="$TMP_DOWNLOAD_DIR/Downloader.java"
  targetZip="$TMP_DOWNLOAD_DIR/$distributionUrlName"
  cat >"$javaSource" <<-END
	public class Downloader extends java.net.Authenticator
	{
	  protected java.net.PasswordAuthentication getPasswordAuthentication()
	  {
	    return new java.net.PasswordAuthentication( System.getenv( "MVNW_USERNAME" ), System.getenv( "MVNW_PASSWORD" ).toCharArray() );
	  }
	  public static void main( String[] args ) throws Exception
	  {
	    setDefault( new Downloader() );
	    java.nio.file.Files.copy( java.net.URI.create( args[0] ).toURL().openStream(), java.nio.file.Paths.get( args[1] ).toAbsolutePath().normalize() );
	  }
	}
	END
  # For Cygwin/MinGW, switch paths to Windows format before running javac and java
  verbose " - Compiling Downloader.java ..."
  "$(native_path "$JAVACCMD")" "$(native_path "$javaSource")" || die "Failed to compile Downloader.java"
  verbose " - Running Downloader.java ..."
  "$(native_path "$JAVACMD")" -cp "$(native_path "$TMP_DOWNLOAD_DIR")" Downloader "$distributionUrl" "$(native_path "$targetZip")"
fi

# If specified, validate the SHA-256 sum of the Maven distribution zip file
if [ -n "${distributionSha256Sum-}" ]; then
  distributionSha256Result=false
  if [ "$MVN_CMD" = mvnd.sh ]; then
    echo "Checksum validation is not supported for maven-mvnd." >&2
    echo "Please disable validation by removing 'distributionSha256Sum' from your maven-wrapper.properties." >&2
    exit 1
  elif command -v sha256sum >/dev/null; then
    if echo "$distributionSha256Sum  $TMP_DOWNLOAD_DIR/$distributionUrlName" | sha256sum -c >/dev/null 2>&1; then
      distributionSha256Result=true
    fi
  elif command -v shasum >/dev/null; then
    if echo "$distributionSha256Sum  $TMP_DOWNLOAD_DIR/$distributionUrlName" | shasum -a 256 -c >/dev/null 2>&1; then
      distributionSha256Result=true
    fi
  else
    echo "Checksum validation was requested but neither 'sha256sum' or 'shasum' are available." >&2
    echo "Please install either command, or disable validation by removing 'distributionSha256Sum' from your maven-wrapper.properties." >&2
    exit 1
  fi
  if [ $distributionSha256Result = false ]; then
    echo "Error: Failed to validate Maven distribution SHA-256, your Maven distribution might be compromised." >&2
    echo "If you updated your Maven version, you need to update the specified distributionSha256Sum property." >&2
    exit 1
  fi
fi

# unzip and move
if command -v unzip >/dev/null; then
  unzip ${__MVNW_QUIET_UNZIP:+"$__MVNW_QUIET_UNZIP"} "$TMP_DOWNLOAD_DIR/$distributionUrlName" -d "$TMP_DOWNLOAD_DIR" || die "failed to unzip"
else
  tar xzf${__MVNW_QUIET_TAR:+"$__MVNW_QUIET_TAR"} "$TMP_DOWNLOAD_DIR/$distributionUrlName" -C "$TMP_DOWNLOAD_DIR" || die "failed to untar"
fi
printf %s\\n "$distributionUrl" >"$TMP_DOWNLOAD_DIR/$distributionUrlNameMain/mvnw.url"
mv -- "$TMP_DOWNLOAD_DIR/$distributionUrlNameMain" "$MAVEN_HOME" || [ -d "$MAVEN_HOME" ] || die "fail to move MAVEN_HOME"

clean || :
exec_maven "$@"
// END OF FILE: mvnw

//---> PATH: /home/mbogneng-junior/freelance-driver_Sylladb/backend/mvnw.cmd

<# : batch portion
@REM ----------------------------------------------------------------------------
@REM Licensed to the Apache Software Foundation (ASF) under one
@REM or more contributor license agreements.  See the NOTICE file
@REM distributed with this work for additional information
@REM regarding copyright ownership.  The ASF licenses this file
@REM to you under the Apache License, Version 2.0 (the
@REM "License"); you may not use this file except in compliance
@REM with the License.  You may obtain a copy of the License at
@REM
@REM    http://www.apache.org/licenses/LICENSE-2.0
@REM
@REM Unless required by applicable law or agreed to in writing,
@REM software distributed under the License is distributed on an
@REM "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
@REM KIND, either express or implied.  See the License for the
@REM specific language governing permissions and limitations
@REM under the License.
@REM ----------------------------------------------------------------------------

@REM ----------------------------------------------------------------------------
@REM Apache Maven Wrapper startup batch script, version 3.3.2
@REM
@REM Optional ENV vars
@REM   MVNW_REPOURL - repo url base for downloading maven distribution
@REM   MVNW_USERNAME/MVNW_PASSWORD - user and password for downloading maven
@REM   MVNW_VERBOSE - true: enable verbose log; others: silence the output
@REM ----------------------------------------------------------------------------

@IF "%__MVNW_ARG0_NAME__%"=="" (SET __MVNW_ARG0_NAME__=%~nx0)
@SET __MVNW_CMD__=
@SET __MVNW_ERROR__=
@SET __MVNW_PSMODULEP_SAVE=%PSModulePath%
@SET PSModulePath=
@FOR /F "usebackq tokens=1* delims==" %%A IN (`powershell -noprofile "& {$scriptDir='%~dp0'; $script='%__MVNW_ARG0_NAME__%'; icm -ScriptBlock ([Scriptblock]::Create((Get-Content -Raw '%~f0'))) -NoNewScope}"`) DO @(
  IF "%%A"=="MVN_CMD" (set __MVNW_CMD__=%%B) ELSE IF "%%B"=="" (echo %%A) ELSE (echo %%A=%%B)
)
@SET PSModulePath=%__MVNW_PSMODULEP_SAVE%
@SET __MVNW_PSMODULEP_SAVE=
@SET __MVNW_ARG0_NAME__=
@SET MVNW_USERNAME=
@SET MVNW_PASSWORD=
@IF NOT "%__MVNW_CMD__%"=="" (%__MVNW_CMD__% %*)
@echo Cannot start maven from wrapper >&2 && exit /b 1
@GOTO :EOF
: end batch / begin powershell #>

$ErrorActionPreference = "Stop"
if ($env:MVNW_VERBOSE -eq "true") {
  $VerbosePreference = "Continue"
}

# calculate distributionUrl, requires .mvn/wrapper/maven-wrapper.properties
$distributionUrl = (Get-Content -Raw "$scriptDir/.mvn/wrapper/maven-wrapper.properties" | ConvertFrom-StringData).distributionUrl
if (!$distributionUrl) {
  Write-Error "cannot read distributionUrl property in $scriptDir/.mvn/wrapper/maven-wrapper.properties"
}

switch -wildcard -casesensitive ( $($distributionUrl -replace '^.*/','') ) {
  "maven-mvnd-*" {
    $USE_MVND = $true
    $distributionUrl = $distributionUrl -replace '-bin\.[^.]*$',"-windows-amd64.zip"
    $MVN_CMD = "mvnd.cmd"
    break
  }
  default {
    $USE_MVND = $false
    $MVN_CMD = $script -replace '^mvnw','mvn'
    break
  }
}

# apply MVNW_REPOURL and calculate MAVEN_HOME
# maven home pattern: ~/.m2/wrapper/dists/{apache-maven-<version>,maven-mvnd-<version>-<platform>}/<hash>
if ($env:MVNW_REPOURL) {
  $MVNW_REPO_PATTERN = if ($USE_MVND) { "/org/apache/maven/" } else { "/maven/mvnd/" }
  $distributionUrl = "$env:MVNW_REPOURL$MVNW_REPO_PATTERN$($distributionUrl -replace '^.*'+$MVNW_REPO_PATTERN,'')"
}
$distributionUrlName = $distributionUrl -replace '^.*/',''
$distributionUrlNameMain = $distributionUrlName -replace '\.[^.]*$','' -replace '-bin$',''
$MAVEN_HOME_PARENT = "$HOME/.m2/wrapper/dists/$distributionUrlNameMain"
if ($env:MAVEN_USER_HOME) {
  $MAVEN_HOME_PARENT = "$env:MAVEN_USER_HOME/wrapper/dists/$distributionUrlNameMain"
}
$MAVEN_HOME_NAME = ([System.Security.Cryptography.MD5]::Create().ComputeHash([byte[]][char[]]$distributionUrl) | ForEach-Object {$_.ToString("x2")}) -join ''
$MAVEN_HOME = "$MAVEN_HOME_PARENT/$MAVEN_HOME_NAME"

if (Test-Path -Path "$MAVEN_HOME" -PathType Container) {
  Write-Verbose "found existing MAVEN_HOME at $MAVEN_HOME"
  Write-Output "MVN_CMD=$MAVEN_HOME/bin/$MVN_CMD"
  exit $?
}

if (! $distributionUrlNameMain -or ($distributionUrlName -eq $distributionUrlNameMain)) {
  Write-Error "distributionUrl is not valid, must end with *-bin.zip, but found $distributionUrl"
}

# prepare tmp dir
$TMP_DOWNLOAD_DIR_HOLDER = New-TemporaryFile
$TMP_DOWNLOAD_DIR = New-Item -Itemtype Directory -Path "$TMP_DOWNLOAD_DIR_HOLDER.dir"
$TMP_DOWNLOAD_DIR_HOLDER.Delete() | Out-Null
trap {
  if ($TMP_DOWNLOAD_DIR.Exists) {
    try { Remove-Item $TMP_DOWNLOAD_DIR -Recurse -Force | Out-Null }
    catch { Write-Warning "Cannot remove $TMP_DOWNLOAD_DIR" }
  }
}

New-Item -Itemtype Directory -Path "$MAVEN_HOME_PARENT" -Force | Out-Null

# Download and Install Apache Maven
Write-Verbose "Couldn't find MAVEN_HOME, downloading and installing it ..."
Write-Verbose "Downloading from: $distributionUrl"
Write-Verbose "Downloading to: $TMP_DOWNLOAD_DIR/$distributionUrlName"

$webclient = New-Object System.Net.WebClient
if ($env:MVNW_USERNAME -and $env:MVNW_PASSWORD) {
  $webclient.Credentials = New-Object System.Net.NetworkCredential($env:MVNW_USERNAME, $env:MVNW_PASSWORD)
}
[Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12
$webclient.DownloadFile($distributionUrl, "$TMP_DOWNLOAD_DIR/$distributionUrlName") | Out-Null

# If specified, validate the SHA-256 sum of the Maven distribution zip file
$distributionSha256Sum = (Get-Content -Raw "$scriptDir/.mvn/wrapper/maven-wrapper.properties" | ConvertFrom-StringData).distributionSha256Sum
if ($distributionSha256Sum) {
  if ($USE_MVND) {
    Write-Error "Checksum validation is not supported for maven-mvnd. `nPlease disable validation by removing 'distributionSha256Sum' from your maven-wrapper.properties."
  }
  Import-Module $PSHOME\Modules\Microsoft.PowerShell.Utility -Function Get-FileHash
  if ((Get-FileHash "$TMP_DOWNLOAD_DIR/$distributionUrlName" -Algorithm SHA256).Hash.ToLower() -ne $distributionSha256Sum) {
    Write-Error "Error: Failed to validate Maven distribution SHA-256, your Maven distribution might be compromised. If you updated your Maven version, you need to update the specified distributionSha256Sum property."
  }
}

# unzip and move
Expand-Archive "$TMP_DOWNLOAD_DIR/$distributionUrlName" -DestinationPath "$TMP_DOWNLOAD_DIR" | Out-Null
Rename-Item -Path "$TMP_DOWNLOAD_DIR/$distributionUrlNameMain" -NewName $MAVEN_HOME_NAME | Out-Null
try {
  Move-Item -Path "$TMP_DOWNLOAD_DIR/$MAVEN_HOME_NAME" -Destination $MAVEN_HOME_PARENT | Out-Null
} catch {
  if (! (Test-Path -Path "$MAVEN_HOME" -PathType Container)) {
    Write-Error "fail to move MAVEN_HOME"
  }
} finally {
  try { Remove-Item $TMP_DOWNLOAD_DIR -Recurse -Force | Out-Null }
  catch { Write-Warning "Cannot remove $TMP_DOWNLOAD_DIR" }
}

Write-Output "MVN_CMD=$MAVEN_HOME/bin/$MVN_CMD"
// END OF FILE: mvnw.cmd

//---> PATH: /home/mbogneng-junior/freelance-driver_Sylladb/backend/policy.json

{
    "Version": "2012-10-17",
    "Statement": [
        {
            "Effect": "Allow",
            "Principal": "*",
            "Action": [
                "s3:GetObject"
            ],
            "Resource": [
                "arn:aws:s3:::freelance-driver/*"
            ]
        }
    ]
}
// END OF FILE: policy.json

//---> PATH: /home/mbogneng-junior/freelance-driver_Sylladb/backend/pom.xml

<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>
    <parent>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-parent</artifactId>
        <version>3.3.0</version>
        <relativePath/> <!-- lookup parent from repository -->
    </parent>
    <groupId>inc.yowyob</groupId>
    <artifactId>freelance-driver-service</artifactId>
    <version>1.0.0</version>
    <name>freelance-driver-service</name>
    <description>Backend service for the freelance driver application</description>

    <properties>
        <java.version>21</java.version>
        <!-- Version du Bill of Materials de Spring Cloud compatible avec Spring Boot 3.3.0 -->
        <spring-cloud.version>2023.0.1</spring-cloud.version>
    </properties>

    <!-- Gestion des versions des d√©pendances Spring Cloud -->
    <dependencyManagement>
        <dependencies>
            <dependency>
                <groupId>org.springframework.cloud</groupId>
                <artifactId>spring-cloud-dependencies</artifactId>
                <version>${spring-cloud.version}</version>
                <type>pom</type>
                <scope>import</scope>
            </dependency>
            <dependency>
                <groupId>software.amazon.awssdk</groupId>
                <artifactId>bom</artifactId>
                <version>2.25.30</version>
                <type>pom</type>
                <scope>import</scope>
            </dependency>
        </dependencies>
    </dependencyManagement>

    <dependencies>
        <!-- Support pour la base de donn√©es ScyllaDB/Cassandra en mode r√©actif -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-data-cassandra-reactive</artifactId>
        </dependency>

        <!-- Framework Web r√©actif (remplace spring-boot-starter-web) -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-webflux</artifactId>
        </dependency>

        <!-- S√©curit√© Spring -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-security</artifactId>
        </dependency>

        <!-- Support pour valider les tokens JWT (tr√®s utile pour un microservice) -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-oauth2-resource-server</artifactId>
        </dependency>

        <!-- D√âPENDANCE POUR LE SERVEUR SOCKET.IO -->
        <dependency>
            <groupId>com.corundumstudio.socketio</groupId>
            <artifactId>netty-socketio</artifactId>
            <version>2.0.11</version> <!-- Version r√©cente et stable -->
        </dependency>

              
        <!-- Support pour l'envoi d'emails -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-mail</artifactId>
        </dependency>

        <!-- Moteur de template Thymeleaf pour g√©n√©rer le HTML des emails -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-thymeleaf</artifactId>
        </dependency>

        <!-- Support pour Firebase Admin SDK (Notifications Push) -->
        <dependency>
            <groupId>com.google.firebase</groupId>
            <artifactId>firebase-admin</artifactId>
            <version>9.3.0</version>    
        </dependency>
              
              
        <dependency>
            <groupId>software.amazon.awssdk</groupId>
            <artifactId>s3</artifactId>
            <!-- Pas besoin de <version> ici, Maven la conna√Æt gr√¢ce au BOM ! -->
        </dependency>

        <dependency>
        <groupId>io.minio</groupId>
            <artifactId>minio</artifactId>
            <version>8.5.2</version> <!-- Une version r√©cente et stable -->
        </dependency>

    

    

        <!-- Outils de d√©veloppement (rechargement √† chaud) -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-devtools</artifactId>
            <scope>runtime</scope>
            <optional>true</optional>
        </dependency>

        <!-- Lombok pour r√©duire le code boilerplate -->
        <dependency>
            <groupId>org.projectlombok</groupId>
            <artifactId>lombok</artifactId>
            <optional>true</optional>
        </dependency>

        <dependency>

            <groupId>io.github.cdimascio</groupId>

            <artifactId>dotenv-java</artifactId>

            <version>3.0.0</version>

        </dependency>

        <!-- D√©pendances de test -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-test</artifactId>
            <scope>test</scope>
        </dependency>
        <dependency>
            <groupId>io.projectreactor</groupId>
            <artifactId>reactor-test</artifactId>
            <scope>test</scope>
        </dependency>
        <dependency>
            <groupId>org.springframework.security</groupId>
            <artifactId>spring-security-test</artifactId>
            <scope>test</scope>
        </dependency>
    </dependencies>

    <build>
        <plugins>
            <!-- Plugin Maven pour la compilation -->
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-compiler-plugin</artifactId>
                <configuration>
                    <!-- N√©cessaire pour que Lombok fonctionne avec Maven -->
                    <annotationProcessorPaths>
                        <path>
                            <groupId>org.projectlombok</groupId>
                            <artifactId>lombok</artifactId>
                            <version>${lombok.version}</version>
                        </path>
                    </annotationProcessorPaths>
                </configuration>
            </plugin>
            <!-- Plugin Spring Boot pour cr√©er l'ex√©cutable -->
            <plugin>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-maven-plugin</artifactId>
                <configuration>
                    <excludes>
                        <exclude>
                            <groupId>org.projectlombok</groupId>
                            <artifactId>lombok</artifactId>
                        </exclude>
                    </excludes>
                </configuration>
            </plugin>
        </plugins>
    </build>
    <repositories>
        <repository>
            <id>maven-central</id>
            <url>https://repo.maven.apache.org/maven2</url>
        </repository>
        <repository>
            <id>gitlab-maven</id>
            <url>https://gitlab.yowyob.com/api/v4/groups/3/-/packages/maven</url>
        </repository>
    </repositories>
    <distributionManagement>
        <repository>
            <id>gitlab-maven</id>
            <url>${CI_API_V4_URL}/projects/${CI_PROJECT_ID}/packages/maven</url>
        </repository>
        <snapshotRepository>
            <id>gitlab-maven</id>
            <url>${CI_API_V4_URL}/projects/${CI_PROJECT_ID}/packages/maven</url>
        </snapshotRepository>
    </distributionManagement>
</project>// END OF FILE: pom.xml

//---> PATH: /home/mbogneng-junior/freelance-driver_Sylladb/backend/prompter.sh

#!/bin/bash

# --- Configuration ---

# Default project path if none provided
DEFAULT_PROJECT_PATH="."
PROJECT_PATH=${1:-"$DEFAULT_PROJECT_PATH"}

# Output file name (relative to PROJECT_PATH)
OUTPUT_FILENAME="project_context.txt"

# Directories to completely ignore (won't be traversed)
EXCLUDE_DIRS_PATTERN=( \
    ".*"            # All hidden folders (.git, .vscode, .idea, .svn, etc.)
    "node_modules"
    "vendor"        # PHP Composer
    "build"
    "dist"
    "target"        # Java/Rust build outputs
    "__pycache__"   # Python cache
    ".next"         # Next.js build output
    "cache"         # General cache folders
    "target"
    "storage"       # Laravel storage (often contains logs, cache, etc.)
    # Add more directory names here if needed
)

# Specific file patterns to ignore within traversed directories
EXCLUDE_FILES_PATTERN=( \
    "*.log"
    "*.jar"
    "*.pdf"
    "*.class"
    "*.sqlite"
    "project_context.txt"
    # ".env*"       # Consider if you NEED .env files; uncomment if NOT needed.
    "package-lock.json"
    "yarn.lock"
    "composer.lock"
    "*.ico"
    "pnpm-lock.yaml"
    # Add more file patterns here (e.g., "*.swp", "*.bak", "*.tmp")
)

# --- Script Logic ---

# Attempt to get absolute path; exit if PROJECT_PATH is invalid early
PROJECT_PATH=$(realpath "$PROJECT_PATH" 2>/dev/null)
if [ $? -ne 0 ] || [ ! -d "$PROJECT_PATH" ]; then
    echo "Error: Invalid or non-existent project directory specified." >&2 # Error to stderr
    exit 1
fi

OUTPUT_FILE="$PROJECT_PATH/$OUTPUT_FILENAME"

# --- Safety Check: Prevent overwriting the project directory itself ---
# This is unlikely but guards against strange configurations
if [ "$PROJECT_PATH" == "$OUTPUT_FILE" ]; then
    echo "Error: Project directory path conflicts with output file name '$OUTPUT_FILENAME'." >&2
    exit 1
fi

# Delete output file silently if it exists
rm -f "$OUTPUT_FILE"

# --- Build the find command ---
# Uses arrays to construct the find command safely and avoid complex escaping issues with eval
find_args=("$PROJECT_PATH")

# Add directory prune conditions
if [ ${#EXCLUDE_DIRS_PATTERN[@]} -gt 0 ]; then
    find_args+=(\()
    first_prune=true
    for dir_pattern in "${EXCLUDE_DIRS_PATTERN[@]}"; do
        if ! $first_prune; then
            find_args+=(-o)
        fi
        find_args+=(-name "$dir_pattern" -type d)
        first_prune=false
    done
    find_args+=(\) -prune -o) # Add the prune action and the OR for the next part
fi

# Add primary find conditions (type file, exclude output file, exclude patterns)
find_args+=(\( -type f -not -path "$OUTPUT_FILE")
if [ ${#EXCLUDE_FILES_PATTERN[@]} -gt 0 ]; then
    for file_pattern in "${EXCLUDE_FILES_PATTERN[@]}"; do
        find_args+=(-not -name "$file_pattern")
    done
fi
find_args+=(-print \)) # Add the print action and close the group

# --- Execute the find command and process results ---

# Create the header in the output file
{
    echo "Project Context From: $PROJECT_PATH"
    echo "Generated On: $(date)"
    echo "==============================================="
    echo "Ignored Directory Patterns: ${EXCLUDE_DIRS_PATTERN[*]}"
    echo "Ignored File Patterns: ${EXCLUDE_FILES_PATTERN[*]}"
    echo "==============================================="
    echo ""
} > "$OUTPUT_FILE"

error_count=0
# Use find with process substitution and sorting. Avoids eval.
while IFS= read -r FILE_PATH; do
    # Calculate relative path for cleaner output
    RELATIVE_PATH="${FILE_PATH#"$PROJECT_PATH"/}"

    # Append file info and content to the output file
    {
        # echo ""
        # echo "// ==============================================="
        # echo "---> FILE: $RELATIVE_PATH"
        echo "//---> PATH: $FILE_PATH"
        # echo "// ==============================================="
        echo ""
    } >> "$OUTPUT_FILE"

    # Check if file is likely binary/non-text using 'file' command
    # -b: omit filename; check for common non-text types
    if file -b "$FILE_PATH" | grep -q -E 'binary|archive|compressed|image|font'; then
        echo "[Non-text file (e.g., binary, data, compressed) - Contents omitted]" >> "$OUTPUT_FILE"
    else
        # Append text file content, redirect cat errors to stderr
        if ! cat "$FILE_PATH" >> "$OUTPUT_FILE" 2> /dev/null; then # Hide cat errors from stdout
             # Optionally log error to the output file itself, or just count it
             echo "[Error reading file content for $RELATIVE_PATH]" >> "$OUTPUT_FILE"
             ((error_count++))
        fi
    fi

    {
        # echo ""
        echo "// END OF FILE: $RELATIVE_PATH"
        echo ""
    } >> "$OUTPUT_FILE"

done < <(find "${find_args[@]}" | sort) # Execute find command using safe array expansion

# Optionally report errors to stderr if any occurred
if [ $error_count -gt 0 ]; then
    echo "Warning: Encountered $error_count errors reading file contents during context generation." >&2
    # Exit with a non-zero status to indicate partial success/warning
    exit 1
fi

# Exit silently on success
exit 0
// END OF FILE: prompter.sh

//---> PATH: /home/mbogneng-junior/freelance-driver_Sylladb/backend/README.md

echo "üõë √âtape 1/5: Arr√™t et suppression des conteneurs et volumes Docker..."
docker compose down -v
echo "‚úÖ Conteneurs et volumes supprim√©s."
echo ""


# --- √âTAPE 2: RELANCE DE L'INFRASTRUCTURE ---
echo "üöÄ √âtape 2/5: D√©marrage des nouveaux conteneurs Docker (ScyllaDB & MinIO)..."
docker compose up -d
echo "‚úÖ Conteneurs d√©marr√©s. Attente de 10 secondes pour leur stabilisation..."
sleep 10
echo ""


# --- √âTAPE 3: CONFIGURATION DE SCYLLADB ---
echo "üóÑÔ∏è √âtape 3/5: Cr√©ation du keyspace dans ScyllaDB..."
docker exec -it scylla-node-dev cqlsh -e "CREATE KEYSPACE IF NOT EXISTS freelanceBd WITH REPLICATION = { 'class' : 'SimpleStrategy', 'replication_factor' : 1 };"
echo "‚úÖ Keyspace 'freelanceBd' cr√©√©."
echo ""




# --- √âTAPE 5: LANCEMENT DU BACKEND SPRING BOOT ---
echo "‚òï √âtape 5/5: Nettoyage du projet Maven et lancement de l'application Spring Boot..."
./mvnw clean
./mvnw spring-boot:run
// END OF FILE: README.md

//---> PATH: /home/mbogneng-junior/freelance-driver_Sylladb/backend/restart-dev.sh

Telecharger aws et configurer

curl "https://awscli.amazonaws.com/awscli-exe-linux-x86_64.zip" -o "awscliv2.zip"

unzip awscliv2.zip
sudo ./aws/install

aws --version

profile
aws configure --profile minio

docker-compose.yml :

AWS Access Key ID [None]:

    Tapez : junioradmin et appuyez sur Entr√©e.

    (Source : la variable MINIO_ROOT_USER de votre docker-compose.yml)

AWS Secret Access Key [None]:

    Tapez : YourStrongPassword2025 et appuyez sur Entr√©e.

    (Source : la variable MINIO_ROOT_PASSWORD de votre docker-compose.yml)

Default region name [None]:

    Tapez : us-east-1 et appuyez sur Entr√©e.

    (MinIO n'utilise pas de r√©gion, mais le CLI exige une valeur. us-east-1 est une valeur par d√©faut standard et sans danger.)

Default output format [None]:

    Tapez : json et appuyez sur Entr√©e.

    (C'est le format de sortie le plus lisible et le plus facile √† utiliser dans des scripts.)



# --- √âTAPE 4: CONFIGURATION DE MINIO ---
echo "ü™£ √âtape 4/5: Cr√©ation du bucket MinIO et application de la politique d'acc√®s..."

# Cr√©er le bucket
aws --endpoint-url http://localhost:9000 s3 mb s3://freelance-driver --profile minio
echo "‚úÖ Bucket 'freelance-driver' cr√©√©."

# Pr√©parer le fichier de politique (au cas o√π il aurait √©t√© supprim√©)
cat <<EOF > policy.json
{
    "Version": "2012-10-17",
    "Statement": [
        {
            "Effect": "Allow",
            "Principal": "*",
            "Action": [
                "s3:GetObject"
            ],
            "Resource": [
                "arn:aws:s3:::freelance-driver/*"
            ]
        }
    ]
}
EOF

# Appliquer la politique

echo "‚úÖ Politique d'acc√®s public en lecture appliqu√©e au bucket."
echo ""


#!/bin/bash
# Un script simple pour r√©initialiser compl√®tement l'environnement de d√©veloppement.
# Ex√©cutez-le depuis la racine de votre projet driver-backend.

# --- √âTAPE 1: ARR√äT ET NETTOYAGE COMPLET ---
echo "üõë √âtape 1/5: Arr√™t et suppression des conteneurs et volumes Docker..."
docker compose down -v
echo "‚úÖ Conteneurs et volumes supprim√©s."
echo ""


# --- √âTAPE 2: RELANCE DE L'INFRASTRUCTURE ---
echo "üöÄ √âtape 2/5: D√©marrage des nouveaux conteneurs Docker (ScyllaDB & MinIO)..."
docker compose up -d
echo "‚úÖ Conteneurs d√©marr√©s. Attente de 10 secondes pour leur stabilisation..."
sleep 10
echo ""


# --- √âTAPE 3: CONFIGURATION DE SCYLLADB ---
echo "üóÑÔ∏è √âtape 3/5: Cr√©ation du keyspace dans ScyllaDB..."
docker exec -it scylla-node-dev cqlsh -e "CREATE KEYSPACE IF NOT EXISTS freelanceBd WITH REPLICATION = { 'class' : 'SimpleStrategy', 'replication_factor' : 1 };"
echo "‚úÖ Keyspace 'freelanceBd' cr√©√©."
echo ""




# --- √âTAPE 5: LANCEMENT DU BACKEND SPRING BOOT ---
echo "‚òï √âtape 5/5: Nettoyage du projet Maven et lancement de l'application Spring Boot..."
./mvnw clean
./mvnw spring-boot:run



ssh root@167.71.176.127
Reconstruisez l'image Docker :
code Bash

    
docker build -t freelance-driver-app:latest .

  

Arr√™tez et supprimez l'ancien conteneur :
code Bash

    
docker stop freelance-driver-service && docker rm freelance-driver-service

  

Relancez le conteneur avec la nouvelle image :
code Bash

    
docker run -d \
  --name freelance-driver-service \
  -p 8080:8080 \
  -p 8081:8081 \
  -e SERVER_PORT=8081 \
  --env-file .env \
  --network=freelance_driver_backend_freelance-net \
  --restart always \
  freelance-driver-app:latest
  

docker logs -f freelance-driver-service



sudo ufw allow 8080/tcp
sudo ufw allow 8081/tcp
sudo ufw allow 9092/tcp
sudo ufw allow out 587/tcp
sudo ufw reload
// END OF FILE: restart-dev.sh

//---> PATH: /home/mbogneng-junior/freelance-driver_Sylladb/backend/src/main/java/com/freelance/driver_backend/config/CassandraConfig.java

package com.freelance.driver_backend.config;

import com.datastax.oss.driver.api.core.config.DefaultDriverOption;
import com.datastax.oss.driver.api.core.config.DriverConfigLoader;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Configuration;
import org.springframework.data.cassandra.config.AbstractCassandraConfiguration;
import org.springframework.data.cassandra.config.SchemaAction;
import org.springframework.data.cassandra.config.SessionBuilderConfigurer;
import org.springframework.data.cassandra.core.cql.keyspace.CreateKeyspaceSpecification;
import org.springframework.data.cassandra.core.cql.keyspace.DropKeyspaceSpecification;
import org.springframework.data.cassandra.core.cql.keyspace.KeyspaceOption;
import org.springframework.data.cassandra.repository.config.EnableReactiveCassandraRepositories;

import java.time.Duration;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

@Configuration
@EnableReactiveCassandraRepositories(basePackages = "com.freelance.driver_backend.repository")
public class CassandraConfig extends AbstractCassandraConfiguration {

    @Value("${spring.data.cassandra.contact-points:127.0.0.1}")
    private String hostname;

    @Value("${spring.data.cassandra.port:9042}")
    private int port;

    @Value("${spring.data.cassandra.keyspace:freelancebd}")
    private String keyspace;

    @Value("${spring.data.cassandra.datacenter:datacenter1}")
    private String datacenter;

    @Override
    protected String getKeyspaceName() {
        return keyspace;
    }

    @Override
    protected String getContactPoints() {
        return hostname;
    }

    @Override
    protected int getPort() {
        return port;
    }

    @Override
    public SchemaAction getSchemaAction() {
        return SchemaAction.CREATE_IF_NOT_EXISTS;
    }

    @Override
    protected List getStartupScripts() {
        return Collections.singletonList("CREATE KEYSPACE IF NOT EXISTS "
                + keyspace + " WITH replication = {"
                + " 'class': 'SimpleStrategy', "
                + " 'replication_factor': '2' " + "};");

    }

    @Override
    protected List<CreateKeyspaceSpecification> getKeyspaceCreations() {
        final CreateKeyspaceSpecification specification = CreateKeyspaceSpecification.createKeyspace(getKeyspaceName())
                .ifNotExists().with(KeyspaceOption.DURABLE_WRITES, true).withSimpleReplication();
        return Collections.singletonList(specification);
    }

    @Override
    protected List<DropKeyspaceSpecification> getKeyspaceDrops() {
        List<DropKeyspaceSpecification> list = new ArrayList<>();
        list.add(DropKeyspaceSpecification.dropKeyspace(getKeyspaceName()));
        return list;
    }
     /*
    @Override
    protected List<DropKeyspaceSpecification> getKeyspaceDrops() {
        // CORRECTION ICI : Retournez une liste vide pour NE PAS supprimer le keyspace.
        return Collections.emptyList(); // Ou new ArrayList<>() pour plus de clart√©
    }
    */
    /**
     * Configuration avanc√©e pour surcharger les timeouts du driver Cassandra.
     * Cette m√©thode est plus robuste que la configuration via application.properties.
     */
    @Override
    protected SessionBuilderConfigurer getSessionBuilderConfigurer() {
        return sessionBuilder -> {
            DriverConfigLoader configLoader = DriverConfigLoader.programmaticBuilder()
                    // Augmente le timeout pour toutes les requ√™tes √† 20 secondes.
                    .withDuration(DefaultDriverOption.REQUEST_TIMEOUT, Duration.ofSeconds(20))
                    // Augmente le timeout pour la connexion initiale.
                    .withDuration(DefaultDriverOption.CONNECTION_CONNECT_TIMEOUT, Duration.ofSeconds(20))
                    // Augmente le timeout pour l'initialisation du sch√©ma (cr√©ation des tables/index).
                    .withDuration(DefaultDriverOption.CONTROL_CONNECTION_TIMEOUT, Duration.ofSeconds(20))
                    .build();
            
            return sessionBuilder.withConfigLoader(configLoader);
        };
    }
}// END OF FILE: src/main/java/com/freelance/driver_backend/config/CassandraConfig.java

//---> PATH: /home/mbogneng-junior/freelance-driver_Sylladb/backend/src/main/java/com/freelance/driver_backend/config/DotenvConfig.java

package com.freelance.driver_backend.config;

import io.github.cdimascio.dotenv.Dotenv;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class DotenvConfig {

    @Bean
    public Dotenv dotenv() {
        return Dotenv.configure().ignoreIfMissing().load();
    }
}
// END OF FILE: src/main/java/com/freelance/driver_backend/config/DotenvConfig.java

//---> PATH: /home/mbogneng-junior/freelance-driver_Sylladb/backend/src/main/java/com/freelance/driver_backend/config/FirebaseConfig.java

package com.freelance.driver_backend.config;

import com.google.auth.oauth2.GoogleCredentials;
import com.google.firebase.FirebaseApp;
import com.google.firebase.FirebaseOptions;
import com.google.firebase.messaging.FirebaseMessaging; 
import lombok.extern.slf4j.Slf4j;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.core.io.ClassPathResource;
import org.springframework.beans.factory.annotation.Value; 

import java.io.IOException;
import java.io.InputStream;

@Configuration
@Slf4j
public class FirebaseConfig {

    // NOUVELLE INJECTION : ID du projet Firebase pour les notifications
    @Value("${freelancedriver.firebase.project-id}") 
    private String firebaseProjectId;

    @Bean
    public FirebaseApp firebaseApp() throws IOException {
        if (FirebaseApp.getApps().isEmpty()) {
            log.info("Initialisation du SDK Admin de Firebase...");
            ClassPathResource resource = new ClassPathResource("firebase-service-account-key.json");
            if (!resource.exists()) {
                log.error("Le fichier 'firebase-service-account-key.json' est introuvable dans src/main/resources/");
                throw new IOException("Le fichier firebase-service-account-key.json est introuvable.");
            }

            try (InputStream serviceAccount = resource.getInputStream()) {
                FirebaseOptions options = FirebaseOptions.builder()
                    .setCredentials(GoogleCredentials.fromStream(serviceAccount))
                    .setProjectId(firebaseProjectId) // <-- UTILISE LE NOUVEAU NOM
                    .build();

                FirebaseApp app = FirebaseApp.initializeApp(options);
                log.info("‚úÖ SDK Admin de Firebase initialis√© avec succ√®s pour le projet : {}", app.getName());
                return app; 
            }
        } else {
            log.warn("Le SDK Admin de Firebase est d√©j√† initialis√©. R√©cup√©ration de l'instance existante.");
            return FirebaseApp.getInstance(); 
        }
    }

    @Bean
    public FirebaseMessaging firebaseMessaging(FirebaseApp firebaseApp) {
        return FirebaseMessaging.getInstance(firebaseApp);
    }
}// END OF FILE: src/main/java/com/freelance/driver_backend/config/FirebaseConfig.java

//---> PATH: /home/mbogneng-junior/freelance-driver_Sylladb/backend/src/main/java/com/freelance/driver_backend/config/JwtConfig.java

package com.freelance.driver_backend.config;

import com.nimbusds.jose.jwk.JWK;
import com.nimbusds.jose.jwk.JWKSet;
import com.nimbusds.jose.jwk.RSAKey;
import com.nimbusds.jose.jwk.source.ImmutableJWKSet;
import com.nimbusds.jose.jwk.source.JWKSource;
import com.nimbusds.jose.proc.SecurityContext;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.oauth2.jwt.JwtDecoder;
import org.springframework.security.oauth2.jwt.JwtEncoder;
import org.springframework.security.oauth2.jwt.NimbusJwtDecoder;
import org.springframework.security.oauth2.jwt.NimbusJwtEncoder;

import java.security.KeyPair;
import java.security.KeyPairGenerator;
import java.security.interfaces.RSAPrivateKey;
import java.security.interfaces.RSAPublicKey;

@Configuration
public class JwtConfig {

    @Bean
    public KeyPair keyPair() {
        try {
            KeyPairGenerator keyPairGenerator = KeyPairGenerator.getInstance("RSA");
            keyPairGenerator.initialize(2048);
            return keyPairGenerator.generateKeyPair();
        } catch (Exception e) {
            throw new RuntimeException("Erreur lors de la g√©n√©ration des cl√©s RSA", e);
        }
    }

    @Bean
    public JWKSource<SecurityContext> jwkSource(KeyPair keyPair) {
        RSAPublicKey publicKey = (RSAPublicKey) keyPair.getPublic();
        RSAPrivateKey privateKey = (RSAPrivateKey) keyPair.getPrivate();
        
        JWK jwk = new RSAKey.Builder(publicKey)
                .privateKey(privateKey)
                .keyID("jwt-key-id")
                .build();
        
        JWKSet jwkSet = new JWKSet(jwk);
        return new ImmutableJWKSet<>(jwkSet);
    }

    @Bean
    public JwtEncoder jwtEncoder(JWKSource<SecurityContext> jwkSource) {
        return new NimbusJwtEncoder(jwkSource);
    }

    // RENOMMER le bean pour √©viter le conflit avec SecurityConfig
    @Bean("localJwtDecoder")
    public JwtDecoder localJwtDecoder(KeyPair keyPair) {
        RSAPublicKey publicKey = (RSAPublicKey) keyPair.getPublic();
        return NimbusJwtDecoder.withPublicKey(publicKey).build();
    }
}// END OF FILE: src/main/java/com/freelance/driver_backend/config/JwtConfig.java

//---> PATH: /home/mbogneng-junior/freelance-driver_Sylladb/backend/src/main/java/com/freelance/driver_backend/config/SecurityConfig.java

package com.freelance.driver_backend.config;

import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.core.annotation.Order;
import org.springframework.http.HttpMethod;
import org.springframework.security.config.annotation.web.reactive.EnableWebFluxSecurity;
import org.springframework.security.config.web.server.ServerHttpSecurity;
import org.springframework.security.oauth2.jwt.NimbusReactiveJwtDecoder;
import org.springframework.security.oauth2.jwt.ReactiveJwtDecoder;
import org.springframework.security.web.server.SecurityWebFilterChain;
import org.springframework.security.web.server.util.matcher.PathPatternParserServerWebExchangeMatcher;
import org.springframework.web.cors.CorsConfiguration;
import org.springframework.web.cors.reactive.CorsConfigurationSource;
import org.springframework.web.cors.reactive.UrlBasedCorsConfigurationSource;

import java.security.KeyPair;
import java.security.interfaces.RSAPublicKey;
import java.util.Arrays;

@Configuration
@EnableWebFluxSecurity
public class SecurityConfig {

    @Value("${spring.security.oauth2.resourceserver.jwt.jwk-set-uri}")
    private String jwkSetUri;

    // ==============================================================================
    //                       CHA√éNE DE FILTRES DE S√âCURIT√â UNIQUE
    // ==============================================================================
    
    @Bean
    @Order(0) // Priorit√© la plus haute
    public SecurityWebFilterChain apiFilterChain(ServerHttpSecurity http) throws Exception {
        http
            // ===== CORRECTION 1 : Int√©grer la configuration CORS dans la cha√Æne de s√©curit√© =====
            .cors(cors -> cors.configurationSource(corsConfigurationSource()))
            
            // Appliquer cette configuration √† toutes les routes sous /api/
            .securityMatcher(new PathPatternParserServerWebExchangeMatcher("/api/**"))
            .csrf(ServerHttpSecurity.CsrfSpec::disable)
            .authorizeExchange(exchanges -> exchanges
                // ===== CORRECTION 2 : Autoriser explicitement les requ√™tes de pr√©-v√©rification (preflight) OPTIONS =====
                .pathMatchers(HttpMethod.OPTIONS, "/**").permitAll()
                
                // --- Routes Publiques (permitAll) ---
                
                // POST publics (Login, Register, Onboarding)
                .pathMatchers(HttpMethod.POST, 
                    "/api/register", 
                    "/api/auth/login", 
                    "/api/onboarding/**"
                ).permitAll()
                
                // GET publics (Recherche, Profils publics, Annonces publi√©es)
                .pathMatchers(HttpMethod.GET,
                    "/api/announcements", 
                    "/api/planning/published", 
                    "/api/planning/user/**",
                    "/api/search/**",           
                    "/api/reviews/user/**", 
                    "/api/profiles/user/**", 
                    "/api/vehicles/user/**", 
                    "/api/addresses/user/**", 
                    "/api/experiences/user/**"
                ).permitAll()

                // Routes pour les mocks de d√©veloppement
                .pathMatchers("/api/mock-**/**").permitAll()
                .pathMatchers("/api/mock_user/**", "/api/mock_auth/**").permitAll()

                // --- Routes S√©curis√©es (authenticated) ---
                // Toutes les autres requ√™tes n√©cessitent une authentification
                .anyExchange().authenticated()
            )
            // Configurer le serveur de ressources OAuth2 pour valider les tokens JWT
            .oauth2ResourceServer(oauth2 -> oauth2.jwt(jwt -> { }));

        return http.build();
    }

    // ==============================================================================
    //                       CONFIGURATION CORS ET JWT
    // ==============================================================================

    @Bean
    public CorsConfigurationSource corsConfigurationSource() {
        CorsConfiguration configuration = new CorsConfiguration();
        
        // IMPORTANT : Pour la production, vous devriez remplacer "*" par l'URL de votre frontend
        // Par exemple : configuration.setAllowedOrigins(Arrays.asList("https://mon-app.com"));
        configuration.addAllowedOriginPattern("*"); 
        
        configuration.setAllowedMethods(Arrays.asList("GET", "POST", "PUT", "DELETE", "OPTIONS"));
        configuration.setAllowedHeaders(Arrays.asList("*"));
        
        // Laisser √† 'false' si vous ne g√©rez pas de cookies/sessions cross-domain
        // configuration.setAllowCredentials(true); 
        
        UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();
        source.registerCorsConfiguration("/**", configuration);
        return source;
    }
  
   @Bean
    public ReactiveJwtDecoder jwtDecoder(KeyPair keyPair) {
        RSAPublicKey publicKey = (RSAPublicKey) keyPair.getPublic();
        return NimbusReactiveJwtDecoder.withPublicKey(publicKey).build();
    }
}// END OF FILE: src/main/java/com/freelance/driver_backend/config/SecurityConfig.java

//---> PATH: /home/mbogneng-junior/freelance-driver_Sylladb/backend/src/main/java/com/freelance/driver_backend/config/SocketIOConfig.java

// src/main/java/com/freelance/driver_backend/config/SocketIOConfig.java

package com.freelance.driver_backend.config;

import com.corundumstudio.socketio.SocketIOServer;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class SocketIOConfig {

    @Value("${socketio.server.host}")
    private String host;

    @Value("${socketio.server.port}")
    private Integer port;

    @Bean
    public SocketIOServer socketIOServer() {
        com.corundumstudio.socketio.Configuration config = new com.corundumstudio.socketio.Configuration();
        config.setHostname(host);
        config.setPort(port);

        // Cette ligne est cruciale pour autoriser les connexions depuis votre application mobile et le web.
        config.setOrigin("*");

        return new SocketIOServer(config);
    }
}// END OF FILE: src/main/java/com/freelance/driver_backend/config/SocketIOConfig.java

//---> PATH: /home/mbogneng-junior/freelance-driver_Sylladb/backend/src/main/java/com/freelance/driver_backend/config/ThymeleafConfig.java

package com.freelance.driver_backend.config;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.thymeleaf.spring6.SpringTemplateEngine;
import org.thymeleaf.templatemode.TemplateMode;
import org.thymeleaf.templateresolver.StringTemplateResolver;
import org.springframework.context.annotation.Primary;

@Configuration
public class ThymeleafConfig {

    /**
     * Configure un moteur de template Thymeleaf capable de traiter des cha√Ænes de caract√®res.
     * On le marque comme @Primary pour qu'il soit choisi par d√©faut lors de l'injection
     * de d√©pendances, au lieu de celui configur√© automatiquement par Spring Boot.
     * @return Une instance de SpringTemplateEngine.
     */
    @Bean
    @Primary // <-- AJOUTER CETTE ANNOTATION
    public SpringTemplateEngine springTemplateEngine() {
        SpringTemplateEngine templateEngine = new SpringTemplateEngine();
        
        // Cr√©er un "resolver" qui sait lire des cha√Ænes de caract√®res
        StringTemplateResolver stringTemplateResolver = new StringTemplateResolver();
        stringTemplateResolver.setTemplateMode(TemplateMode.HTML); // Pr√©ciser qu'on traite du HTML
        
        // Ajouter ce resolver au moteur de template
        templateEngine.addTemplateResolver(stringTemplateResolver);
        
        return templateEngine;
    }
}// END OF FILE: src/main/java/com/freelance/driver_backend/config/ThymeleafConfig.java

//---> PATH: /home/mbogneng-junior/freelance-driver_Sylladb/backend/src/main/java/com/freelance/driver_backend/config/WebClientConfig.java

package com.freelance.driver_backend.config;

import io.netty.channel.ChannelOption;
import io.netty.handler.timeout.ReadTimeoutHandler;
import io.netty.handler.timeout.WriteTimeoutHandler;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.http.HttpHeaders;
import org.springframework.http.MediaType;
import org.springframework.http.client.reactive.ReactorClientHttpConnector;
import org.springframework.web.reactive.function.client.WebClient;
import reactor.netty.http.client.HttpClient;

import java.time.Duration;
import java.util.concurrent.TimeUnit;

@Configuration
public class WebClientConfig {

    @Value("${microservices.chat-service.url}")
    private String chatServiceUrl;

    @Value("${microservices.auth-service.url}")
    private String authServiceUrl;

    @Value("${microservices.organisation-service.url}")
    private String organisationServiceUrl;

    @Value("${server.port}")
    private String localServerPort;

    @Value("${microservices.resource-service.url}")
    private String resourceServiceUrl;

    @Value("${microservices.media-service.url}") // URL du service de m√©dias, nouvellement ajout√©e
    private String mediaServiceUrl;

    /**
     * Cr√©e un HttpClient r√©utilisable avec des timeouts standards.
     * 
     * @return HttpClient configur√©
     */
    private HttpClient createConfiguredHttpClient() {
        return HttpClient.create()
                .option(ChannelOption.CONNECT_TIMEOUT_MILLIS, 20000) // 20 secondes
                .responseTimeout(Duration.ofSeconds(20)) // 20 secondes
                .doOnConnected(conn -> conn.addHandlerLast(new ReadTimeoutHandler(20, TimeUnit.SECONDS))
                        .addHandlerLast(new WriteTimeoutHandler(20, TimeUnit.SECONDS)));
    }

    /**
     * Cr√©e un HttpClient configur√© avec des timeouts plus longs pour les op√©rations
     * de m√©dia.
     * Les t√©l√©versements de fichiers peuvent prendre plus de temps.
     * 
     * @return HttpClient configur√© pour les m√©dias
     */
    private HttpClient createMediaServiceHttpClient() {
        return HttpClient.create()
                // --- CORRECTION APPLIQU√âE ICI ---
                .followRedirect(true) // <-- DIT AU CLIENT DE SUIVRE AUTOMATIQUEMENT LES REDIRECTIONS (COMME 301)
                .option(ChannelOption.CONNECT_TIMEOUT_MILLIS, 30000) // 30 secondes pour la connexion
                .responseTimeout(Duration.ofSeconds(60)) // 60 secondes pour la r√©ponse compl√®te
                .doOnConnected(conn -> conn.addHandlerLast(new ReadTimeoutHandler(60, TimeUnit.SECONDS)) // 60s read
                                                                                                         // timeout
                        .addHandlerLast(new WriteTimeoutHandler(60, TimeUnit.SECONDS))); // 60s write timeout
    }

    @Bean
    @Qualifier("authServiceWebClient")
    public WebClient authServiceWebClient() {
        return WebClient.builder()
                .baseUrl(authServiceUrl)
                .clientConnector(new ReactorClientHttpConnector(createConfiguredHttpClient()))
                .defaultHeader(HttpHeaders.CONTENT_TYPE, MediaType.APPLICATION_JSON_VALUE)
                .build();
    }

    @Bean
    @Qualifier("organisationServiceWebClient")
    public WebClient organisationServiceWebClient() {
        return WebClient.builder()
                .baseUrl(organisationServiceUrl)
                .clientConnector(new ReactorClientHttpConnector(createConfiguredHttpClient()))
                .defaultHeader(HttpHeaders.CONTENT_TYPE, MediaType.APPLICATION_JSON_VALUE)
                .build();
    }

    @Bean
    @Qualifier("chatServiceWebClient")
    public WebClient chatServiceWebClient() {
        return WebClient.builder()
                .baseUrl(chatServiceUrl)
                .clientConnector(new ReactorClientHttpConnector(createConfiguredHttpClient()))
                .defaultHeader(HttpHeaders.CONTENT_TYPE, MediaType.APPLICATION_JSON_VALUE)
                .build();
    }

    @Bean
    @Qualifier("localApiWebClient")
    public WebClient localApiWebClient() {
        return WebClient.builder().baseUrl("http://localhost:" + localServerPort).build();
    }

    @Bean
    @Qualifier("externalResourceWebClient")
    public WebClient externalResourceWebClient() {
        return WebClient.builder().baseUrl(resourceServiceUrl).build();
    }

    /**
     * Cr√©e un WebClient pour interagir avec le service de m√©dias externe.
     * Utilise des timeouts plus longs pour les op√©rations de fichiers.
     * 
     * @return WebClient configur√© pour le service de m√©dias
     */
    @Bean
    @Qualifier("externalMediaServiceWebClient")
    public WebClient externalMediaServiceWebClient() {
        return WebClient.builder()
                .baseUrl(mediaServiceUrl)
                .clientConnector(new ReactorClientHttpConnector(createMediaServiceHttpClient()))
                // Le Content-Type est d√©fini par BodyInserters.fromMultipartData() pour les
                // uploads de fichiers
                .build();
    }

    

    @Bean
    @Qualifier("mockWebClient")
    public WebClient mockWebClient() {
        return WebClient.builder()
                .baseUrl("http://localhost:" + localServerPort)
                .clientConnector(new ReactorClientHttpConnector(createConfiguredHttpClient()))
                .defaultHeader(HttpHeaders.CONTENT_TYPE, MediaType.APPLICATION_JSON_VALUE)
                .build();
    }

}// END OF FILE: src/main/java/com/freelance/driver_backend/config/WebClientConfig.java

//---> PATH: /home/mbogneng-junior/freelance-driver_Sylladb/backend/src/main/java/com/freelance/driver_backend/controller/AddressController.java



// PATH: /home/mbogneng-junior/freelance-driver (Copie)/backend/src/main/java/com/freelance/driver_backend/controller/AddressController.java

package com.freelance.driver_backend.controller;

import com.freelance.driver_backend.dto.CreateProductRequest;
import com.freelance.driver_backend.dto.UserSessionContextDto; // Nouveau import
import com.freelance.driver_backend.model.Product;
import com.freelance.driver_backend.service.ProfileService;
import com.freelance.driver_backend.service.ResourceService;
import com.freelance.driver_backend.util.JwtUtil;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.core.annotation.AuthenticationPrincipal;
import org.springframework.security.oauth2.jwt.Jwt;
import org.springframework.web.bind.annotation.*;
import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;

import java.util.Optional;
import java.util.UUID;

@RestController
@RequestMapping("/api/addresses")
@RequiredArgsConstructor
@Slf4j
public class AddressController {

    private final ProfileService profileService;
    private final ResourceService resourceService;

    // Un UUID fixe et unique pour identifier toutes les adresses dans la table "products"
    private static final UUID ADDRESS_CATEGORY_ID = UUID.fromString("4a6f8b90-1234-5678-9abc-def012345678");

    /**
     * SECURISE: R√©cup√®re toutes les adresses de l'utilisateur actuellement connect√©.
     */
    @GetMapping
    public Flux<Product> getUserAddresses(
            @AuthenticationPrincipal Mono<Jwt> jwtMono,
            @RequestHeader("Authorization") String authorizationHeader) {
        
        return jwtMono
            .flatMap(jwt -> profileService.getUserSessionContext(JwtUtil.getUserIdFromToken(jwt), authorizationHeader, null))
            .flatMapMany(userContext -> {
                // Un utilisateur devrait toujours avoir une organisation apr√®s l'onboarding initial
                if (userContext.getOrganisation() == null || userContext.getOrganisation().getOrganizationId() == null) {
                    return Flux.error(new IllegalStateException("L'utilisateur n'a pas d'organisation valide associ√©e."));
                }
                UUID organizationId = userContext.getOrganisation().getOrganizationId();
                // Utilise le service de ressources pour obtenir les produits par cat√©gorie et par client_id (l'utilisateur connect√©)
                // NOTE: getProductsByCategory ne filtre pas par clientId, il faut le faire apr√®s ou modifier le service de ressources
                return resourceService.getProductsByCategory(organizationId, ADDRESS_CATEGORY_ID, authorizationHeader, null)
                                      .filter(product -> userContext.getUserId().equals(product.getClientId())); // Filtrer par l'ID de l'utilisateur connect√©
            });
    }

    /**
     * PUBLIC: R√©cup√®re les adresses d'un utilisateur sp√©cifique par son ID.
     */
    @GetMapping("/user/{userId}")
    public Flux<Product> getAddressesForUser(
        @PathVariable UUID userId,
        @RequestHeader(value = "Authorization", required = false) String authorizationHeader
    ) {
        log.info("‚ñ∂Ô∏è [AddressController] R√©cup√©ration des adresses publiques pour l'utilisateur ID: {}", userId);

        String token = Optional.ofNullable(authorizationHeader).orElse(null);

        // MODIFI√â : R√©cup√®re l'organisation ID du userId sp√©cifi√©.
        // Puis, filtre les produits de cette organisation qui appartiennent √† ce userId.
        return profileService.findOrganisationIdByUserId(userId)
             .flatMapMany(orgId ->
                resourceService.getProductsByCategory(orgId, ADDRESS_CATEGORY_ID, token, null)
                               .filter(product -> userId.equals(product.getClientId())) // Filtrer par l'ID de l'utilisateur demand√©
             )
             .doOnComplete(() -> log.info("‚úÖ [addressService] Adresses publiques trouv√©es pour l'utilisateur {}.", userId))
             .doOnError(error -> log.error("‚ùå Erreur lors de la r√©cup√©ration des adresses pour {}: {}", userId, error.getMessage()));
    }


    /**
     * SECURISE: Cr√©e une nouvelle adresse pour l'utilisateur connect√©.
     */
    @PostMapping
    public Mono<ResponseEntity<Product>> createAddress(
            @RequestBody CreateProductRequest request,
            @AuthenticationPrincipal Mono<Jwt> jwtMono,
            @RequestHeader("Authorization") String authorizationHeader) {

        return jwtMono
            .flatMap(jwt -> profileService.getUserSessionContext(JwtUtil.getUserIdFromToken(jwt), authorizationHeader, null))
            .flatMap(userContext -> {
                if (userContext.getOrganisation() == null || userContext.getOrganisation().getOrganizationId() == null) {
                    return Mono.error(new IllegalStateException("Contexte utilisateur invalide pour cr√©er une adresse (organisation manquante)."));
                }
                
                // On s'assure que la bonne cat√©gorie et l'ID du propri√©taire sont d√©finis
                request.setCategoryId(ADDRESS_CATEGORY_ID);
                request.setClientId(userContext.getUserId()); // L'ID de l'utilisateur connect√© est le propri√©taire
                
                log.info("‚ñ∂Ô∏è Controller: Cr√©ation d'une nouvelle adresse '{}' pour l'utilisateur {}", request.getName(), userContext.getUserId());
                
                return resourceService.createProduct(
                    userContext.getOrganisation().getOrganizationId(), 
                    request, 
                    authorizationHeader, 
                    null
                );
            })
            .map(createdProduct -> new ResponseEntity<>(createdProduct, HttpStatus.CREATED));
    }

    /**
     * SECURISE: Met √† jour une adresse existante.
     */
    @PutMapping("/{addressId}")
    public Mono<ResponseEntity<Product>> updateAddress(
            @PathVariable UUID addressId,
            @RequestBody CreateProductRequest request,
            @AuthenticationPrincipal Mono<Jwt> jwtMono,
            @RequestHeader("Authorization") String authorizationHeader) {
        
        return jwtMono
            .flatMap(jwt -> profileService.getUserSessionContext(JwtUtil.getUserIdFromToken(jwt), authorizationHeader, null))
            .flatMap(userContext -> {
                if (userContext.getOrganisation() == null || userContext.getOrganisation().getOrganizationId() == null) {
                    return Mono.error(new IllegalStateException("Contexte utilisateur invalide pour mettre √† jour une adresse (organisation manquante)."));
                }
                // V√©rification cruciale : l'utilisateur connect√© est-il le propri√©taire de l'adresse ?
                return resourceService.getProductsByCategory(userContext.getOrganisation().getOrganizationId(), ADDRESS_CATEGORY_ID, authorizationHeader, null)
                        .filter(product -> product.getId().equals(addressId) && userContext.getUserId().equals(product.getClientId()))
                        .next() // Prend le premier √©l√©ment ou vide
                        .switchIfEmpty(Mono.error(new SecurityException("L'utilisateur n'est pas autoris√© √† modifier cette adresse ou elle n'existe pas.")))
                        .flatMap(existingAddress -> {
                            request.setCategoryId(ADDRESS_CATEGORY_ID);
                            request.setClientId(userContext.getUserId()); // Assure que le propri√©taire reste le m√™me
                            log.info("‚ñ∂Ô∏è Controller: Mise √† jour de l'adresse ID: {}", addressId);
                            
                            return resourceService.updateProduct(
                                userContext.getOrganisation().getOrganizationId(), 
                                addressId,
                                request, 
                                authorizationHeader, 
                                null
                            );
                        });
            })
            .map(ResponseEntity::ok)
            .defaultIfEmpty(ResponseEntity.notFound().build());
    }

    /**
     * SECURISE: Supprime une adresse existante.
     */
    @DeleteMapping("/{addressId}")
    public Mono<ResponseEntity<Void>> deleteAddress(
            @PathVariable UUID addressId,
            @AuthenticationPrincipal Mono<Jwt> jwtMono,
            @RequestHeader("Authorization") String authorizationHeader) {

        return jwtMono
            .flatMap(jwt -> profileService.getUserSessionContext(JwtUtil.getUserIdFromToken(jwt), authorizationHeader, null))
            .flatMap(userContext -> {
                if (userContext.getOrganisation() == null || userContext.getOrganisation().getOrganizationId() == null) {
                    return Mono.error(new IllegalStateException("Contexte utilisateur invalide pour supprimer une adresse (organisation manquante)."));
                }
                // V√©rification cruciale : l'utilisateur connect√© est-il le propri√©taire de l'adresse ?
                return resourceService.getProductsByCategory(userContext.getOrganisation().getOrganizationId(), ADDRESS_CATEGORY_ID, authorizationHeader, null)
                        .filter(product -> product.getId().equals(addressId) && userContext.getUserId().equals(product.getClientId()))
                        .next() // Prend le premier √©l√©ment ou vide
                        .switchIfEmpty(Mono.error(new SecurityException("L'utilisateur n'est pas autoris√© √† supprimer cette adresse ou elle n'existe pas.")))
                        .flatMap(existingAddress -> {
                            log.info("‚ñ∂Ô∏è Controller: Suppression de l'adresse ID: {}", addressId);
                            return resourceService.deleteProduct(
                                userContext.getOrganisation().getOrganizationId(), 
                                addressId,
                                authorizationHeader, 
                                null
                            );
                        });
            })
            .then(Mono.just(new ResponseEntity<Void>(HttpStatus.NO_CONTENT)));
    }
}// END OF FILE: src/main/java/com/freelance/driver_backend/controller/AddressController.java

//---> PATH: /home/mbogneng-junior/freelance-driver_Sylladb/backend/src/main/java/com/freelance/driver_backend/controller/AnnouncementController.java


package com.freelance.driver_backend.controller;

import com.corundumstudio.socketio.SocketIOServer;
import com.freelance.driver_backend.dto.CreateProductRequest;
import com.freelance.driver_backend.dto.UserSessionContextDto;
import com.freelance.driver_backend.model.ClientProfile;
import com.freelance.driver_backend.model.DriverProfile;
import com.freelance.driver_backend.model.Product;
import com.freelance.driver_backend.model.ProductKey;
import com.freelance.driver_backend.repository.ProductRepository;
import com.freelance.driver_backend.service.NotificationTriggerService;
import com.freelance.driver_backend.service.ProfileService;
import com.freelance.driver_backend.service.ResourceService;
import com.freelance.driver_backend.util.JwtUtil;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.core.annotation.AuthenticationPrincipal;
import org.springframework.security.oauth2.jwt.Jwt;
import org.springframework.web.bind.annotation.*;
import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;

import java.util.UUID;

@RestController
@RequestMapping("/api/announcements")
@RequiredArgsConstructor
@Slf4j
public class AnnouncementController {

    private final ResourceService resourceService;
    private final ProfileService profileService;
    private final ProductRepository productRepository; 
    private final NotificationTriggerService notificationTriggerService;
    private final SocketIOServer socketIOServer; 

    private static final UUID ANNOUNCEMENT_CATEGORY_ID = UUID.fromString("c1a5b4e0-1234-5678-9abc-def012345678");

    /**
     * PUBLIC: R√©cup√®re toutes les annonces publi√©es par les clients.
     */
    @GetMapping
    public Flux<Product> getPublishedAnnouncements() {
        log.info("Controller: Requ√™te publique pour r√©cup√©rer les annonces publi√©es.");
        return productRepository.findByCategoryId(ANNOUNCEMENT_CATEGORY_ID)
                .filter(product -> "Published".equalsIgnoreCase(product.getStatus()))
                .flatMap(this::enrichProductWithAuthorDetails);
    }

    /**
     * SECURISE (CLIENT): R√©cup√®re les annonces du client actuellement connect√©.
     */
    @GetMapping("/my-announcements")
    public Flux<Product> getMyAnnouncements(
            @AuthenticationPrincipal Mono<Jwt> jwtMono,
            @RequestHeader("Authorization") String authorizationHeader) { 
        return jwtMono
            .flatMap(jwt -> profileService.getUserSessionContext(JwtUtil.getUserIdFromToken(jwt), authorizationHeader, null))
            .flatMapMany(userContext -> {
                if (userContext.getClientProfile() == null) {
                     return Flux.error(new IllegalStateException("L'utilisateur n'est pas un client."));
                }
                return productRepository.findByClientIdAndCategoryId(userContext.getUserId(), ANNOUNCEMENT_CATEGORY_ID);
            });
    }

    /**
     * SECURISE (CLIENT): Cr√©e une nouvelle annonce pour le client connect√©.
     */
    @PostMapping
    public Mono<ResponseEntity<Product>> createAnnouncement(
            @RequestBody CreateProductRequest request,
            @AuthenticationPrincipal Mono<Jwt> jwtMono,
            @RequestHeader("Authorization") String authorizationHeader) {

        return jwtMono
            .flatMap(jwt -> profileService.getUserSessionContext(JwtUtil.getUserIdFromToken(jwt), authorizationHeader, null))
            .flatMap(userContext -> {
                if (userContext.getClientProfile() == null) {
                    return Mono.error(new IllegalStateException("Seul un client peut cr√©er une annonce."));
                }
                if (userContext.getOrganisation() == null || userContext.getOrganisation().getOrganizationId() == null) {
                    return Mono.error(new IllegalStateException("Contexte utilisateur invalide pour cr√©er une annonce (organisation manquante)."));
                }
                ClientProfile clientProfile = userContext.getClientProfile(); 
                
                request.setCategoryId(ANNOUNCEMENT_CATEGORY_ID);
                request.setClientId(clientProfile.getUserId());
                request.setClientName(clientProfile.getFirstName() + " " + clientProfile.getLastName());
                request.setClientPhoneNumber(clientProfile.getPhoneNumber());
                request.setClientProfileImageUrl(clientProfile.getProfileImageUrl());

                return resourceService.createProduct(userContext.getOrganisation().getOrganizationId(), request, authorizationHeader, null);
            })
            .map(createdProduct -> new ResponseEntity<>(createdProduct, HttpStatus.CREATED));
    }

    /**
     * SECURISE (CLIENT): Met √† jour une annonce appartenant au client connect√©.
     */
    @PutMapping("/{productId}")
    public Mono<ResponseEntity<Product>> updateAnnouncement(
            @PathVariable UUID productId,
            @RequestBody CreateProductRequest request,
            @AuthenticationPrincipal Mono<Jwt> jwtMono,
            @RequestHeader("Authorization") String authorizationHeader) {
        
        return jwtMono
            .flatMap(jwt -> profileService.getUserSessionContext(JwtUtil.getUserIdFromToken(jwt), authorizationHeader, null))
            .flatMap(userContext -> {
                if (userContext.getClientProfile() == null) {
                    return Mono.error(new IllegalStateException("Seuls les clients peuvent modifier leurs annonces."));
                }
                if (userContext.getOrganisation() == null || userContext.getOrganisation().getOrganizationId() == null) {
                    return Mono.error(new IllegalStateException("Contexte utilisateur invalide pour mettre √† jour une annonce (organisation manquante)."));
                }
                ClientProfile clientProfile = userContext.getClientProfile();

                return productRepository.findById(new ProductKey(userContext.getOrganisation().getOrganizationId(), productId))
                        .filter(product -> clientProfile.getUserId().equals(product.getClientId()))
                        .switchIfEmpty(Mono.error(new SecurityException("Le client n'est pas autoris√© √† modifier cette annonce ou elle n'existe pas.")))
                        .flatMap(existingAnnouncement -> {
                            return resourceService.updateProduct(userContext.getOrganisation().getOrganizationId(), productId, request, authorizationHeader, null);
                        });
            })
            .doOnSuccess(updatedAnnouncement -> {
                if (updatedAnnouncement != null) {
                    socketIOServer.getBroadcastOperations().sendEvent("updated_announcement", updatedAnnouncement);
                }
            })
            .map(ResponseEntity::ok)
            .defaultIfEmpty(ResponseEntity.notFound().build());
    }
    
    /**
     * SECURISE (CLIENT): Supprime une annonce appartenant au client connect√©.
     */
    @DeleteMapping("/{productId}")
    public Mono<ResponseEntity<Void>> deleteAnnouncement(
            @PathVariable UUID productId,
            @AuthenticationPrincipal Mono<Jwt> jwtMono,
            @RequestHeader("Authorization") String authorizationHeader) {

        return jwtMono
            .flatMap(jwt -> profileService.getUserSessionContext(JwtUtil.getUserIdFromToken(jwt), authorizationHeader, null))
            .flatMap(userContext -> {
                if (userContext.getClientProfile() == null) {
                    return Mono.error(new IllegalStateException("Seuls les clients peuvent supprimer leurs annonces."));
                }
                if (userContext.getOrganisation() == null || userContext.getOrganisation().getOrganizationId() == null) {
                    return Mono.error(new IllegalStateException("Contexte utilisateur invalide pour supprimer une annonce (organisation manquante)."));
                }
                ClientProfile clientProfile = userContext.getClientProfile();

                return productRepository.findById(new ProductKey(userContext.getOrganisation().getOrganizationId(), productId))
                        .filter(product -> clientProfile.getUserId().equals(product.getClientId()))
                        .switchIfEmpty(Mono.error(new SecurityException("Le client n'est pas autoris√© √† supprimer cette annonce ou elle n'existe pas.")))
                        .flatMap(existingAnnouncement ->
                            resourceService.deleteProduct(userContext.getOrganisation().getOrganizationId(), productId, authorizationHeader, null)
                        );
            })
            .then(Mono.just(new ResponseEntity<Void>(HttpStatus.NO_CONTENT)));
    }

    /**
     * SECURISE (CONDUCTEUR): Permet √† un conducteur de POSTULER √† une annonce.
     * Le statut de l'annonce passe √† "PendingConfirmation". Une notification est envoy√©e au client.
     */
    @PostMapping("/{announcementId}/apply")
    public Mono<ResponseEntity<Product>> applyToAnnouncement(
            @PathVariable UUID announcementId,
            @AuthenticationPrincipal Mono<Jwt> jwtMono,
            @RequestHeader("Authorization") String authorizationHeader) {

        return jwtMono
            .flatMap(jwt -> profileService.getUserSessionContext(JwtUtil.getUserIdFromToken(jwt), authorizationHeader, null))
            .flatMap(driverContext -> {
                if (driverContext.getDriverProfile() == null) {
                    return Mono.error(new IllegalStateException("Seul un chauffeur peut postuler √† une annonce."));
                }
                DriverProfile driverProfile = driverContext.getDriverProfile();
                
                return productRepository.findAll().filter(p -> p.getId().equals(announcementId)).next()
                    .flatMap(announcement -> {
                         ProductKey key = new ProductKey(announcement.getOrganizationId(), announcementId);
                         return productRepository.findById(key)
                            .flatMap(ann -> {
                                if (ann.getReservedByDriverId() != null) {
                                    return Mono.error(new IllegalStateException("Cette annonce a d√©j√† √©t√© postul√©e/r√©serv√©e."));
                                }
                                ann.setReservedByDriverId(driverProfile.getUserId());
                                ann.setReservedByDriverName(driverProfile.getFirstName() + " " + driverProfile.getLastName());
                                ann.setStatus("PendingConfirmation");
                                log.info("Chauffeur {} a postul√© pour l'annonce {}. Statut mis √† jour √† 'PendingConfirmation'.", driverProfile.getUserId(), announcementId);
                                return productRepository.save(ann);
                            })
                            .flatMap(updatedAnnouncement -> {
                                socketIOServer.getBroadcastOperations().sendEvent("updated_announcement", updatedAnnouncement);
                                log.info("D√©clenchement de la notification pour le client de l'annonce {} (postulation par chauffeur {}).", announcementId, driverProfile.getUserId());
                                return notificationTriggerService.notifyClientOfAcceptedAnnouncement(updatedAnnouncement, driverProfile)
                                    .thenReturn(updatedAnnouncement);
                            });
                    });
            })
            .map(ResponseEntity::ok)
            .defaultIfEmpty(ResponseEntity.notFound().build());
    }

    /**
     * SECURISE (CONDUCTEUR): Permet √† un CONDUCTEUR d'annuler une postulation.
     * Le statut de l'annonce revient √† "Published". Une notification est envoy√©e au client.
     */
    @PostMapping("/{announcementId}/cancel-postulation") // <-- NOUVEL ENDPOINT POUR L'ANNULATION
    public Mono<ResponseEntity<Product>> cancelPostulation(
            @PathVariable UUID announcementId,
            @AuthenticationPrincipal Mono<Jwt> jwtMono,
            @RequestHeader("Authorization") String authorizationHeader) {

        return jwtMono
            .flatMap(jwt -> profileService.getUserSessionContext(JwtUtil.getUserIdFromToken(jwt), authorizationHeader, null))
            .flatMap(driverContext -> {
                if (driverContext.getDriverProfile() == null) {
                    return Mono.error(new IllegalStateException("Seul un chauffeur peut annuler une postulation."));
                }
                DriverProfile driverProfile = driverContext.getDriverProfile();

                return productRepository.findAll().filter(p -> p.getId().equals(announcementId)).next()
                    .flatMap(announcement -> {
                        if (!driverProfile.getUserId().equals(announcement.getReservedByDriverId())) {
                            return Mono.error(new SecurityException("Vous n'avez pas postul√© √† cette annonce ou n'√™tes pas le chauffeur concern√©."));
                        }
                        if (!"PendingConfirmation".equalsIgnoreCase(announcement.getStatus()) && !"Ongoing".equalsIgnoreCase(announcement.getStatus())) {
                            return Mono.error(new IllegalStateException("L'annonce n'est pas dans un √©tat permettant l'annulation de postulation (statut actuel: " + announcement.getStatus() + ")."));
                        }

                        ProductKey key = new ProductKey(announcement.getOrganizationId(), announcementId);
                        return productRepository.findById(key)
                            .flatMap(ann -> {
                                ann.setReservedByDriverId(null);
                                ann.setReservedByDriverName(null);
                                ann.setStatus("Published"); // Revenir au statut "Published"
                                log.info("Chauffeur {} a annul√© sa postulation pour l'annonce {}. Statut remis √† 'Published'.", driverProfile.getUserId(), announcementId);
                                return productRepository.save(ann);
                            })
                            .flatMap(updatedAnnouncement -> {
                                socketIOServer.getBroadcastOperations().sendEvent("updated_announcement", updatedAnnouncement);
                                log.info("D√©clenchement de la notification pour le client de l'annonce {} (annulation de postulation par chauffeur {}).", announcementId, driverProfile.getUserId());
                                return notificationTriggerService.notifyClientOfCancelledPostulation(updatedAnnouncement, driverProfile)
                                    .thenReturn(updatedAnnouncement);
                            });
                    });
            })
            .map(ResponseEntity::ok)
            .defaultIfEmpty(ResponseEntity.notFound().build());
    }

    /**
     * SECURISE (CLIENT): Permet au CLIENT de confirmer (accepter) un chauffeur qui a postul√© √† son annonce.
     * Le statut de l'annonce passe √† "Ongoing" et une notification est envoy√©e au chauffeur.
     */
    @PostMapping("/{announcementId}/confirm")
    public Mono<ResponseEntity<Product>> confirmDriverForAnnouncement(
            @PathVariable UUID announcementId,
            @RequestParam UUID driverId, 
            @AuthenticationPrincipal Mono<Jwt> jwtMono,
            @RequestHeader("Authorization") String authorizationHeader) {

        return jwtMono
            .flatMap(jwt -> profileService.getUserSessionContext(JwtUtil.getUserIdFromToken(jwt), authorizationHeader, null))
            .flatMap(clientContext -> {
                if (clientContext.getClientProfile() == null) {
                    return Mono.error(new IllegalStateException("Seul un client peut confirmer un chauffeur pour son annonce."));
                }
                ClientProfile clientProfile = clientContext.getClientProfile();

                return productRepository.findAll().filter(p -> p.getId().equals(announcementId)).next()
                    .flatMap(announcement -> {
                        if (!announcement.getClientId().equals(clientProfile.getUserId())) {
                            return Mono.error(new SecurityException("Le client n'est pas l'auteur de cette annonce."));
                        }
                        if (!"PendingConfirmation".equalsIgnoreCase(announcement.getStatus()) || !announcement.getReservedByDriverId().equals(driverId)) {
                             return Mono.error(new IllegalStateException("Cette annonce n'est pas en attente de confirmation pour ce chauffeur, ou le statut est incorrect."));
                        }

                        ProductKey key = new ProductKey(announcement.getOrganizationId(), announcementId);
                        return productRepository.findById(key)
                            .flatMap(ann -> {
                                ann.setStatus("Ongoing");
                                log.info("Client {} a confirm√© le chauffeur {} pour l'annonce {}. Statut mis √† jour √† 'Ongoing'.", clientProfile.getUserId(), driverId, announcementId);
                                return productRepository.save(ann);
                            })
                            .flatMap(updatedAnnouncement -> 
                                profileService.findDriverById(driverId)
                                    .flatMap(driverProfile -> notificationTriggerService.notifyDriverOfConfirmedAnnouncement(updatedAnnouncement, driverProfile))
                                    .thenReturn(updatedAnnouncement)
                            );
                    });
            })
            .map(ResponseEntity::ok)
            .defaultIfEmpty(ResponseEntity.notFound().build());
    }

    /**
     * SECURISE (CONDUCTEUR): R√©cup√®re les courses que le conducteur connect√© a accept√©es.
     */
    @GetMapping("/my-rides")
    public Flux<Product> getMyAcceptedRides(@AuthenticationPrincipal Mono<Jwt> jwtMono,
                                            @RequestHeader("Authorization") String authorizationHeader) {
        return jwtMono
            .flatMap(jwt -> profileService.getUserSessionContext(JwtUtil.getUserIdFromToken(jwt), authorizationHeader, null))
            .flatMapMany(userContext -> {
                 if (userContext.getDriverProfile() == null) {
                     return Flux.error(new IllegalStateException("L'utilisateur n'est pas un chauffeur."));
                }
                UUID driverId = userContext.getUserId();
                log.info("R√©cup√©ration des courses accept√©es/postul√©es par le chauffeur {}", driverId);
                
                return productRepository.findByReservedByDriverId(driverId)
                           .flatMap(this::enrichProductWithAuthorDetails)
                           .doOnNext(product -> {
                               // Debugging log pour voir les produits enrichis avant de les envoyer
                               log.info("DEBUG_BACKEND_OFFERS: Produit complet enrichi envoy√© pour driver {}: Id='{}', Title='{}', AuthorName='{}', Cost={}, ReservedByDriverName='{}'", 
                                        driverId, product.getId(), product.getName(), product.getAuthorName(), product.getDefaultSellPrice(), product.getReservedByDriverName());
                           });
            });
    }


    /**
     * M√©thode priv√©e pour enrichir une annonce avec les d√©tails de son auteur (client).
     */
    private Mono<Product> enrichProductWithAuthorDetails(Product product) {
        UUID authorId = product.getClientId();
        if (authorId == null) {
            return Mono.just(product);
        }

        return profileService.findClientById(authorId)
            .map(clientProfile -> {
                product.setAuthorId(clientProfile.getUserId());
                product.setAuthorName(clientProfile.getFirstName() + " " + clientProfile.getLastName());
                product.setAuthorPhoneNumber(clientProfile.getPhoneNumber());
                product.setAuthorProfileImageUrl(clientProfile.getProfileImageUrl());
                return product;
            })
            .defaultIfEmpty(product); 
    }
}// END OF FILE: src/main/java/com/freelance/driver_backend/controller/AnnouncementController.java

//---> PATH: /home/mbogneng-junior/freelance-driver_Sylladb/backend/src/main/java/com/freelance/driver_backend/controller/AuthController.java

package com.freelance.driver_backend.controller;

import com.freelance.driver_backend.dto.external.LoginRequest;
import com.freelance.driver_backend.dto.external.NotificationRequest;
import com.freelance.driver_backend.dto.external.RegistrationRequest; // Garder cet import
import com.freelance.driver_backend.dto.onboarding.OnboardingResponse;
import com.freelance.driver_backend.model.OtpVerification; // Garder cet import
import com.freelance.driver_backend.repository.OtpVerificationRepository; // Garder cet import
import com.freelance.driver_backend.service.LoginService;
import com.freelance.driver_backend.service.external.AuthService; // Garder cet import
import com.freelance.driver_backend.service.external.NotificationService;
import io.github.cdimascio.dotenv.Dotenv;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Value; // Garder cet import
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;
import reactor.core.publisher.Mono;

import java.time.Instant;
import java.time.temporal.ChronoUnit;
import java.util.List;
import java.util.Map;
import java.util.Random;
import java.util.UUID;

@RestController
@RequestMapping("/api") // Le mapping doit √™tre "/api" pour que /api/register fonctionne
@RequiredArgsConstructor
@Slf4j
public class AuthController {

    private final LoginService loginService;
    private final OtpVerificationRepository otpVerificationRepository; // R√©activer l'injection
    private final NotificationService notificationService;
    private final Dotenv dotenv;
    private final AuthService authService; // R√©activer l'injection

    @Value("${freelancedriver.oauth2.client-id}")
    private String oauthClientId;
    @Value("${freelancedriver.oauth2.client-secret}")
    private String oauthClientSecret;


    @PostMapping("/auth/login") // La route de login reste sous /api/auth/login
    public Mono<ResponseEntity<OnboardingResponse>> login(@RequestBody LoginRequest loginRequest) {
        return loginService.loginAndGetContext(loginRequest)
                .doOnNext(response -> {
                    log.info("‚ñ∂Ô∏è Backend DEBUG: R√©ponse Login envoy√©e au frontend: {}", response);
                })
                .map(ResponseEntity::ok)
                .defaultIfEmpty(ResponseEntity.status(401).build());
    }

    /**
     * G√®re l'inscription initiale : enregistre l'utilisateur via l'API externe,
     * puis g√©n√®re et envoie l'OTP.
     * Cet endpoint est appel√© par `SignUp.tsx`.
     */
    /* @PostMapping("/register") // CETTE ROUTE DOIT √äTRE R√âACTIV√âE
    public Mono<ResponseEntity<Map<String, String>>> registerUserAndInitiateOtp(@RequestBody RegistrationRequest request) {
        String email = request.getEmail();
        String firstName = request.getFirstName();
        
        log.info("‚ñ∂Ô∏è D√©but du processus d'inscription (API externe) et OTP pour l'email: {}", email);
        
        // 1. Obtenir le token M2M (Machine-to-Machine)
        return authService.getClientCredentialsToken(oauthClientId, oauthClientSecret)
            .flatMap(m2mTokenResponse -> {
                String m2mBearerToken = "Bearer " + m2mTokenResponse.getAccessToken();

                // 2. Enregistrer l'utilisateur aupr√®s du service d'authentification externe r√©el
                return authService.registerUser(request, m2mBearerToken)
                    .flatMap(userDto -> {
                        log.info("‚úÖ Utilisateur '{}' enregistr√© avec succ√®s via l'API externe. ID: {}", userDto.getEmail(), userDto.getId());
                        
                        // 3. G√©n√©rer et sauvegarder l'OTP localement
                        String otp = String.format("%06d", new Random().nextInt(999999));
                        OtpVerification newVerification = new OtpVerification();
                        newVerification.setEmail(email);
                        newVerification.setOtpCode(otp);
                        newVerification.setExpiresAt(Instant.now().plus(10, ChronoUnit.MINUTES));
                        
                        return otpVerificationRepository.save(newVerification);
                    })
                    .flatMap(savedOtp -> {
                        log.info("‚úÖ OTP {} sauvegard√© localement pour {}", savedOtp.getOtpCode(), email);

                        // 4. Envoyer l'email OTP via le service de notification (mock ou r√©el, selon le profil)
                        UUID otpTemplateId = UUID.fromString(dotenv.get("TEMPLATE_EMAIL_OTP_ID"));
                        UUID tempOrgId = UUID.fromString(dotenv.get("SYSTEM_ORGANIZATION_ID"));

                        NotificationRequest otpRequest = NotificationRequest.builder()
                            .templateId(otpTemplateId)
                            .recipients(List.of(email))
                            .metadata(Map.of("firstName", firstName, "otpCode", savedOtp.getOtpCode()))
                            .build();
                        
                        return notificationService.sendEmailNotification(tempOrgId, otpRequest, null, null);
                    })
                    .map(success -> {
                        if (Boolean.TRUE.equals(success)) {
                            log.info("‚úÖ Email OTP envoy√© avec succ√®s √† {}", email);
                            return ResponseEntity.status(HttpStatus.CREATED).body(Map.of("message", "Utilisateur enregistr√©, OTP envoy√©."));
                        } else {
                            log.error("‚ùå √âchec de l'envoi de l'email OTP √† {}", email);
                            return ResponseEntity.status(HttpStatus.ACCEPTED).body(Map.of("message", "Utilisateur enregistr√©, mais l'email OTP n'a pas pu √™tre envoy√©."));
                        }
                    })
                    .onErrorResume(RuntimeException.class, e -> {
                        log.error("‚ùå Erreur lors de l'inscription ou de l'envoi de l'OTP pour {}: {}", email, e.getMessage());
                        return Mono.just(ResponseEntity.status(HttpStatus.BAD_REQUEST).body(Map.of("message", e.getMessage())));
                    });
            });
    } */

        @PostMapping("/register") // CETTE ROUTE DOIT √äTRE R√âACTIV√âE
    public Mono<ResponseEntity<Map<String, String>>> registerUserAndInitiateOtp(@RequestBody RegistrationRequest request) {
        String email = request.getEmail();
        String firstName = request.getFirstName();
        
        log.info("‚ñ∂Ô∏è D√©but du processus d'inscription (API externe) et OTP pour l'email: {}", email);
        
        // Le token M2M n'est plus requis pour l'enregistrement de l'utilisateur.
        // L'appel √† getClientCredentialsToken est donc supprim√© ici.
        String m2mBearerToken = "Bearer BQC5Zt6s9y$C&F)J@NcRfUjXn2r5u8x/";
        // 1. Enregistrer l'utilisateur aupr√®s du service d'authentification externe.
        return authService.registerUser(request,m2mBearerToken)
            .flatMap(userDto -> {
                log.info("‚úÖ Utilisateur '{}' enregistr√© avec succ√®s via l'API externe. ID: {}", userDto.getEmail(), userDto.getId());
                
                // 2. G√©n√©rer et sauvegarder l'OTP localement
                String otp = String.format("%06d", new Random().nextInt(999999));
                OtpVerification newVerification = new OtpVerification();
                newVerification.setEmail(email);
                newVerification.setOtpCode(otp);
                
                newVerification.setExpiresAt(Instant.now().plus(10, ChronoUnit.MINUTES));
                
                return otpVerificationRepository.save(newVerification);
            })
            .flatMap(savedOtp -> {
                log.info("‚úÖ OTP {} sauvegard√© localement pour {}", savedOtp.getOtpCode(), email);

                // 3. Envoyer l'email OTP via le service de notification
                UUID otpTemplateId = UUID.fromString(dotenv.get("TEMPLATE_EMAIL_OTP_ID"));
                UUID tempOrgId = UUID.fromString(dotenv.get("SYSTEM_ORGANIZATION_ID"));

                NotificationRequest otpRequest = NotificationRequest.builder()
                    .templateId(otpTemplateId)
                    .recipients(List.of(email))
                    .metadata(Map.of("firstName", firstName, "otpCode", savedOtp.getOtpCode()))
                    .build();
                
                // Note: L'envoi de notification pourrait n√©cessiter un token M2M.
                // Si c'est le cas, l'appel √† getClientCredentialsToken devrait √™tre replac√© ici.
                return notificationService.sendEmailNotification(tempOrgId, otpRequest, null, null);
            })
            .map(success -> {
                if (Boolean.TRUE.equals(success)) {
                    log.info("‚úÖ Email OTP envoy√© avec succ√®s √† {}", email);
                    return ResponseEntity.status(HttpStatus.CREATED).body(Map.of("message", "Utilisateur enregistr√©, OTP envoy√©."));
                } else {
                    log.error("‚ùå √âchec de l'envoi de l'email OTP √† {}", email);
                    return ResponseEntity.status(HttpStatus.ACCEPTED).body(Map.of("message", "Utilisateur enregistr√©, mais l'email OTP n'a pas pu √™tre envoy√©."));
                }
            })
            .onErrorResume(RuntimeException.class, e -> {
                log.error("‚ùå Erreur lors de l'inscription ou de l'envoi de l'OTP pour {}: {}", email, e.getMessage());
                return Mono.just(ResponseEntity.status(HttpStatus.BAD_REQUEST).body(Map.of("message", e.getMessage())));
            });
    }
}// END OF FILE: src/main/java/com/freelance/driver_backend/controller/AuthController.java

//---> PATH: /home/mbogneng-junior/freelance-driver_Sylladb/backend/src/main/java/com/freelance/driver_backend/controller/DriverSearchController.java



// PATH: /home/mbogneng-junior/freelance-driver (Copie)/backend/src/main/java/com/freelance/driver_backend/controller/DriverSearchController.java

package com.freelance.driver_backend.controller;

import com.freelance.driver_backend.model.Resource;
import com.freelance.driver_backend.service.resource.ResourceService;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;
import reactor.core.publisher.Flux;

@RestController
@RequestMapping("/api/search")
@RequiredArgsConstructor
@Slf4j
public class DriverSearchController {

    private final ResourceService resourceService;
    private static final String PLANNING_CATEGORY_ID = "ba75b2c0-30a8-11f0-a5b5-bb7d33c83c13";

    @GetMapping("/drivers")
    public Flux<Resource> findAvailableDrivers() {
        log.info("-> Requ√™te PUBLIQUE re√ßue pour GET /api/search/drivers");
        return resourceService.getResourcesByCategory(PLANNING_CATEGORY_ID)
                .filter(resource -> "AVAILABLE".equalsIgnoreCase(resource.getState()))
                .doOnNext(resource -> log.info("--> Planning publi√© trouv√© : {}", resource.getName()));
    }
}// END OF FILE: src/main/java/com/freelance/driver_backend/controller/DriverSearchController.java

//---> PATH: /home/mbogneng-junior/freelance-driver_Sylladb/backend/src/main/java/com/freelance/driver_backend/controller/ExperienceController.java


// PATH: /home/mbogneng-junior/freelance-driver (Copie)/backend/src/main/java/com/freelance/driver_backend/controller/ExperienceController.java

package com.freelance.driver_backend.controller;

import com.freelance.driver_backend.dto.CreateProductRequest; // Ajout√© pour les m√©thodes POST/PUT
import com.freelance.driver_backend.dto.UserSessionContextDto; // Nouveau import
import com.freelance.driver_backend.model.DriverProfile; // Nouveau import
import com.freelance.driver_backend.model.Product;
import com.freelance.driver_backend.service.ProfileService;
import com.freelance.driver_backend.service.ResourceService;
import com.freelance.driver_backend.util.JwtUtil; // Ajout√© pour les m√©thodes POST/PUT
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.http.HttpStatus; // Ajout√© pour les ResponseEntity
import org.springframework.http.ResponseEntity; // Ajout√© pour les ResponseEntity
import org.springframework.security.core.annotation.AuthenticationPrincipal; // Ajout√© pour les m√©thodes POST/PUT
import org.springframework.security.oauth2.jwt.Jwt; // Ajout√© pour les m√©thodes POST/PUT
import org.springframework.web.bind.annotation.*;
import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;

import java.util.Optional;
import java.util.UUID;

@RestController
@RequestMapping("/api/experiences")
@RequiredArgsConstructor
@Slf4j
public class ExperienceController {

    private final ProfileService profileService;
    private final ResourceService resourceService;

    // UUID fixe pour la cat√©gorie "exp√©riences"
    private static final UUID EXPERIENCE_CATEGORY_ID = UUID.fromString("e1f2a3b4-c5d6-7890-1234-567890abcdef");
    private static final UUID DRIVER_LICENSE_CATEGORY_ID = UUID.fromString("f1c2b3d4-e5f6-7890-1234-567890abcdef"); // Du frontend
    private static final UUID CV_CATEGORY_ID = UUID.fromString("a1b2c3d4-e5f6-7890-1234-567890fedcba"); // Du frontend


    /**
     * PUBLIC: R√©cup√®re les exp√©riences d'un utilisateur sp√©cifique par son ID.
     */
    @GetMapping("/user/{userId}")
    public Flux<Product> getExperiencesForUser(
            @PathVariable UUID userId,
            @RequestHeader(value = "Authorization", required = false) String authorizationHeader
    ) {
        log.info("‚ñ∂Ô∏è [ExperienceController] R√©cup√©ration des exp√©riences pour l'utilisateur ID: {}", userId);

        String token = Optional.ofNullable(authorizationHeader).orElse(null);

        // MODIFI√â : R√©cup√®re l'organisation ID du userId sp√©cifi√©.
        // Puis, filtre les produits de cette organisation qui appartiennent √† ce userId.
        return profileService.findOrganisationIdByUserId(userId)
                .flatMapMany(orgId -> resourceService.getProductsByCategory(orgId, EXPERIENCE_CATEGORY_ID, token, null)
                                                    .filter(product -> userId.equals(product.getClientId())));
    }
    
    /**
     * SECURISE (CONDUCTEUR): Cr√©e une nouvelle exp√©rience/document pour le chauffeur connect√©.
     */
    @PostMapping
    public Mono<ResponseEntity<Product>> createExperienceOrDocument(
            @RequestBody CreateProductRequest request,
            @AuthenticationPrincipal Mono<Jwt> jwtMono,
            @RequestHeader("Authorization") String authorizationHeader) {

        return jwtMono
            .flatMap(jwt -> profileService.getUserSessionContext(JwtUtil.getUserIdFromToken(jwt), authorizationHeader, null))
            .flatMap(userContext -> {
                if (userContext.getDriverProfile() == null) {
                    return Mono.error(new IllegalStateException("Seuls les chauffeurs peuvent g√©rer leurs exp√©riences/documents."));
                }
                if (userContext.getOrganisation() == null || userContext.getOrganisation().getOrganizationId() == null) {
                    return Mono.error(new IllegalStateException("Contexte utilisateur invalide (organisation manquante)."));
                }
                DriverProfile driverProfile = userContext.getDriverProfile();

                // Assurez-vous que la cat√©gorie est d√©finie dans la requ√™te.
                if (request.getCategoryId() == null ||
                    (!request.getCategoryId().equals(EXPERIENCE_CATEGORY_ID) &&
                     !request.getCategoryId().equals(DRIVER_LICENSE_CATEGORY_ID) &&
                     !request.getCategoryId().equals(CV_CATEGORY_ID))) {
                    return Mono.error(new IllegalArgumentException("Cat√©gorie d'exp√©rience/document invalide ou manquante."));
                }

                request.setClientId(driverProfile.getUserId()); // L'ID du chauffeur est le propri√©taire
                request.setClientName(driverProfile.getFirstName() + " " + driverProfile.getLastName());
                request.setClientPhoneNumber(driverProfile.getPhoneNumber());
                request.setClientProfileImageUrl(driverProfile.getProfileImageUrl());
                
                log.info("‚ñ∂Ô∏è Controller: Cr√©ation d'une exp√©rience/document (cat√©gorie: {}) pour le chauffeur {}", request.getCategoryId(), driverProfile.getUserId());
                
                return resourceService.createProduct(
                    userContext.getOrganisation().getOrganizationId(), 
                    request, 
                    authorizationHeader, 
                    null
                );
            })
            .map(createdProduct -> new ResponseEntity<>(createdProduct, HttpStatus.CREATED));
    }

    /**
     * SECURISE (CONDUCTEUR): Met √† jour une exp√©rience/document existant.
     */
    @PutMapping("/{productId}")
    public Mono<ResponseEntity<Product>> updateExperienceOrDocument(
            @PathVariable UUID productId,
            @RequestBody CreateProductRequest request,
            @AuthenticationPrincipal Mono<Jwt> jwtMono,
            @RequestHeader("Authorization") String authorizationHeader) {
        
        return jwtMono
            .flatMap(jwt -> profileService.getUserSessionContext(JwtUtil.getUserIdFromToken(jwt), authorizationHeader, null))
            .flatMap(userContext -> {
                if (userContext.getDriverProfile() == null) {
                    return Mono.error(new IllegalStateException("Seuls les chauffeurs peuvent modifier leurs exp√©riences/documents."));
                }
                if (userContext.getOrganisation() == null || userContext.getOrganisation().getOrganizationId() == null) {
                    return Mono.error(new IllegalStateException("Contexte utilisateur invalide (organisation manquante)."));
                }
                DriverProfile driverProfile = userContext.getDriverProfile();

                 // Assurez-vous que la cat√©gorie est d√©finie dans la requ√™te.
                if (request.getCategoryId() == null ||
                    (!request.getCategoryId().equals(EXPERIENCE_CATEGORY_ID) &&
                     !request.getCategoryId().equals(DRIVER_LICENSE_CATEGORY_ID) &&
                     !request.getCategoryId().equals(CV_CATEGORY_ID))) {
                    return Mono.error(new IllegalArgumentException("Cat√©gorie d'exp√©rience/document invalide ou manquante."));
                }
                
                // V√©rification cruciale : l'utilisateur connect√© est-il le propri√©taire ?
                return resourceService.getProductsByCategory(userContext.getOrganisation().getOrganizationId(), request.getCategoryId(), authorizationHeader, null)
                        .filter(product -> product.getId().equals(productId) && driverProfile.getUserId().equals(product.getClientId()))
                        .next()
                        .switchIfEmpty(Mono.error(new SecurityException("Le chauffeur n'est pas autoris√© √† modifier cet √©l√©ment ou il n'existe pas.")))
                        .flatMap(existingProduct -> {
                            request.setClientId(driverProfile.getUserId()); // Assure que le propri√©taire reste le m√™me
                            request.setClientName(driverProfile.getFirstName() + " " + driverProfile.getLastName());
                            request.setClientPhoneNumber(driverProfile.getPhoneNumber());
                            request.setClientProfileImageUrl(driverProfile.getProfileImageUrl());

                            log.info("‚ñ∂Ô∏è Controller: Mise √† jour de l'exp√©rience/document ID: {}", productId);
                            
                            return resourceService.updateProduct(
                                userContext.getOrganisation().getOrganizationId(), 
                                productId,
                                request, 
                                authorizationHeader, 
                                null
                            );
                        });
            })
            .map(ResponseEntity::ok)
            .defaultIfEmpty(ResponseEntity.notFound().build());
    }

    /**
     * SECURISE (CONDUCTEUR): Supprime une exp√©rience/document existant.
     */
    @DeleteMapping("/{productId}")
    public Mono<ResponseEntity<Void>> deleteExperienceOrDocument(
            @PathVariable UUID productId,
            @AuthenticationPrincipal Mono<Jwt> jwtMono,
            @RequestHeader("Authorization") String authorizationHeader) {

        return jwtMono
            .flatMap(jwt -> profileService.getUserSessionContext(JwtUtil.getUserIdFromToken(jwt), authorizationHeader, null))
            .flatMap(userContext -> {
                if (userContext.getDriverProfile() == null) {
                    return Mono.error(new IllegalStateException("Seuls les chauffeurs peuvent supprimer leurs exp√©riences/documents."));
                }
                if (userContext.getOrganisation() == null || userContext.getOrganisation().getOrganizationId() == null) {
                    return Mono.error(new IllegalStateException("Contexte utilisateur invalide (organisation manquante)."));
                }
                DriverProfile driverProfile = userContext.getDriverProfile();

                // On ne peut pas facilement r√©cup√©rer la cat√©gorie ici sans re-fetch.
                // Une meilleure approche serait d'inclure la categoryId dans le path ou comme query param pour DELETE.
                // Pour l'instant, on fait un fetch large puis filtre. C'est moins performant.
                return resourceService.getProductsByCategory(userContext.getOrganisation().getOrganizationId(), EXPERIENCE_CATEGORY_ID, authorizationHeader, null)
                        .filter(product -> product.getId().equals(productId) && driverProfile.getUserId().equals(product.getClientId()))
                        .next()
                        .switchIfEmpty(Mono.error(new SecurityException("Le chauffeur n'est pas autoris√© √† supprimer cet √©l√©ment ou il n'existe pas.")))
                        .flatMap(existingProduct -> {
                            log.info("‚ñ∂Ô∏è Controller: Suppression de l'exp√©rience/document ID: {}", productId);
                            return resourceService.deleteProduct(
                                userContext.getOrganisation().getOrganizationId(), 
                                productId,
                                authorizationHeader, 
                                null
                            );
                        });
            })
            .then(Mono.just(new ResponseEntity<Void>(HttpStatus.NO_CONTENT)));
    }
}// END OF FILE: src/main/java/com/freelance/driver_backend/controller/ExperienceController.java

//---> PATH: /home/mbogneng-junior/freelance-driver_Sylladb/backend/src/main/java/com/freelance/driver_backend/controller/MediaController.java

package com.freelance.driver_backend.controller;

import com.freelance.driver_backend.dto.external.UploadMediaResponse;
import com.freelance.driver_backend.service.StorageService;
import com.freelance.driver_backend.util.JwtUtil;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
// Retirer cet import car publicKey n'est plus directement utilis√© ici
// import org.springframework.beans.factory.annotation.Value; 
import org.springframework.http.MediaType;
import org.springframework.http.ResponseEntity;
import org.springframework.http.codec.multipart.FilePart;
import org.springframework.security.core.annotation.AuthenticationPrincipal;
import org.springframework.security.oauth2.jwt.Jwt;
import org.springframework.web.bind.annotation.*;
import reactor.core.publisher.Mono;

import java.util.Map;
import java.util.UUID;

@RestController
@RequestMapping("/api/media")
@RequiredArgsConstructor
@Slf4j
public class MediaController {

    private final StorageService storageService;

    // Retirer ceci si ce n'est plus utilis√© nulle part dans le contr√¥leur
    // @Value("${freelancedriver.api.public-key}")
    // private String publicKey;

    @PostMapping(value = "/upload", consumes = MediaType.MULTIPART_FORM_DATA_VALUE)
    public Mono<ResponseEntity<Map<String, String>>> uploadFile(
            @AuthenticationPrincipal Mono<Jwt> jwtMono,
            @RequestHeader("Authorization") String authorizationHeader, // Nous avons toujours besoin de cet en-t√™te pour le contr√¥leur lui-m√™me pour v√©rifier l'utilisateur.
            @RequestPart("file") Mono<FilePart> filePartMono,
            @RequestParam("type") String frontendType,
            @RequestParam("resourceId") String resourceId) {

        return Mono.zip(jwtMono, filePartMono)
            .flatMap(tuple -> {
                Jwt jwt = tuple.getT1();
                FilePart filePart = tuple.getT2();
                UUID userId = JwtUtil.getUserIdFromToken(jwt);
                UUID targetResourceId = UUID.fromString(resourceId);

                log.info("‚ñ∂Ô∏è T√©l√©versement d'un fichier de type logique '{}' pour la ressource '{}' par l'utilisateur '{}'", frontendType, resourceId, userId);

                // Le StorageService s'occupera d'obtenir son propre token M2M
                return storageService.saveFile(
                    "product",
                    frontendType,
                    userId,
                    targetResourceId,
                    filePart.filename(),
                    filePart
                )
                .map(uploadResponse -> {
                    log.info("‚úÖ Fichier t√©l√©vers√© avec succ√®s. URL: {}, URI: {}", uploadResponse.getUrl(), uploadResponse.getUri());
                    return ResponseEntity.ok(Map.of("url", uploadResponse.getUrl(), "uri", uploadResponse.getUri()));
                });
            });
    }
}// END OF FILE: src/main/java/com/freelance/driver_backend/controller/MediaController.java

//---> PATH: /home/mbogneng-junior/freelance-driver_Sylladb/backend/src/main/java/com/freelance/driver_backend/controller/MockProductController.java

package com.freelance.driver_backend.controller;

import com.freelance.driver_backend.dto.CreateProductRequest;
import com.freelance.driver_backend.model.Product;
import com.freelance.driver_backend.model.ProductKey;
import com.freelance.driver_backend.repository.ProductRepository;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.context.annotation.Profile;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;
import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;

import java.util.UUID;

@RestController
@RequestMapping("/api/mock-products/{organizationId}")
@RequiredArgsConstructor
@Slf4j

public class MockProductController {

    private final ProductRepository productRepository;

    /**
     * Cr√©e un nouveau "produit" (annonce, v√©hicule, adresse, etc.).
     */
    @PostMapping
    public Mono<ResponseEntity<Product>> createProduct(
            @PathVariable UUID organizationId,
            @RequestBody CreateProductRequest request) {

        log.warn("[MOCK-CONTROLLER] Cr√©ation d'un produit pour l'organisation {}. Request re√ßue: {}", organizationId,
                request);
        // AJOUT : Inclure l'ID de la requ√™te dans les logs pour le diagnostic
        log.warn("[MOCK-CONTROLLER] Request details: clientId={}, categoryId={}, name={}, requestedId={}",
                request.getClientId(), request.getCategoryId(), request.getName(), request.getId());

        Product newProduct = new Product();
        ProductKey key;

        // --- CORRECTION : Utiliser l'ID fourni par le frontend si pr√©sent ---
        if (request.getId() != null && !request.getId().isEmpty()) {
            try {
                // Tenter de convertir l'ID fourni en UUID
                key = new ProductKey(organizationId, UUID.fromString(request.getId()));
                log.warn("[MOCK-CONTROLLER] Cr√©ation de produit avec ID fourni par le frontend: {}", request.getId());
            } catch (IllegalArgumentException e) {
                // Si l'ID fourni n'est pas un UUID valide, rejeter la requ√™te
                log.error("[MOCK-CONTROLLER] ID de produit fourni invalide par le frontend: {}", request.getId(), e);
                return Mono.error(new IllegalArgumentException("L'ID de produit fourni par le frontend est invalide."));
            }
        } else {
            // Si aucun ID n'est fourni, g√©n√©rer un nouvel UUID
            key = new ProductKey(organizationId, UUID.randomUUID());
            log.warn("[MOCK-CONTROLLER] Cr√©ation de produit avec ID g√©n√©r√© (aucun fourni): {}", key.getId());
        }
        newProduct.setKey(key);

        // On utilise la m√©thode centralis√©e pour remplir l'objet
        updateProductFromRequest(newProduct, request);

        log.warn(
                "[MOCK-CONTROLLER] Objet Product construit avant sauvegarde: ID={}, OrgID={}, ClientID={}, CatID={}, Nom='{}'",
                newProduct.getId(), newProduct.getOrganizationId(), newProduct.getClientId(),
                newProduct.getCategoryId(), newProduct.getName());

        return productRepository.save(newProduct)
                .map(savedProduct -> {
                    log.warn(
                            "[MOCK-CONTROLLER] Produit sauvegard√© avec succ√®s. ID: {}, OrgID: {}, ClientID: {}, CatID: {}, Nom: '{}', Statut: '{}'",
                            savedProduct.getId(), savedProduct.getOrganizationId(), savedProduct.getClientId(),
                            savedProduct.getCategoryId(), savedProduct.getName(), savedProduct.getStatus());
                    return new ResponseEntity<>(savedProduct, HttpStatus.CREATED);
                });
    }

    /**
     * R√©cup√®re les "produits" d'une organisation, filtr√©s par cat√©gorie.
     */
    @GetMapping
    public Flux<Product> getProductsByCategory(
            @PathVariable UUID organizationId,
            @RequestParam UUID categoryId) {
        log.warn("[MOCK-CONTROLLER] R√©cup√©ration des produits pour org {} et cat√©gorie {}", organizationId, categoryId);
        return productRepository.findByKeyOrganizationIdAndCategoryId(organizationId, categoryId);
    }

    /**
     * Met √† jour un "produit" existant.
     */
    @PutMapping("/{productId}")
    public Mono<ResponseEntity<Product>> updateProduct(
            @PathVariable UUID organizationId,
            @PathVariable UUID productId,
            @RequestBody CreateProductRequest request) {

        ProductKey key = new ProductKey(organizationId, productId);
        log.warn("[MOCK-CONTROLLER] Mise √† jour du produit avec la cl√© {}. Donn√©es re√ßues : {}", key, request);

        return productRepository.findById(key)
                .flatMap(existingProduct -> {
                    log.info("Produit existant trouv√© : {}", existingProduct);
                    updateProductFromRequest(existingProduct, request);
                    log.info("Produit apr√®s mise √† jour (avant sauvegarde) : {}", existingProduct);
                    return productRepository.save(existingProduct);
                })
                .map(savedProduct -> {
                    log.info("Produit sauvegard√© avec succ√®s : {}", savedProduct);
                    return ResponseEntity.ok(savedProduct);
                })
                .defaultIfEmpty(ResponseEntity.notFound().build());
    }

    /**
     * Supprime un "produit".
     */
    @DeleteMapping("/{productId}")
    public Mono<ResponseEntity<Void>> deleteProduct(
            @PathVariable UUID organizationId,
            @PathVariable UUID productId) {

        ProductKey key = new ProductKey(organizationId, productId);
        log.warn("[MOCK-CONTROLLER] Suppression du produit avec la cl√© {}", key);

        return productRepository.deleteById(key)
                .then(Mono.just(new ResponseEntity<Void>(HttpStatus.NO_CONTENT)));
    }

    /**
     * M√©thode utilitaire priv√©e pour mapper les champs d'une CreateProductRequest
     * vers un objet Product. Centralise la logique pour √©viter la r√©p√©tition
     * entre les m√©thodes createProduct et updateProduct.
     */
    private void updateProductFromRequest(Product product, CreateProductRequest request) {
        product.setName(request.getName());
        product.setDefaultSellPrice(request.getDefaultSellPrice());
        product.setShortDescription(request.getShortDescription());

        if (request.getCategoryId() != null) {
            product.setCategoryId(request.getCategoryId());
        }

        product.setIsActive(request.getIsActive());
        product.setPickupLocation(request.getPickupLocation());
        product.setDropoffLocation(request.getDropoffLocation());
        product.setStartDate(request.getStartDate());
        product.setStartTime(request.getStartTime());
        product.setEndDate(request.getEndDate());
        product.setEndTime(request.getEndTime());
        product.setIsNegotiable(request.isNegotiable());
        product.setPaymentMethod(request.getPaymentMethod());
        product.setClientId(request.getClientId());
        product.setClientName(request.getClientName());
        product.setStatus(request.getStatus());
        product.setClientPhoneNumber(request.getClientPhoneNumber());
        product.setClientProfileImageUrl(request.getClientProfileImageUrl());
        product.setBaggageInfo(request.getBaggageInfo());
        product.setMetadata(request.getMetadata());
        // L'ID ne peut pas √™tre mis √† jour directement ici car il fait partie de la cl√©
        // primaire.
        // Il est g√©r√© par la logique `key = new ProductKey(...)` plus haut.
    }
}// END OF FILE: src/main/java/com/freelance/driver_backend/controller/MockProductController.java

//---> PATH: /home/mbogneng-junior/freelance-driver_Sylladb/backend/src/main/java/com/freelance/driver_backend/controller/MockUserController.java

package com.freelance.driver_backend.controller;

import com.freelance.driver_backend.dto.external.*;
import com.freelance.driver_backend.service.MockUserService;
import lombok.RequiredArgsConstructor;
import org.springframework.http.HttpStatus;
import org.springframework.web.bind.annotation.*;
import reactor.core.publisher.Mono;

@RestController
@RequestMapping("/api/mock_user")
@RequiredArgsConstructor
@CrossOrigin(origins = "*")
public class MockUserController {

    private final MockUserService mockUserService;

    @PostMapping("/register")
    @ResponseStatus(HttpStatus.CREATED)
    public Mono<UserDto> register(@RequestBody  RegistrationRequest request) {
        return mockUserService.register(request);
    }

    @PostMapping("/login")
    public Mono<LoginResponse> login(@RequestBody LoginRequest request) {
        return mockUserService.login(request);
    }
}// END OF FILE: src/main/java/com/freelance/driver_backend/controller/MockUserController.java

//---> PATH: /home/mbogneng-junior/freelance-driver_Sylladb/backend/src/main/java/com/freelance/driver_backend/controller/NotificationConfigController.java

// Dans src/main/java/com/freelance/driver_backend/controller/NotificationConfigController.java

package com.freelance.driver_backend.controller;

import java.util.UUID;

import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import com.freelance.driver_backend.dto.external.NotificationRequest;
import com.freelance.driver_backend.model.DesignTemplate;
import com.freelance.driver_backend.model.EmailTemplate;
import com.freelance.driver_backend.model.FirebaseSetting;
import com.freelance.driver_backend.model.PushTemplate;
import com.freelance.driver_backend.model.SmtpSetting;
import com.freelance.driver_backend.repository.DesignTemplateRepository;
import com.freelance.driver_backend.repository.EmailTemplateRepository;
import com.freelance.driver_backend.repository.FirebaseSettingRepository;
import com.freelance.driver_backend.repository.PushTemplateRepository;
import com.freelance.driver_backend.repository.SmtpSettingRepository;
import com.freelance.driver_backend.service.external.NotificationService;

import lombok.RequiredArgsConstructor;
import reactor.core.publisher.Mono;

@RestController
@RequestMapping("/api/mock-notifications/{organizationId}")
@RequiredArgsConstructor
public class NotificationConfigController {

    private final SmtpSettingRepository smtpSettingRepository;
    private final DesignTemplateRepository designTemplateRepository;
    private final EmailTemplateRepository emailTemplateRepository;
    private final NotificationService notificationService;
    private final FirebaseSettingRepository firebaseSettingRepository;
    private final PushTemplateRepository pushTemplateRepository;

    @PostMapping("/smtp-settings")
    public Mono<SmtpSetting> createSmtpSetting(@PathVariable UUID organizationId, @RequestBody SmtpSetting setting) {
        // Utilise l'ID fourni par le client, ou g√©n√®re-en un si aucun n'est fourni
        if (setting.getId() == null) {
            setting.setId(UUID.randomUUID());
        }
        setting.setOrganizationId(organizationId);
        return smtpSettingRepository.save(setting);
    }

    @PostMapping("/design-templates")
    public Mono<DesignTemplate> createDesignTemplate(@PathVariable UUID organizationId, @RequestBody DesignTemplate template) {
        // Utilise l'ID fourni par le client, ou g√©n√®re-en un si aucun n'est fourni
        if (template.getId() == null) {
            template.setId(UUID.randomUUID());
        }
        template.setOrganizationId(organizationId);
        return designTemplateRepository.save(template);
    }

    @PostMapping("/email-templates")
    public Mono<EmailTemplate> createEmailTemplate(@PathVariable UUID organizationId, @RequestBody EmailTemplate template) {
        // Utilise l'ID fourni par le client, ou g√©n√®re-en un si aucun n'est fourni
        if (template.getId() == null) {
            template.setId(UUID.randomUUID());
        }
        template.setOrganizationId(organizationId);
        return emailTemplateRepository.save(template);
    }

     @PostMapping("/send-test-email")
    public Mono<ResponseEntity<String>> sendTestEmail(
            @PathVariable UUID organizationId,
            @RequestBody NotificationRequest request) {
        
        // Nous n'avons pas besoin du token ou de la cl√© publique ici car c'est un test local
        // qui appelle notre service "mock".
        return notificationService.sendEmailNotification(organizationId, request, "mock-token", "mock-key")
            .map(success -> {
                if (Boolean.TRUE.equals(success)) {
                    return ResponseEntity.ok("Test email sent successfully!");
                } else {
                    return ResponseEntity.status(500).body("Failed to send test email.");
                }
            })
            .onErrorResume(e -> Mono.just(ResponseEntity.status(500).body("Error: " + e.getMessage())));
    }


    @PostMapping("/firebase-settings")
    public Mono<FirebaseSetting> createFirebaseSetting(@PathVariable UUID organizationId, @RequestBody FirebaseSetting setting) {
        // Utilise l'ID fourni par le client, ou g√©n√®re-en un si aucun n'est fourni
        if (setting.getId() == null) {
            setting.setId(UUID.randomUUID());
        }
        setting.setOrganizationId(organizationId);
        return firebaseSettingRepository.save(setting);
    }

    @PostMapping("/push-templates")
    public Mono<PushTemplate> createPushTemplate(@PathVariable UUID organizationId, @RequestBody PushTemplate template) {
        // Utilise l'ID fourni par le client, ou g√©n√®re-en un si aucun n'est fourni
        if (template.getId() == null) {
            template.setId(UUID.randomUUID());
        }
        template.setOrganizationId(organizationId);
        return pushTemplateRepository.save(template);
    }
    
}// END OF FILE: src/main/java/com/freelance/driver_backend/controller/NotificationConfigController.java

//---> PATH: /home/mbogneng-junior/freelance-driver_Sylladb/backend/src/main/java/com/freelance/driver_backend/controller/NotificationController.java

package com.freelance.driver_backend.controller;

import com.freelance.driver_backend.model.DeviceToken;
import com.freelance.driver_backend.repository.DeviceTokenRepository;
import com.freelance.driver_backend.util.JwtUtil;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.core.annotation.AuthenticationPrincipal;
import org.springframework.security.oauth2.jwt.Jwt;
import org.springframework.web.bind.annotation.*;
import reactor.core.publisher.Mono;

import java.util.Map;

@RestController
@RequestMapping("/api/notifications")
@RequiredArgsConstructor
@Slf4j
public class NotificationController {

    private final DeviceTokenRepository deviceTokenRepository;

    @PostMapping("/register-device")
    public Mono<ResponseEntity<Void>> registerDevice(
            @AuthenticationPrincipal Mono<Jwt> jwtMono,
            @RequestBody Map<String, String> payload) {
        
        String token = payload.get("token");
        if (token == null || token.isBlank()) {
            return Mono.just(ResponseEntity.badRequest().build());
        }

        return jwtMono.flatMap(jwt -> {
            DeviceToken deviceToken = new DeviceToken();
            deviceToken.setUserId(JwtUtil.getUserIdFromToken(jwt));
            deviceToken.setToken(token);
            
            log.info("Enregistrement du token de l'appareil pour l'utilisateur {}", deviceToken.getUserId());
            
            return deviceTokenRepository.save(deviceToken)
                .thenReturn(new ResponseEntity<Void>(HttpStatus.CREATED));
        });
    }
}// END OF FILE: src/main/java/com/freelance/driver_backend/controller/NotificationController.java

//---> PATH: /home/mbogneng-junior/freelance-driver_Sylladb/backend/src/main/java/com/freelance/driver_backend/controller/OnboardingController.java

package com.freelance.driver_backend.controller;

import com.freelance.driver_backend.dto.onboarding.ClientOnboardingRequest;
import com.freelance.driver_backend.dto.onboarding.DriverOnboardingRequest;

import com.freelance.driver_backend.service.OnboardingService;
import lombok.extern.slf4j.Slf4j;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;
import reactor.core.publisher.Mono;
import com.freelance.driver_backend.dto.onboarding.OnboardingResponse;

@RestController
@RequestMapping("/api/onboarding")
@Slf4j
public class OnboardingController {

    private final OnboardingService onboardingService;

    public OnboardingController(OnboardingService onboardingService) {
        this.onboardingService = onboardingService;
    }

    @PostMapping("/driver")
    public Mono<ResponseEntity<OnboardingResponse>> onboardDriver(@RequestBody DriverOnboardingRequest request) {
        return onboardingService.createDriverAccount(request)
                .doOnNext(response -> { // AJOUT DU LOG ICI
                    log.info("‚ñ∂Ô∏è Backend DEBUG: R√©ponse Onboarding (DRIVER) envoy√©e au frontend: {}", response);
                })
                .map(response -> new ResponseEntity<>(response, HttpStatus.CREATED));
    }

    @PostMapping("/client")
    public Mono<ResponseEntity<OnboardingResponse>> onboardClient(@RequestBody ClientOnboardingRequest request) {
        return onboardingService.createClientAccount(request)
                .doOnNext(response -> { // AJOUT DU LOG ICI
                    log.info("‚ñ∂Ô∏è Backend DEBUG: R√©ponse Onboarding (CLIENT) envoy√©e au frontend: {}", response);
                })
                .map(response -> new ResponseEntity<>(response, HttpStatus.CREATED));
    }
}// END OF FILE: src/main/java/com/freelance/driver_backend/controller/OnboardingController.java

//---> PATH: /home/mbogneng-junior/freelance-driver_Sylladb/backend/src/main/java/com/freelance/driver_backend/controller/PlanningController.java


package com.freelance.driver_backend.controller;

import com.corundumstudio.socketio.SocketIOServer;
import com.freelance.driver_backend.dto.CreateProductRequest;
import com.freelance.driver_backend.dto.UserSessionContextDto;
import com.freelance.driver_backend.model.ClientProfile;
import com.freelance.driver_backend.model.DriverProfile;
import com.freelance.driver_backend.model.Product;
import com.freelance.driver_backend.model.ProductKey;
import com.freelance.driver_backend.repository.ProductRepository;
import com.freelance.driver_backend.service.NotificationTriggerService;
import com.freelance.driver_backend.service.ProfileService;
import com.freelance.driver_backend.service.ResourceService;
import com.freelance.driver_backend.util.JwtUtil;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.core.annotation.AuthenticationPrincipal;
import org.springframework.security.oauth2.jwt.Jwt;
import org.springframework.web.bind.annotation.*;
import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;
import java.util.UUID;

@RestController
@RequestMapping("/api/planning")
@RequiredArgsConstructor
@Slf4j
public class PlanningController {

    private final ResourceService resourceService;
    private final ProfileService profileService;
    private final ProductRepository productRepository;
    private final NotificationTriggerService notificationTriggerService;
    private final SocketIOServer socketIOServer;

    private static final UUID PLANNING_CATEGORY_ID = UUID.fromString("ba75b2c0-30a8-11f0-a5b5-bb7d33c83c13");

    /**
     * PUBLIC: R√©cup√®re tous les plannings publi√©s par les chauffeurs.
     */
    @GetMapping("/published")
    public Flux<Product> getPublishedPlannings() {
        log.info("Controller: Requ√™te publique pour r√©cup√©rer les plannings publi√©s.");
        return productRepository.findByCategoryId(PLANNING_CATEGORY_ID)
                .filter(product -> "Published".equalsIgnoreCase(product.getStatus())) // Seuls les plannings "Published"
                .flatMap(this::enrichProductWithAuthorDetails);
    }

    /**
     * PUBLIC: R√©cup√®re les plannings publi√©s d'un chauffeur sp√©cifique.
     */
    @GetMapping("/user/{userId}")
    public Flux<Product> getPlanningsForUser(@PathVariable UUID userId) {
        log.info("R√©cup√©ration des plannings publi√©s pour le chauffeur ID: {}", userId);
        return productRepository.findByClientIdAndCategoryId(userId, PLANNING_CATEGORY_ID)
                .filter(product -> "Published".equalsIgnoreCase(product.getStatus()))
                .flatMap(this::enrichProductWithAuthorDetails);
    }

    /**
     * SECURISE (CONDUCTEUR): R√©cup√®re les plannings du conducteur actuellement connect√©.
     * Inclut aussi ceux en attente de confirmation ou confirm√©s.
     */
    @GetMapping
    public Flux<Product> getAllPlanningsForCurrentUser(@AuthenticationPrincipal Mono<Jwt> jwtMono,
                                                        @RequestHeader("Authorization") String authorizationHeader) {
        return jwtMono
            .flatMap(jwt -> profileService.getUserSessionContext(JwtUtil.getUserIdFromToken(jwt), authorizationHeader, null))
            .flatMapMany(userContext -> {
                if (userContext.getDriverProfile() == null) {
                     return Flux.error(new IllegalStateException("L'utilisateur n'est pas un chauffeur."));
                }
                // R√©cup√®re tous les plannings o√π ce chauffeur est le client_id (auteur)
                return productRepository.findByClientIdAndCategoryId(userContext.getUserId(), PLANNING_CATEGORY_ID);
            });
    }

    /**
     * SECURISE (CONDUCTEUR): Cr√©e un nouveau planning pour le conducteur connect√©.
     */
    @PostMapping
    public Mono<ResponseEntity<Product>> createPlanning(
            @RequestBody CreateProductRequest request,
            @AuthenticationPrincipal Mono<Jwt> jwtMono, 
            @RequestHeader("Authorization") String authorizationHeader) {
        
        return jwtMono
            .flatMap(jwt -> profileService.getUserSessionContext(JwtUtil.getUserIdFromToken(jwt), authorizationHeader, null))
            .flatMap(userContext -> {
                if (userContext.getDriverProfile() == null) {
                    return Mono.error(new IllegalStateException("Seul un chauffeur peut cr√©er un planning."));
                }
                if (userContext.getOrganisation() == null || userContext.getOrganisation().getOrganizationId() == null) {
                    return Mono.error(new IllegalStateException("Contexte utilisateur invalide pour cr√©er un planning (organisation manquante)."));
                }
                DriverProfile driverProfile = userContext.getDriverProfile();
                
                request.setCategoryId(PLANNING_CATEGORY_ID);
                request.setClientId(driverProfile.getUserId());
                request.setClientName(driverProfile.getFirstName() + " " + driverProfile.getLastName());
                request.setClientPhoneNumber(driverProfile.getPhoneNumber());
                request.setClientProfileImageUrl(driverProfile.getProfileImageUrl());
                
                // Le statut par d√©faut d'un nouveau planning est "Published"
                request.setStatus("Published");

                log.info("‚ñ∂Ô∏è [PlanningController.createPlanning] Cr√©ation d'un planning par le chauffeur ID: {} pour l'organisation ID: {}",
                         driverProfile.getUserId(), userContext.getOrganisation().getOrganizationId());
                log.info("‚ñ∂Ô∏è [PlanningController.createPlanning] Request payload avant envoi au resourceService: {}", request);

                return resourceService.createProduct(userContext.getOrganisation().getOrganizationId(), request, authorizationHeader, null);
            })
            .map(createdProduct -> {
                log.info("‚úÖ [PlanningController.createPlanning] Planning cr√©√© avec succ√®s. ID: {}", createdProduct.getId());
                return new ResponseEntity<>(createdProduct, HttpStatus.CREATED);
            });
    }

    /**
     * SECURISE (CONDUCTEUR): Met √† jour un planning appartenant au conducteur connect√©.
     */
    @PutMapping("/{planningId}")
    public Mono<ResponseEntity<Product>> updatePlanning(
            @PathVariable UUID planningId,
            @RequestBody CreateProductRequest request,
            @AuthenticationPrincipal Mono<Jwt> jwtMono,
            @RequestHeader("Authorization") String authorizationHeader) {
        
        return jwtMono
            .flatMap(jwt -> profileService.getUserSessionContext(JwtUtil.getUserIdFromToken(jwt), authorizationHeader, null))
            .flatMap(userContext -> {
                 if (userContext.getDriverProfile() == null) {
                    return Mono.error(new IllegalStateException("Seuls les chauffeurs peuvent modifier leurs plannings."));
                }
                if (userContext.getOrganisation() == null || userContext.getOrganisation().getOrganizationId() == null) {
                    return Mono.error(new IllegalStateException("Contexte utilisateur invalide pour mettre √† jour un planning (organisation manquante)."));
                }
                DriverProfile driverProfile = userContext.getDriverProfile();

                return productRepository.findById(new ProductKey(userContext.getOrganisation().getOrganizationId(), planningId))
                        .filter(product -> driverProfile.getUserId().equals(product.getClientId()))
                        .switchIfEmpty(Mono.error(new SecurityException("Le chauffeur n'est pas autoris√© √† modifier ce planning ou il n'existe pas.")))
                        .flatMap(existingPlanning ->
                            resourceService.updateProduct(userContext.getOrganisation().getOrganizationId(), planningId, request, authorizationHeader, null)
                        );
            })
            .doOnSuccess(updatedPlanning -> {
                if (updatedPlanning != null) {
                    socketIOServer.getBroadcastOperations().sendEvent("updated_planning", updatedPlanning);
                }
            })
            .map(ResponseEntity::ok)
            .defaultIfEmpty(ResponseEntity.notFound().build());
    }

    /**
     * SECURISE (CONDUCTEUR): Supprime un planning appartenant au conducteur connect√©.
     */
    @DeleteMapping("/{planningId}")
    public Mono<ResponseEntity<Void>> deletePlanning(
            @PathVariable UUID planningId,
            @AuthenticationPrincipal Mono<Jwt> jwtMono,
            @RequestHeader("Authorization") String authorizationHeader) {

        return jwtMono
            .flatMap(jwt -> profileService.getUserSessionContext(JwtUtil.getUserIdFromToken(jwt), authorizationHeader, null))
            .flatMap(userContext -> {
                if (userContext.getDriverProfile() == null) {
                    return Mono.error(new IllegalStateException("Seuls les chauffeurs peuvent supprimer leurs plannings."));
                }
                if (userContext.getOrganisation() == null || userContext.getOrganisation().getOrganizationId() == null) {
                    return Mono.error(new IllegalStateException("Contexte utilisateur invalide pour supprimer un planning (organisation manquante)."));
                }
                DriverProfile driverProfile = userContext.getDriverProfile();

                return productRepository.findById(new ProductKey(userContext.getOrganisation().getOrganizationId(), planningId))
                        .filter(product -> driverProfile.getUserId().equals(product.getClientId()))
                        .switchIfEmpty(Mono.error(new SecurityException("Le chauffeur n'est pas autoris√© √† supprimer ce planning ou il n'existe pas.")))
                        .flatMap(existingPlanning ->
                            resourceService.deleteProduct(userContext.getOrganisation().getOrganizationId(), planningId, authorizationHeader, null)
                        );
            })
            .then(Mono.just(new ResponseEntity<Void>(HttpStatus.NO_CONTENT)));
    }
    
    /**
     * SECURISE (CLIENT): Permet √† un client de DEMANDER √† r√©server un planning.
     * Le statut de l'annonce passe √† "PendingDriverConfirmation". Une notification est envoy√©e au chauffeur.
     * (Anciennement /accept)
     */
    @PostMapping("/{planningId}/request-booking")
    public Mono<ResponseEntity<Product>> requestPlanningBooking( // RENOMM√â
            @PathVariable UUID planningId,
            @AuthenticationPrincipal Mono<Jwt> jwtMono,
            @RequestHeader("Authorization") String authorizationHeader) {

        return jwtMono
            .flatMap(jwt -> profileService.getUserSessionContext(JwtUtil.getUserIdFromToken(jwt), authorizationHeader, null))
            .flatMap(clientContext -> {
                if (clientContext.getClientProfile() == null) {
                    return Mono.error(new IllegalStateException("Seul un client peut demander la r√©servation d'un planning."));
                }
                if (clientContext.getOrganisation() == null || clientContext.getOrganisation().getOrganizationId() == null) {
                    return Mono.error(new IllegalStateException("Contexte utilisateur invalide pour demander la r√©servation d'un planning (organisation manquante)."));
                }
                ClientProfile clientProfile = clientContext.getClientProfile();
                
                return productRepository.findById(new ProductKey(clientContext.getOrganisation().getOrganizationId(), planningId))
                    .flatMap(planning -> {
                        if (planning.getReservedByDriverId() != null) {
                            return Mono.error(new IllegalStateException("Ce planning a d√©j√† une demande de r√©servation ou est d√©j√† r√©serv√©."));
                        }
                        
                        // Met l'ID du client demandeur dans reservedByDriverId (qui repr√©sente ici le client ayant fait la demande)
                        planning.setReservedByDriverId(clientProfile.getUserId());
                        planning.setReservedByDriverName(clientProfile.getFirstName() + " " + clientProfile.getLastName());
                        planning.setStatus("PendingDriverConfirmation"); // NOUVEAU STATUT
                        log.info("Client {} demande la r√©servation du planning {}. Statut mis √† jour √† 'PendingDriverConfirmation'.", clientProfile.getUserId(), planningId);
                        
                        return productRepository.save(planning);
                    })
                    .flatMap(updatedPlanning -> 
                        profileService.findDriverById(updatedPlanning.getClientId()) // Le client_id du planning est l'ID du chauffeur
                            .flatMap(driverProfile -> notificationTriggerService.notifyDriverOfPlanningBookingRequest(updatedPlanning, clientProfile))
                            .thenReturn(updatedPlanning)
                    )
                    .doOnSuccess(updatedPlanning -> {
                        socketIOServer.getBroadcastOperations().sendEvent("updated_planning", updatedPlanning);
                    });
            })
            .map(ResponseEntity::ok)
            .defaultIfEmpty(ResponseEntity.notFound().build());
    }

    /**
     * SECURISE (CONDUCTEUR): Permet au CHAUFFEUR de confirmer (accepter) une demande de r√©servation d'un client.
     * Le statut du planning passe √† "Ongoing". Une notification est envoy√©e au client.
     */
    @PostMapping("/{planningId}/confirm-booking") // NOUVEL ENDPOINT
    public Mono<ResponseEntity<Product>> confirmPlanningBooking(
            @PathVariable UUID planningId,
            @RequestParam UUID clientId, // Le client √† confirmer
            @AuthenticationPrincipal Mono<Jwt> jwtMono,
            @RequestHeader("Authorization") String authorizationHeader) {
        
        return jwtMono
            .flatMap(jwt -> profileService.getUserSessionContext(JwtUtil.getUserIdFromToken(jwt), authorizationHeader, null))
            .flatMap(driverContext -> {
                if (driverContext.getDriverProfile() == null) {
                    return Mono.error(new IllegalStateException("Seul un chauffeur peut confirmer la r√©servation d'un planning."));
                }
                if (driverContext.getOrganisation() == null || driverContext.getOrganisation().getOrganizationId() == null) {
                    return Mono.error(new IllegalStateException("Contexte utilisateur invalide pour confirmer une r√©servation de planning (organisation manquante)."));
                }
                DriverProfile driverProfile = driverContext.getDriverProfile();

                return productRepository.findById(new ProductKey(driverContext.getOrganisation().getOrganizationId(), planningId))
                    .flatMap(planning -> {
                        // V√©rifier que le chauffeur connect√© est bien l'auteur du planning
                        if (!planning.getClientId().equals(driverContext.getUserId())) {
                            return Mono.error(new SecurityException("Vous n'√™tes pas l'auteur de ce planning."));
                        }
                        // V√©rifier que le statut est bien "PendingDriverConfirmation" et que le client √† confirmer est celui qui a fait la demande
                        if (!"PendingDriverConfirmation".equalsIgnoreCase(planning.getStatus()) || !planning.getReservedByDriverId().equals(clientId)) {
                             return Mono.error(new IllegalStateException("Ce planning n'est pas en attente de confirmation pour ce client, ou le statut est incorrect."));
                        }

                        planning.setStatus("Ongoing"); // Statut final
                        log.info("Chauffeur {} a confirm√© la r√©servation du client {} pour le planning {}. Statut mis √† jour √† 'Ongoing'.", driverProfile.getUserId(), clientId, planningId);
                        
                        return productRepository.save(planning);
                    })
                    .flatMap(updatedPlanning -> 
                        profileService.findClientById(clientId) // Retrouver le profil du client pour la notification
                            .flatMap(clientProfile -> notificationTriggerService.notifyClientOfPlanningBookingAccepted(updatedPlanning, driverProfile))
                            .thenReturn(updatedPlanning)
                    )
                    .doOnSuccess(updatedPlanning -> {
                        socketIOServer.getBroadcastOperations().sendEvent("updated_planning", updatedPlanning);
                    });
            })
            .map(ResponseEntity::ok)
            .defaultIfEmpty(ResponseEntity.notFound().build());
    }

    /**
     * SECURISE (CLIENT): Permet √† un client d'ANNULER sa demande de r√©servation ou une r√©servation en cours.
     * Le statut du planning revient √† "Published". Une notification est envoy√©e au chauffeur.
     */
    @PostMapping("/{planningId}/cancel-reservation") // NOUVEL ENDPOINT
    public Mono<ResponseEntity<Product>> cancelPlanningReservation(
            @PathVariable UUID planningId,
            @AuthenticationPrincipal Mono<Jwt> jwtMono,
            @RequestHeader("Authorization") String authorizationHeader) {

        return jwtMono
            .flatMap(jwt -> profileService.getUserSessionContext(JwtUtil.getUserIdFromToken(jwt), authorizationHeader, null))
            .flatMap(clientContext -> {
                if (clientContext.getClientProfile() == null) {
                    return Mono.error(new IllegalStateException("Seul un client peut annuler une r√©servation de planning."));
                }
                if (clientContext.getOrganisation() == null || clientContext.getOrganisation().getOrganizationId() == null) {
                    return Mono.error(new IllegalStateException("Contexte utilisateur invalide pour annuler une r√©servation de planning (organisation manquante)."));
                }
                ClientProfile clientProfile = clientContext.getClientProfile();

                return productRepository.findById(new ProductKey(clientContext.getOrganisation().getOrganizationId(), planningId))
                    .flatMap(planning -> {
                        // V√©rifier que le client connect√© est bien celui qui a demand√© ou r√©serv√©
                        if (!clientProfile.getUserId().equals(planning.getReservedByDriverId())) {
                            return Mono.error(new SecurityException("Vous n'avez pas demand√© ou r√©serv√© ce planning."));
                        }
                        // Autoriser l'annulation si le statut est "PendingDriverConfirmation" ou "Ongoing"
                        if (!"PendingDriverConfirmation".equalsIgnoreCase(planning.getStatus()) && !"Ongoing".equalsIgnoreCase(planning.getStatus())) {
                            return Mono.error(new IllegalStateException("Le planning n'est pas dans un √©tat permettant l'annulation de r√©servation (statut actuel: " + planning.getStatus() + ")."));
                        }

                        planning.setReservedByDriverId(null);
                        planning.setReservedByDriverName(null);
                        planning.setStatus("Published"); // Revenir au statut "Published"
                        log.info("Client {} a annul√© sa demande/r√©servation pour le planning {}. Statut remis √† 'Published'.", clientProfile.getUserId(), planningId);
                        
                        return productRepository.save(planning);
                    })
                    .flatMap(updatedPlanning -> 
                        profileService.findDriverById(updatedPlanning.getClientId()) // L'auteur du planning est le chauffeur
                            .flatMap(driverProfile -> notificationTriggerService.notifyDriverOfCancelledPlanningReservation(updatedPlanning, clientProfile))
                            .thenReturn(updatedPlanning)
                    )
                    .doOnSuccess(updatedPlanning -> {
                        socketIOServer.getBroadcastOperations().sendEvent("updated_planning", updatedPlanning);
                    });
            })
            .map(ResponseEntity::ok)
            .defaultIfEmpty(ResponseEntity.notFound().build());
    }

    /**
     * SECURISE (CLIENT): R√©cup√®re les plannings que le client connect√© a r√©serv√©s ou demand√©s.
     */
    @GetMapping("/my-reservations")
    public Flux<Product> getMyReservedRides(@AuthenticationPrincipal Mono<Jwt> jwtMono,
                                            @RequestHeader("Authorization") String authorizationHeader) {
        return jwtMono
            .flatMap(jwt -> profileService.getUserSessionContext(JwtUtil.getUserIdFromToken(jwt), authorizationHeader, null))
            .flatMapMany(userContext -> {
                 if (userContext.getClientProfile() == null) {
                     return Flux.error(new IllegalStateException("L'utilisateur n'est pas un client."));
                }
                log.info("R√©cup√©ration des courses r√©serv√©es/demand√©es par le client {}", userContext.getUserId());
                // Filtrer les plannings o√π ce client est le "reservedByDriverId"
                return productRepository.findByReservedByDriverId(userContext.getUserId())
                            .flatMap(this::enrichProductWithAuthorDetails); // Enrichir avec les d√©tails du chauffeur (auteur du planning)
            });
    }

    /**
     * M√©thode priv√©e pour enrichir un produit avec les d√©tails de son auteur (chauffeur).
     */
    private Mono<Product> enrichProductWithAuthorDetails(Product product) {
        UUID authorId = product.getClientId();
        if (authorId == null) {
            return Mono.just(product);
        }

        return profileService.findDriverById(authorId)
            .map(driverProfile -> {
                product.setAuthorId(driverProfile.getUserId());
                product.setAuthorName(driverProfile.getFirstName() + " " + driverProfile.getLastName());
                product.setAuthorPhoneNumber(driverProfile.getPhoneNumber());
                product.setAuthorProfileImageUrl(driverProfile.getProfileImageUrl());
                return product;
            })
            .defaultIfEmpty(product);
    }
}// END OF FILE: src/main/java/com/freelance/driver_backend/controller/PlanningController.java

//---> PATH: /home/mbogneng-junior/freelance-driver_Sylladb/backend/src/main/java/com/freelance/driver_backend/controller/ProfileController.java



// PATH: /home/mbogneng-junior/freelance-driver (Copie)/backend/src/main/java/com/freelance/driver_backend/controller/ProfileController.java

package com.freelance.driver_backend.controller;

import com.freelance.driver_backend.dto.UserSessionContextDto;
import com.freelance.driver_backend.model.ClientProfile;
import com.freelance.driver_backend.model.DriverProfile;
import com.freelance.driver_backend.service.ProfileService;
import com.freelance.driver_backend.util.JwtUtil;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.http.ResponseEntity;
import org.springframework.security.core.annotation.AuthenticationPrincipal;
import org.springframework.security.oauth2.jwt.Jwt;
import org.springframework.web.bind.annotation.*;
import reactor.core.publisher.Mono;

import java.util.Map;
import java.util.UUID;

@Slf4j
@RestController
@RequestMapping("/api/profiles")
@RequiredArgsConstructor
public class ProfileController {

    private final ProfileService profileService;

    /**
     * SECURISE: R√©cup√®re le profil complet de l'utilisateur actuellement connect√©.
     * Retourne la nouvelle structure UserSessionContextDto.
     */
    @GetMapping("/me")
    public Mono<ResponseEntity<UserSessionContextDto>> getMyProfile(
            @AuthenticationPrincipal Mono<Jwt> jwtMono,
            @RequestHeader("Authorization") String authorizationHeader) {
        return jwtMono
                .flatMap(jwt -> profileService.getUserSessionContext(JwtUtil.getUserIdFromToken(jwt),
                        authorizationHeader, null))
                .map(ResponseEntity::ok)
                .defaultIfEmpty(ResponseEntity.notFound().build());
    }

    /**
     * SECURISE: Met √† jour le profil du conducteur actuellement connect√©.
     * V√©rifie que l'utilisateur a bien un profil chauffeur.
     * // --- MODIFICATION ICI : Le type de retour du Mono ---
     * 
     * @return Le UserSessionContextDto complet et mis √† jour.
     */
    @PutMapping("/driver/me")
    public Mono<ResponseEntity<UserSessionContextDto>> updateDriverProfile( // <-- CHANGEMENT DU TYPE DE RETOUR
            @AuthenticationPrincipal Mono<Jwt> jwtMono,
            @RequestBody DriverProfile updatedProfileData,
            @RequestHeader("Authorization") String authorizationHeader) {
        return jwtMono
                .flatMap(jwt -> profileService.getUserSessionContext(JwtUtil.getUserIdFromToken(jwt),
                        authorizationHeader, null))
                .flatMap(userContext -> {
                    if (userContext.getDriverProfile() == null) {
                        return Mono.error(new IllegalStateException(
                                "L'utilisateur n'est pas un chauffeur. Impossible de mettre √† jour le profil chauffeur."));
                    }
                    UUID userId = userContext.getUserId();
                    return profileService.updateDriverProfile(userId, updatedProfileData); // <--
                                                                                           // profileService.updateDriverProfile
                                                                                           // retourne
                                                                                           // UserSessionContextDto
                })
                .map(ResponseEntity::ok)
                .defaultIfEmpty(ResponseEntity.notFound().build());
    }

    /**
     * SECURISE: Met √† jour le profil du client actuellement connect√©.
     * V√©rifie que l'utilisateur a bien un profil client.
     * // --- MODIFICATION ICI : Le type de retour du Mono ---
     * 
     * @return Le UserSessionContextDto complet et mis √† jour.
     */
    @PutMapping("/client/me")
    public Mono<ResponseEntity<UserSessionContextDto>> updateClientProfile( // <-- CHANGEMENT DU TYPE DE RETOUR
            @AuthenticationPrincipal Mono<Jwt> jwtMono,
            @RequestBody ClientProfile updatedProfileData,
            @RequestHeader("Authorization") String authorizationHeader) {

        return jwtMono
                .flatMap(jwt -> profileService.getUserSessionContext(JwtUtil.getUserIdFromToken(jwt),
                        authorizationHeader, null))
                .flatMap(userContext -> {
                    if (userContext.getClientProfile() == null) {
                        return Mono.error(new IllegalStateException(
                                "L'utilisateur n'est pas un client. Impossible de mettre √† jour le profil client."));
                    }
                    UUID userId = userContext.getUserId();
                    return profileService.updateClientProfile(userId, updatedProfileData); // <--
                                                                                           // profileService.updateClientProfile
                                                                                           // retourne
                                                                                           // UserSessionContextDto
                })
                .map(ResponseEntity::ok)
                .defaultIfEmpty(ResponseEntity.notFound().build());
    }

    /**
     * PUBLIC: R√©cup√®re le profil public d'un utilisateur par son ID.
     * Retourne la nouvelle structure UserSessionContextDto.
     */
    @GetMapping("/user/{userId}")
    public Mono<ResponseEntity<UserSessionContextDto>> getPublicUserProfile(
            @PathVariable UUID userId,
            @RequestHeader(value = "Authorization", required = false) String authorizationHeader) {
        log.info("‚ñ∂Ô∏è [ProfileController] R√©cup√©ration du profil public pour l'ID: {}", userId);
        return profileService.getUserSessionContext(userId, authorizationHeader, null)
                .map(ResponseEntity::ok)
                .doOnSuccess(response -> log.info("‚úÖ [ProfileController] Profil public de {} r√©cup√©r√©.", userId))
                .doOnError(error -> log.error("‚ùå Erreur lors de la r√©cup√©ration du profil public pour {}: {}", userId,
                        error.getMessage()))
                .defaultIfEmpty(ResponseEntity.notFound().build());
    }

    /**
     * SECURISE: Met √† jour l'URL de l'avatar pour l'utilisateur connect√©.
     * Cette route d√©clenche la mise √† jour de TOUS les profils associ√©s
     * (Driver/Client)
     * et la suppression de l'ancien avatar du stockage.
     * 
     * @param jwtMono             Le token JWT de l'utilisateur authentifi√©.
     * @param requestPayload      Un Map contenant "profileImageUrl".
     * @param authorizationHeader L'en-t√™te Authorization.
     * @return Le UserSessionContextDto complet et mis √† jour.
     */
    @PutMapping("/me/avatar")
    public Mono<ResponseEntity<UserSessionContextDto>> updateMyAvatar(
            @AuthenticationPrincipal Mono<Jwt> jwtMono,
            @RequestBody Map<String, String> requestPayload,
            @RequestHeader("Authorization") String authorizationHeader) {

        String newAvatarUrl = requestPayload.get("profileImageUrl");
        if (newAvatarUrl == null || newAvatarUrl.isEmpty()) {
            log.error("Requ√™te de mise √† jour de l'avatar avec une URL nulle ou vide.");
            return Mono.just(ResponseEntity.badRequest().body(null));
        }

        return jwtMono
                .flatMap(jwt -> {
                    UUID userId = JwtUtil.getUserIdFromToken(jwt);
                    log.info("Requ√™te de mise √† jour de l'avatar pour l'utilisateur ID: {} avec la nouvelle URL: {}",
                            userId, newAvatarUrl);
                    return profileService.updateAvatarUrl(userId, newAvatarUrl);
                })
                .map(ResponseEntity::ok)
                .defaultIfEmpty(ResponseEntity.notFound().build())
                .doOnError(e -> log.error("‚ùå Erreur lors de la mise √† jour de l'avatar de l'utilisateur: {}",
                        e.getMessage(), e));
    }
}// END OF FILE: src/main/java/com/freelance/driver_backend/controller/ProfileController.java

//---> PATH: /home/mbogneng-junior/freelance-driver_Sylladb/backend/src/main/java/com/freelance/driver_backend/controller/ProfileRoleController.java

package com.freelance.driver_backend.controller;

import com.freelance.driver_backend.dto.onboarding.ClientOnboardingRequest;
import com.freelance.driver_backend.dto.onboarding.DriverOnboardingRequest;
import com.freelance.driver_backend.dto.UserSessionContextDto; // Importez la nouvelle structure
import com.freelance.driver_backend.model.ClientProfile;
import com.freelance.driver_backend.model.DriverProfile;
import com.freelance.driver_backend.service.OnboardingService; // R√©utiliser le service Onboarding
import com.freelance.driver_backend.service.ProfileService;
import com.freelance.driver_backend.util.JwtUtil;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.core.annotation.AuthenticationPrincipal;
import org.springframework.security.oauth2.jwt.Jwt;
import org.springframework.web.bind.annotation.*;
import reactor.core.publisher.Mono;

import java.util.UUID;


@RestController
@RequestMapping("/api/profiles/roles")
@RequiredArgsConstructor
@Slf4j
public class ProfileRoleController {

    private final ProfileService profileService;
    private final OnboardingService onboardingService;

    
    @PostMapping("/become-driver")
    public Mono<ResponseEntity<UserSessionContextDto>> becomeDriver(
            @RequestBody DriverOnboardingRequest request, // R√©utilise le DTO d'onboarding
            @AuthenticationPrincipal Mono<Jwt> jwtMono,
            @RequestHeader("Authorization") String authorizationHeader) {

        return jwtMono
            .flatMap(jwt -> {
                UUID userId = JwtUtil.getUserIdFromToken(jwt);
                // V√©rifier d'abord si le profil chauffeur existe d√©j√† pour cet utilisateur
                return profileService.findDriverById(userId)
                    .flatMap(existingDriver -> {
                        log.warn("L'utilisateur {} a d√©j√† un DriverProfile. Impossible d'en cr√©er un autre.", userId);
                        return Mono.error(new IllegalStateException("Vous √™tes d√©j√† enregistr√© en tant que chauffeur."));
                    })
                    .switchIfEmpty(
                        // Si aucun profil chauffeur n'existe, proc√©der √† sa cr√©ation
                        onboardingService.createDriverProfileForExistingUser(userId, request, authorizationHeader)
                    )
                    .flatMap(driverProfile -> // driverProfile est le DriverProfile nouvellement cr√©√©
                         // Puis, r√©cup√©rer le contexte complet mis √† jour pour l'utilisateur
                         profileService.getUserSessionContext(userId, authorizationHeader, null)
                    )
                    .map(context -> new ResponseEntity<>(context, HttpStatus.CREATED));
            });
    }

    
    @PostMapping("/become-client")
    public Mono<ResponseEntity<UserSessionContextDto>> becomeClient(
            @RequestBody ClientOnboardingRequest request, // R√©utilise le DTO d'onboarding
            @AuthenticationPrincipal Mono<Jwt> jwtMono,
            @RequestHeader("Authorization") String authorizationHeader) {

        return jwtMono
            .flatMap(jwt -> {
                UUID userId = JwtUtil.getUserIdFromToken(jwt);
                // V√©rifier d'abord si le profil client existe d√©j√† pour cet utilisateur
                return profileService.findClientById(userId)
                    .flatMap(existingClient -> {
                        log.warn("L'utilisateur {} a d√©j√† un ClientProfile. Impossible d'en cr√©er un autre.", userId);
                        return Mono.error(new IllegalStateException("Vous √™tes d√©j√† enregistr√© en tant que client."));
                    })
                    .switchIfEmpty(
                        // Si aucun profil client n'existe, proc√©der √† sa cr√©ation
                        onboardingService.createClientProfileForExistingUser(userId, request, authorizationHeader)
                    )
                    .flatMap(clientProfile -> // clientProfile est le ClientProfile nouvellement cr√©√©
                         // Puis, r√©cup√©rer le contexte complet mis √† jour pour l'utilisateur
                         profileService.getUserSessionContext(userId, authorizationHeader, null)
                    )
                    .map(context -> new ResponseEntity<>(context, HttpStatus.CREATED));
            });
    }
}


// PATH: /home/mbogneng-junior/freelance-driver (Copie)/backend/src/main/java/com/freelance/driver_backend/controller/ProfileController.java

// END OF FILE: src/main/java/com/freelance/driver_backend/controller/ProfileRoleController.java

//---> PATH: /home/mbogneng-junior/freelance-driver_Sylladb/backend/src/main/java/com/freelance/driver_backend/controller/ReviewController.java



// PATH: /home/mbogneng-junior/freelance-driver (Copie)/backend/src/main/java/com/freelance/driver_backend/controller/ReviewController.java

package com.freelance.driver_backend.controller;

import com.freelance.driver_backend.dto.RateCriteriaRequest;
import com.freelance.driver_backend.dto.CreateReviewRequest;
import com.freelance.driver_backend.dto.UserSessionContextDto; // Importez la nouvelle structure
import com.freelance.driver_backend.model.ClientProfile; // Importez ClientProfile
import com.freelance.driver_backend.model.DriverProfile; // Importez DriverProfile
import com.freelance.driver_backend.model.Review;
import com.freelance.driver_backend.repository.ReviewRepository;
import com.freelance.driver_backend.service.ProfileService;
import com.freelance.driver_backend.util.JwtUtil;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.http.ResponseEntity;
import org.springframework.security.core.annotation.AuthenticationPrincipal;
import org.springframework.security.oauth2.jwt.Jwt;
import org.springframework.web.bind.annotation.*;
import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;

import java.time.Instant;
import java.util.UUID;

@RestController
@RequestMapping("/api/reviews")
@RequiredArgsConstructor
@Slf4j
public class ReviewController {

    private final ReviewRepository reviewRepository;
    private final ProfileService profileService;

    @PostMapping("/criteria")
    public Mono<ResponseEntity<Void>> rateByCriteria(@RequestBody RateCriteriaRequest request) {
        // Logique pour traiter la notation par crit√®res
        log.info("Received criteria rating for entity {}: {}", request.getEntityId(), request.getRatings());
        // Ici, vous ajouteriez la logique pour sauvegarder ces √©valuations.
        // Pour l'instant, nous retournons simplement un succ√®s.
        return Mono.just(ResponseEntity.ok().build());
    }

    @PostMapping
    public Mono<ResponseEntity<Review>> createReview(
            @RequestBody CreateReviewRequest request,
            @AuthenticationPrincipal Mono<Jwt> jwtMono,
            @RequestHeader("Authorization") String authorizationHeader) { // Ajout pour getUserSessionContext

        return jwtMono
            .flatMap(jwt -> profileService.getUserSessionContext(JwtUtil.getUserIdFromToken(jwt), authorizationHeader, null))
            .flatMap(userContext -> {
                // L'auteur d'un avis peut √™tre un client ou un chauffeur
                // On v√©rifie qu'il a au moins un profil
                if (userContext.getDriverProfile() == null && userContext.getClientProfile() == null) {
                    return Mono.error(new IllegalStateException("L'utilisateur n'a pas de profil actif pour laisser un avis."));
                }
                
                Review review = new Review();
                review.setId(UUID.randomUUID());
                review.setTargetUserId(request.getTargetUserId());
                review.setScore(request.getScore());
                review.setComment(request.getComment());
                review.setAuthorId(userContext.getUserId());
                
                // D√©termine les infos de l'auteur en fonction du premier profil trouv√©
                if (userContext.getDriverProfile() != null) {
                    review.setAuthorFirstName(userContext.getDriverProfile().getFirstName());
                    review.setAuthorLastName(userContext.getDriverProfile().getLastName());
                    review.setAuthorProfileImageUrl(userContext.getDriverProfile().getProfileImageUrl());
                } else if (userContext.getClientProfile() != null) {
                    review.setAuthorFirstName(userContext.getClientProfile().getFirstName());
                    review.setAuthorLastName(userContext.getClientProfile().getLastName());
                    review.setAuthorProfileImageUrl(userContext.getClientProfile().getProfileImageUrl());
                } else {
                    // Fallback si vraiment aucun profil n'est trouv√© (ne devrait pas arriver avec la v√©rification ci-dessus)
                    review.setAuthorFirstName("Utilisateur");
                    review.setAuthorLastName("Anonyme");
                }
                
                review.setCreatedAt(Instant.now().toEpochMilli());
                
                return reviewRepository.save(review);
            })
            .map(ResponseEntity::ok);
    }

    @GetMapping("/user/{userId}")
    public Flux<Review> getReviewsForUser(@PathVariable UUID userId,
                                          @RequestHeader(value = "Authorization", required = false) String authorizationHeader) {
        log.info("R√©cup√©ration des avis pour l'utilisateur ID: {}", userId);
        return reviewRepository.findByTargetUserId(userId)
                .flatMap(review -> enrichReviewWithAuthorDetails(review, authorizationHeader)); // Passer l'header
    }

    // MODIFI√â : Prend l'Authorization header pour pouvoir appeler getUserSessionContext
    private Mono<Review> enrichReviewWithAuthorDetails(Review review, String authorizationHeader) {
        return profileService.getUserSessionContext(review.getAuthorId(), authorizationHeader, null) // Utilise getUserSessionContext
            .flatMap(authorContext -> {
                if (authorContext.getDriverProfile() != null) {
                    review.setAuthorFirstName(authorContext.getDriverProfile().getFirstName());
                    review.setAuthorLastName(authorContext.getDriverProfile().getLastName());
                    review.setAuthorProfileImageUrl(authorContext.getDriverProfile().getProfileImageUrl());
                } else if (authorContext.getClientProfile() != null) {
                    review.setAuthorFirstName(authorContext.getClientProfile().getFirstName());
                    review.setAuthorLastName(authorContext.getClientProfile().getLastName());
                    review.setAuthorProfileImageUrl(authorContext.getClientProfile().getProfileImageUrl());
                }
                return Mono.just(review);
            })
            .defaultIfEmpty(review); // En cas d'erreur ou d'absence de profil, on renvoie l'avis sans les d√©tails enrichis
    }
}// END OF FILE: src/main/java/com/freelance/driver_backend/controller/ReviewController.java

//---> PATH: /home/mbogneng-junior/freelance-driver_Sylladb/backend/src/main/java/com/freelance/driver_backend/controller/VehicleController.java


// PATH: /home/mbogneng-junior/freelance-driver (Copie)/backend/src/main/java/com/freelance/driver_backend/controller/VehicleController.java

package com.freelance.driver_backend.controller;

import com.freelance.driver_backend.dto.CreateProductRequest; // Ajout√© pour les m√©thodes POST/PUT
import com.freelance.driver_backend.dto.UserSessionContextDto; // Nouveau import
import com.freelance.driver_backend.model.DriverProfile; // Nouveau import
import com.freelance.driver_backend.model.Product;
import com.freelance.driver_backend.service.ProfileService;
import com.freelance.driver_backend.service.ResourceService;
import com.freelance.driver_backend.util.JwtUtil;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.http.HttpStatus; // Ajout√© pour les ResponseEntity
import org.springframework.http.ResponseEntity; // Ajout√© pour les ResponseEntity
import org.springframework.security.core.annotation.AuthenticationPrincipal; // Ajout√© pour les m√©thodes POST/PUT
import org.springframework.security.oauth2.jwt.Jwt; // Ajout√© pour les m√©thodes POST/PUT
import org.springframework.web.bind.annotation.*;
import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;

import java.util.Optional;
import java.util.UUID;

@RestController
@RequestMapping("/api/vehicles")
@RequiredArgsConstructor
@Slf4j
public class VehicleController {

    private final ProfileService profileService;
    private final ResourceService resourceService;

    private static final UUID VEHICLE_CATEGORY_ID = UUID.fromString("e2a7f23e-a3a3-4b0c-852a-227a1c1d6a7e");

    /**
     * SECURISE: R√©cup√®re tous les v√©hicules du chauffeur actuellement connect√©.
     */
    @GetMapping
    public Flux<Product> getMyVehicles(
            @AuthenticationPrincipal Mono<Jwt> jwtMono,
            @RequestHeader("Authorization") String authorizationHeader) {

        return jwtMono
            .flatMap(jwt -> profileService.getUserSessionContext(JwtUtil.getUserIdFromToken(jwt), authorizationHeader, null))
            .flatMapMany(userContext -> {
                // Seuls les chauffeurs peuvent avoir des v√©hicules
                if (userContext.getDriverProfile() == null) {
                    return Flux.error(new IllegalStateException("Seuls les chauffeurs peuvent g√©rer leurs v√©hicules."));
                }
                if (userContext.getOrganisation() == null || userContext.getOrganisation().getOrganizationId() == null) {
                    return Flux.error(new IllegalStateException("L'utilisateur n'a pas d'organisation valide associ√©e."));
                }
                UUID organizationId = userContext.getOrganisation().getOrganizationId();
                // Filtre les produits par categoryId ET clientId (chauffeur connect√©)
                return resourceService.getProductsByCategory(organizationId, VEHICLE_CATEGORY_ID, authorizationHeader, null)
                                      .filter(product -> userContext.getUserId().equals(product.getClientId()));
            });
    }

    /**
     * PUBLIC: R√©cup√®re les v√©hicules d'un utilisateur sp√©cifique par son ID.
     * Cette route devrait id√©alement √™tre utilis√©e pour afficher les v√©hicules d'un CHAUFFEUR public.
     */
    @GetMapping("/user/{userId}")
    public Flux<Product> getVehiclesForUser(
            @PathVariable UUID userId,
            @RequestHeader(value = "Authorization", required = false) String authorizationHeader
    ) {
        log.info("‚ñ∂Ô∏è [VehicleController] R√©cup√©ration des v√©hicules pour l'utilisateur ID: {}", userId);

        String token = Optional.ofNullable(authorizationHeader).orElse(null);

        // MODIFI√â : R√©cup√®re l'organisation ID du userId sp√©cifi√©.
        // Puis, filtre les produits de cette organisation qui appartiennent √† ce userId.
        return profileService.findOrganisationIdByUserId(userId)
                .flatMapMany(orgId -> resourceService.getProductsByCategory(orgId, VEHICLE_CATEGORY_ID, token, null)
                                                    .filter(product -> userId.equals(product.getClientId())));
    }

    /**
     * SECURISE (CONDUCTEUR): Cr√©e un nouveau v√©hicule pour le chauffeur connect√©.
     */
    @PostMapping
    public Mono<ResponseEntity<Product>> createVehicle(
            @RequestBody CreateProductRequest request,
            @AuthenticationPrincipal Mono<Jwt> jwtMono,
            @RequestHeader("Authorization") String authorizationHeader) {

        return jwtMono
            .flatMap(jwt -> profileService.getUserSessionContext(JwtUtil.getUserIdFromToken(jwt), authorizationHeader, null))
            .flatMap(userContext -> {
                if (userContext.getDriverProfile() == null) {
                    return Mono.error(new IllegalStateException("Seuls les chauffeurs peuvent cr√©er des v√©hicules."));
                }
                if (userContext.getOrganisation() == null || userContext.getOrganisation().getOrganizationId() == null) {
                    return Mono.error(new IllegalStateException("Contexte utilisateur invalide pour cr√©er un v√©hicule (organisation manquante)."));
                }
                DriverProfile driverProfile = userContext.getDriverProfile();

                request.setCategoryId(VEHICLE_CATEGORY_ID);
                request.setClientId(driverProfile.getUserId()); // Le chauffeur connect√© est le propri√©taire du v√©hicule
                // Les autres champs comme clientName, clientPhoneNumber, clientProfileImageUrl peuvent √™tre d√©finis ici
                // pour enrichir le produit si n√©cessaire, mais le service de ressources pourrait d√©j√† le faire.
                request.setClientName(driverProfile.getFirstName() + " " + driverProfile.getLastName());
                request.setClientPhoneNumber(driverProfile.getPhoneNumber());
                request.setClientProfileImageUrl(driverProfile.getProfileImageUrl());
                
                log.info("‚ñ∂Ô∏è Controller: Cr√©ation d'un nouveau v√©hicule '{}' pour le chauffeur {}", request.getName(), driverProfile.getUserId());
                
                return resourceService.createProduct(
                    userContext.getOrganisation().getOrganizationId(), 
                    request, 
                    authorizationHeader, 
                    null
                );
            })
            .map(createdProduct -> new ResponseEntity<>(createdProduct, HttpStatus.CREATED));
    }

    /**
     * SECURISE (CONDUCTEUR): Met √† jour un v√©hicule existant.
     */
    @PutMapping("/{vehicleId}")
    public Mono<ResponseEntity<Product>> updateVehicle(
            @PathVariable UUID vehicleId,
            @RequestBody CreateProductRequest request,
            @AuthenticationPrincipal Mono<Jwt> jwtMono,
            @RequestHeader("Authorization") String authorizationHeader) {
        
        return jwtMono
            .flatMap(jwt -> profileService.getUserSessionContext(JwtUtil.getUserIdFromToken(jwt), authorizationHeader, null))
            .flatMap(userContext -> {
                if (userContext.getDriverProfile() == null) {
                    return Mono.error(new IllegalStateException("Seuls les chauffeurs peuvent modifier leurs v√©hicules."));
                }
                if (userContext.getOrganisation() == null || userContext.getOrganisation().getOrganizationId() == null) {
                    return Mono.error(new IllegalStateException("Contexte utilisateur invalide pour mettre √† jour un v√©hicule (organisation manquante)."));
                }
                DriverProfile driverProfile = userContext.getDriverProfile();

                // V√©rification cruciale : l'utilisateur connect√© est-il le propri√©taire du v√©hicule ?
                return resourceService.getProductsByCategory(userContext.getOrganisation().getOrganizationId(), VEHICLE_CATEGORY_ID, authorizationHeader, null)
                        .filter(product -> product.getId().equals(vehicleId) && driverProfile.getUserId().equals(product.getClientId()))
                        .next() // Prend le premier √©l√©ment ou vide
                        .switchIfEmpty(Mono.error(new SecurityException("Le chauffeur n'est pas autoris√© √† modifier ce v√©hicule ou il n'existe pas.")))
                        .flatMap(existingVehicle -> {
                            request.setCategoryId(VEHICLE_CATEGORY_ID);
                            request.setClientId(driverProfile.getUserId()); // Assure que le propri√©taire reste le m√™me
                            request.setClientName(driverProfile.getFirstName() + " " + driverProfile.getLastName());
                            request.setClientPhoneNumber(driverProfile.getPhoneNumber());
                            request.setClientProfileImageUrl(driverProfile.getProfileImageUrl());

                            log.info("‚ñ∂Ô∏è Controller: Mise √† jour du v√©hicule ID: {}", vehicleId);
                            
                            return resourceService.updateProduct(
                                userContext.getOrganisation().getOrganizationId(), 
                                vehicleId,
                                request, 
                                authorizationHeader, 
                                null
                            );
                        });
            })
            .map(ResponseEntity::ok)
            .defaultIfEmpty(ResponseEntity.notFound().build());
    }

    /**
     * SECURISE (CONDUCTEUR): Supprime un v√©hicule existant.
     */
    @DeleteMapping("/{vehicleId}")
    public Mono<ResponseEntity<Void>> deleteVehicle(
            @PathVariable UUID vehicleId,
            @AuthenticationPrincipal Mono<Jwt> jwtMono,
            @RequestHeader("Authorization") String authorizationHeader) {

        return jwtMono
            .flatMap(jwt -> profileService.getUserSessionContext(JwtUtil.getUserIdFromToken(jwt), authorizationHeader, null))
            .flatMap(userContext -> {
                if (userContext.getDriverProfile() == null) {
                    return Mono.error(new IllegalStateException("Seuls les chauffeurs peuvent supprimer leurs v√©hicules."));
                }
                if (userContext.getOrganisation() == null || userContext.getOrganisation().getOrganizationId() == null) {
                    return Mono.error(new IllegalStateException("Contexte utilisateur invalide pour supprimer un v√©hicule (organisation manquante)."));
                }
                DriverProfile driverProfile = userContext.getDriverProfile();

                // V√©rification cruciale : l'utilisateur connect√© est-il le propri√©taire du v√©hicule ?
                return resourceService.getProductsByCategory(userContext.getOrganisation().getOrganizationId(), VEHICLE_CATEGORY_ID, authorizationHeader, null)
                        .filter(product -> product.getId().equals(vehicleId) && driverProfile.getUserId().equals(product.getClientId()))
                        .next() // Prend le premier √©l√©ment ou vide
                        .switchIfEmpty(Mono.error(new SecurityException("Le chauffeur n'est pas autoris√© √† supprimer ce v√©hicule ou il n'existe pas.")))
                        .flatMap(existingVehicle -> {
                            log.info("‚ñ∂Ô∏è Controller: Suppression du v√©hicule ID: {}", vehicleId);
                            return resourceService.deleteProduct(
                                userContext.getOrganisation().getOrganizationId(), 
                                vehicleId,
                                authorizationHeader, 
                                null
                            );
                        });
            })
            .then(Mono.just(new ResponseEntity<Void>(HttpStatus.NO_CONTENT)));
    }
}// END OF FILE: src/main/java/com/freelance/driver_backend/controller/VehicleController.java

//---> PATH: /home/mbogneng-junior/freelance-driver_Sylladb/backend/src/main/java/com/freelance/driver_backend/DriverBackendApplication.java

package com.freelance.driver_backend;


import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;



@SpringBootApplication

public class DriverBackendApplication {

    public static void main(String[] args) {
        SpringApplication.run(DriverBackendApplication.class, args);
    }

   
}// END OF FILE: src/main/java/com/freelance/driver_backend/DriverBackendApplication.java

//---> PATH: /home/mbogneng-junior/freelance-driver_Sylladb/backend/src/main/java/com/freelance/driver_backend/dto/CreateProductRequest.java

// src/main/java/com/freelance/driver_backend/dto/CreateProductRequest.java

package com.freelance.driver_backend.dto;

import lombok.Data;
import java.math.BigDecimal;
import java.util.Map;
import java.util.UUID;

/**
 * DTO (Data Transfer Object) universel pour la cr√©ation et la mise √† jour de
 * "Produits".
 * Il regroupe tous les champs potentiels envoy√©s par le frontend pour
 * diff√©rentes entit√©s
 * (Annonces, Plannings, V√©hicules, Adresses, etc.).
 */
@Data
public class CreateProductRequest {
    private String id; // L'ID du produit (UUID en string)

    // --- Champs Communs ---
    private String name;
    private String shortDescription;
    private UUID categoryId;
    private Boolean isActive;
    private String status;
    private BigDecimal defaultSellPrice;

    // --- Champs de Trajet (Annonces/Plannings) ---
    private String pickupLocation;
    private String dropoffLocation;
    private String startDate;
    private String startTime;
    private String endDate;
    private String endTime;

    // --- Champs d'Annonce Sp√©cifiques ---
    private String baggageInfo;
    private boolean isNegotiable;
    private String paymentMethod;

    // --- Champs d'Auteur (Client ou Conducteur) ---
    private UUID clientId;
    private String clientName;
    private String clientPhoneNumber;
    private String clientProfileImageUrl;

    // --- Champs Sp√©cifiques au Planning (stock√©s dans metadata par le controller)
    // ---
    private String paymentOption;
    private BigDecimal regularAmount;
    private String discountPercentage;
    private BigDecimal discountedAmount;

    // --- Stockage Flexible ---
    private Map<String, String> metadata;
}// END OF FILE: src/main/java/com/freelance/driver_backend/dto/CreateProductRequest.java

//---> PATH: /home/mbogneng-junior/freelance-driver_Sylladb/backend/src/main/java/com/freelance/driver_backend/dto/CreateReviewRequest.java

package com.freelance.driver_backend.dto;

import lombok.Data;

import java.util.UUID;

@Data
public class CreateReviewRequest {
    private UUID targetUserId;
    private int score;
    private String comment;
}
// END OF FILE: src/main/java/com/freelance/driver_backend/dto/CreateReviewRequest.java

//---> PATH: /home/mbogneng-junior/freelance-driver_Sylladb/backend/src/main/java/com/freelance/driver_backend/dto/external/ChatUserCreationPayload.java

package com.freelance.driver_backend.dto.external;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.util.Map;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class ChatUserCreationPayload {
    private String projectId;
    private String externalId;
    private String avatar;
    private String displayName;
    private String email;
    private String phoneNumber;
    private String login;
    private String secret;
    private Map<String, String> customJson;
}// END OF FILE: src/main/java/com/freelance/driver_backend/dto/external/ChatUserCreationPayload.java

//---> PATH: /home/mbogneng-junior/freelance-driver_Sylladb/backend/src/main/java/com/freelance/driver_backend/dto/external/ChatUserCreationResponse.java

package com.freelance.driver_backend.dto.external;

import lombok.Data;


@Data
public class ChatUserCreationResponse {
    private String id;
    private String projectId;
    private String externalId;
    private String avatar;
    private String displayName;
    private String email;
    private String phoneNumber;
    private String login;
    private String username;
    private boolean online;
    private boolean enabled;
    // On peut omettre les autres champs pour la simplicit√©
}// END OF FILE: src/main/java/com/freelance/driver_backend/dto/external/ChatUserCreationResponse.java

//---> PATH: /home/mbogneng-junior/freelance-driver_Sylladb/backend/src/main/java/com/freelance/driver_backend/dto/external/ChatUserLoginPayload.java

package com.freelance.driver_backend.dto.external;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class ChatUserLoginPayload {
    private String projectId;
    private String login;
    private String secret;
}
// END OF FILE: src/main/java/com/freelance/driver_backend/dto/external/ChatUserLoginPayload.java

//---> PATH: /home/mbogneng-junior/freelance-driver_Sylladb/backend/src/main/java/com/freelance/driver_backend/dto/external/ChatUserLoginResponse.java

package com.freelance.driver_backend.dto.external;

import lombok.Data;

@Data
public class ChatUserLoginResponse {
    private ChatUserCreationResponse data;
    private String token;
}// END OF FILE: src/main/java/com/freelance/driver_backend/dto/external/ChatUserLoginResponse.java

//---> PATH: /home/mbogneng-junior/freelance-driver_Sylladb/backend/src/main/java/com/freelance/driver_backend/dto/external/LoginRequest.java

package com.freelance.driver_backend.dto.external;


import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class LoginRequest {
    private String username;
    private String password;
}// END OF FILE: src/main/java/com/freelance/driver_backend/dto/external/LoginRequest.java

//---> PATH: /home/mbogneng-junior/freelance-driver_Sylladb/backend/src/main/java/com/freelance/driver_backend/dto/external/LoginResponse.java

// Fichier : src/main/java/com/freelance/driver_backend/dto/external/LoginResponse.java
package com.freelance.driver_backend.dto.external;

import com.fasterxml.jackson.annotation.JsonProperty;
import lombok.Data;
import java.util.List;
import java.util.UUID;

@Data
public class LoginResponse {
    @JsonProperty("access_token")
    private AccessToken accessToken;
    private UserInfo user;
    private List<String> roles;
    private List<String> permissions;

    @Data
    public static class AccessToken {
        private String token;
        private String type;
        @JsonProperty("expire_in")
        private int expiresIn;
    }

    @Data
    public static class UserInfo {
        private UUID id;
        @JsonProperty("first_name")
        private String firstName;
        @JsonProperty("last_name")
        private String lastName;
        private String username;
        private String email;
        @JsonProperty("phone_number")
        private String phoneNumber;
        @JsonProperty("email_verified")
        private boolean emailVerified;
        @JsonProperty("phone_number_verified")
        private boolean phoneNumberVerified;
    }
}// END OF FILE: src/main/java/com/freelance/driver_backend/dto/external/LoginResponse.java

//---> PATH: /home/mbogneng-junior/freelance-driver_Sylladb/backend/src/main/java/com/freelance/driver_backend/dto/external/MediaApiResponseDto.java

package com.freelance.driver_backend.dto.external;

import com.fasterxml.jackson.annotation.JsonIgnoreProperties;
import com.fasterxml.jackson.annotation.JsonProperty;
import lombok.Data;
import java.util.UUID;

/**
 * Repr√©sente la r√©ponse JSON de la nouvelle API de m√©dias externe.
 * Ignore les champs non n√©cessaires pour notre logique.
 */
@Data
@JsonIgnoreProperties(ignoreUnknown = true)
public class MediaApiResponseDto {

    @JsonProperty("id")
    private UUID id;

    @JsonProperty("uri")
    private String uri; // L'URI relative compl√®te du fichier

    // Helper pour reconstruire l'URL publique que notre application attend
    public String getPublicUrl(String baseUrl) {
        if (baseUrl == null || id == null) {
            return null;
        }
        // La nouvelle API utilise /media/proxy/{id} pour servir les fichiers
        return baseUrl + "/media/proxy/" + this.id.toString();
    }
}// END OF FILE: src/main/java/com/freelance/driver_backend/dto/external/MediaApiResponseDto.java

//---> PATH: /home/mbogneng-junior/freelance-driver_Sylladb/backend/src/main/java/com/freelance/driver_backend/dto/external/NotificationRequest.java

package com.freelance.driver_backend.dto.external;

import com.fasterxml.jackson.annotation.JsonProperty;
import lombok.Builder;
import lombok.Data;
import java.util.List;
import java.util.Map;
import java.util.UUID;

@Data
@Builder
public class NotificationRequest {

    @JsonProperty("template_id")
    private UUID templateId;

    private String subject;
    private String body;
    private List<String> recipients;
    private String type; // ex: "EMAIL", "SMS"
    private String priority; // ex: "LEVEL_1"
    

    // Pour les variables Thymeleaf
    private Map<String, String> metadata;
    private Map<String, String> data;
}// END OF FILE: src/main/java/com/freelance/driver_backend/dto/external/NotificationRequest.java

//---> PATH: /home/mbogneng-junior/freelance-driver_Sylladb/backend/src/main/java/com/freelance/driver_backend/dto/external/OAuthTokenResponse.java

package com.freelance.driver_backend.dto.external;

import com.fasterxml.jackson.annotation.JsonProperty;
import lombok.Data;

@Data
public class OAuthTokenResponse {

    @JsonProperty("access_token")
    private String accessToken;

    @JsonProperty("token_type")
    private String tokenType;

    @JsonProperty("expires_in")
    private int expiresIn;

    private String scope;
}// END OF FILE: src/main/java/com/freelance/driver_backend/dto/external/OAuthTokenResponse.java

//---> PATH: /home/mbogneng-junior/freelance-driver_Sylladb/backend/src/main/java/com/freelance/driver_backend/dto/external/OrganisationCreationRequest.java

package com.freelance.driver_backend.dto.external;

import com.fasterxml.jackson.annotation.JsonProperty;
import lombok.Builder;
import lombok.Data;

import java.time.OffsetDateTime;
import java.util.List;

@Data
@Builder
public class OrganisationCreationRequest {

    @JsonProperty("long_name")
    private String longName;

    @JsonProperty("short_name")
    private String shortName;

    private String email;
    private String description;

    @JsonProperty("business_domains")
    private List<String> businessDomains;

    @JsonProperty("logo_url")
    private String logoUrl;

    @JsonProperty("legal_form")
    private String legalForm; // ex: "11"

    @JsonProperty("web_site_url")
    private String webSiteUrl;

    @JsonProperty("social_network")
    private String socialNetwork;

    @JsonProperty("business_registration_number")
    private String businessRegistrationNumber;

    @JsonProperty("tax_number")
    private String taxNumber;

    @JsonProperty("capital_share")
    private Double capitalShare;

    @JsonProperty("registration_date")
    private OffsetDateTime registrationDate;

    @JsonProperty("ceo_name")
    private String ceoName;

    @JsonProperty("year_founded")
    private OffsetDateTime yearFounded;

    private List<String> keywords;

    @JsonProperty("number_of_employees")
    private Integer numberOfEmployees;
}// END OF FILE: src/main/java/com/freelance/driver_backend/dto/external/OrganisationCreationRequest.java

//---> PATH: /home/mbogneng-junior/freelance-driver_Sylladb/backend/src/main/java/com/freelance/driver_backend/dto/external/OrganisationDto.java

// Fichier : src/main/java/com/freelance/driver_backend/dto/external/OrganisationDto.java
package com.freelance.driver_backend.dto.external;

import com.fasterxml.jackson.annotation.JsonProperty;
import lombok.Data;
import java.util.UUID;

@Data
public class OrganisationDto {
    @JsonProperty("organization_id")
    private UUID organizationId;
    @JsonProperty("long_name")
    private String longName;
    private String description;
    private String status;
    // Ajouter d'autres champs si n√©cessaire pour votre logique,
    // mais pour le moment, c'est suffisant.
}// END OF FILE: src/main/java/com/freelance/driver_backend/dto/external/OrganisationDto.java

//---> PATH: /home/mbogneng-junior/freelance-driver_Sylladb/backend/src/main/java/com/freelance/driver_backend/dto/external/RegistrationRequest.java

package com.freelance.driver_backend.dto.external;

import com.fasterxml.jackson.annotation.JsonProperty;
import lombok.Builder;
import lombok.Data;
import java.util.Collections;
import java.util.List;

@Data
@Builder // Utiliser le pattern Builder est plus propre
public class RegistrationRequest {
    private String username;
    private String email;
    private String password;
    @JsonProperty("first_name")
    private String firstName;
    @JsonProperty("last_name")
    private String lastName;
    @JsonProperty("phone_number")
    private String phoneNumber;
    
    // Initialis√© √† une liste vide comme dans l'exemple de l'API
    @Builder.Default
    private List<Authority> authorities = Collections.emptyList();

    @Data
    public static class Authority {
        // Cette classe peut rester vide si on ne l'utilise pas, ou la supprimer si on envoie toujours une liste vide.
    }
}// END OF FILE: src/main/java/com/freelance/driver_backend/dto/external/RegistrationRequest.java

//---> PATH: /home/mbogneng-junior/freelance-driver_Sylladb/backend/src/main/java/com/freelance/driver_backend/dto/external/UploadMediaResponse.java

package com.freelance.driver_backend.dto.external;

import lombok.Data;
import java.util.UUID;

/**
 * Repr√©sente la r√©ponse JSON obtenue apr√®s un t√©l√©versement r√©ussi
 * aupr√®s du service de m√©dia.
 */
@Data
public class UploadMediaResponse {
    private UUID id;
    private UUID resourceId;
    private String uri;
    private String url;
}// END OF FILE: src/main/java/com/freelance/driver_backend/dto/external/UploadMediaResponse.java

//---> PATH: /home/mbogneng-junior/freelance-driver_Sylladb/backend/src/main/java/com/freelance/driver_backend/dto/external/UserDto.java

package com.freelance.driver_backend.dto.external;



import com.fasterxml.jackson.annotation.JsonProperty;
import lombok.Data;
import java.time.OffsetDateTime;
import java.util.UUID;

@Data
public class UserDto {
    private UUID id;
    private String username;
    private String email;
    @JsonProperty("first_name")
    private String firstName;
    @JsonProperty("last_name")
    private String lastName;
    @JsonProperty("phone_number")
    private String phoneNumber;
    @JsonProperty("email_verified")
    private boolean emailVerified;
    @JsonProperty("phone_number_verified")
    private boolean phoneNumberVerified;
    @JsonProperty("is_enabled")
    private boolean isEnabled;
    @JsonProperty("created_at")
    private OffsetDateTime createdAt;
    @JsonProperty("updated_at")
    private OffsetDateTime updatedAt;
}// END OF FILE: src/main/java/com/freelance/driver_backend/dto/external/UserDto.java

//---> PATH: /home/mbogneng-junior/freelance-driver_Sylladb/backend/src/main/java/com/freelance/driver_backend/dto/onboarding/ChatSessionInfo.java

package com.freelance.driver_backend.dto.onboarding;

import com.freelance.driver_backend.dto.external.ChatUserCreationResponse;
import lombok.Builder; // <-- V√©rifie cet import
import lombok.Data;

@Data
@Builder // <-- C'est cette annotation qui cr√©e la m√©thode builder()
public class ChatSessionInfo {
    private String token;
    private ChatUserCreationResponse userDetails;
}// END OF FILE: src/main/java/com/freelance/driver_backend/dto/onboarding/ChatSessionInfo.java

//---> PATH: /home/mbogneng-junior/freelance-driver_Sylladb/backend/src/main/java/com/freelance/driver_backend/dto/onboarding/ClientOnboardingRequest.java

package com.freelance.driver_backend.dto.onboarding;

import lombok.Data;

@Data
public class ClientOnboardingRequest {
    // Infos pour le compte User
    private String email;
    private String password;
    private String firstName; // Nom du contact principal
    private String lastName;  // Pr√©nom du contact principal
    private String phoneNumber;

    // Infos pour l'organisation du Client
    private String companyName;
    private String companyDescription;
    private String otp;
}// END OF FILE: src/main/java/com/freelance/driver_backend/dto/onboarding/ClientOnboardingRequest.java

//---> PATH: /home/mbogneng-junior/freelance-driver_Sylladb/backend/src/main/java/com/freelance/driver_backend/dto/onboarding/DriverOnboardingRequest.java

package com.freelance.driver_backend.dto.onboarding;

import lombok.Data;

@Data
public class DriverOnboardingRequest {
    // Infos pour le compte User
    private String email;
    private String password;
    private String firstName;
    private String lastName;
    private String phoneNumber;

    // Infos pour l'organisation
    private String companyName;
    private String companyDescription;

    // Infos pour le profil sp√©cifique Driver
    private String licenseNumber;
    private String vehicleDetails;
    private String otp;
}// END OF FILE: src/main/java/com/freelance/driver_backend/dto/onboarding/DriverOnboardingRequest.java

//---> PATH: /home/mbogneng-junior/freelance-driver_Sylladb/backend/src/main/java/com/freelance/driver_backend/dto/onboarding/OnboardingResponse.java

package com.freelance.driver_backend.dto.onboarding;

import lombok.Builder;
import lombok.Data;

@Data
@Builder
public class OnboardingResponse {
    private String token;
    private Object profile;
    private ChatSessionInfo chatSession; // <-- AJOUTE CETTE LIGNE
}// END OF FILE: src/main/java/com/freelance/driver_backend/dto/onboarding/OnboardingResponse.java

//---> PATH: /home/mbogneng-junior/freelance-driver_Sylladb/backend/src/main/java/com/freelance/driver_backend/dto/RateCriteriaRequest.java

package com.freelance.driver_backend.dto;

import lombok.Data;
import java.util.Map;
import java.util.UUID;

@Data
public class RateCriteriaRequest {
    private String entityId;
    private Map<String, Integer> ratings;
}
// END OF FILE: src/main/java/com/freelance/driver_backend/dto/RateCriteriaRequest.java

//---> PATH: /home/mbogneng-junior/freelance-driver_Sylladb/backend/src/main/java/com/freelance/driver_backend/dto/UserSessionContextDto.java

package com.freelance.driver_backend.dto;

import com.fasterxml.jackson.annotation.JsonInclude;
import com.freelance.driver_backend.dto.external.OrganisationDto;
import com.freelance.driver_backend.model.ClientProfile; // Nouveau import
import com.freelance.driver_backend.model.DriverProfile; // Nouveau import
import lombok.Builder;
import lombok.Data;
import java.util.List; // Import modifi√© pour une liste de r√¥les
import java.util.UUID;

@Data
@Builder // Le Builder sera tr√®s pratique pour construire cet objet complexe
@JsonInclude(JsonInclude.Include.NON_NULL) // N'inclut que les champs non nuls dans le JSON
public class UserSessionContextDto {

    private UUID userId;
    // MODIFI√â : Une liste de r√¥les, permettant plusieurs r√¥les
    private List<UserRole> roles;
    // MODIFI√â : Des objets de profil sp√©cifiques, peuvent √™tre nuls
    private DriverProfile driverProfile;
    private ClientProfile clientProfile;
    // L'objet Organisation enrichi. Un utilisateur aura une organisation "principale" (par exemple, la premi√®re cr√©√©e)
    private OrganisationDto organisation;

    public enum UserRole {
        DRIVER,
        CLIENT,
        NO_PROFILE // Repr√©sente un utilisateur avec un compte d'authentification mais sans profil sp√©cifique encore
    }
}// END OF FILE: src/main/java/com/freelance/driver_backend/dto/UserSessionContextDto.java

//---> PATH: /home/mbogneng-junior/freelance-driver_Sylladb/backend/src/main/java/com/freelance/driver_backend/initializer/ApplicationInitializer.java



package com.freelance.driver_backend.initializer;

import com.freelance.driver_backend.model.DesignTemplate;
import com.freelance.driver_backend.model.EmailTemplate;
import com.freelance.driver_backend.model.FirebaseSetting;
import com.freelance.driver_backend.model.PushTemplate;
import com.freelance.driver_backend.model.SmtpSetting;
import com.freelance.driver_backend.model.mock.MockOrganisation;
import com.freelance.driver_backend.repository.DesignTemplateRepository;
import com.freelance.driver_backend.repository.EmailTemplateRepository;
import com.freelance.driver_backend.repository.FirebaseSettingRepository;
import com.freelance.driver_backend.repository.PushTemplateRepository;
import com.freelance.driver_backend.repository.SmtpSettingRepository;
import com.freelance.driver_backend.repository.mock.MockOrganisationRepository;
import io.github.cdimascio.dotenv.Dotenv;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.boot.CommandLineRunner;
import org.springframework.context.annotation.Profile;
import org.springframework.core.io.ClassPathResource;
import org.springframework.stereotype.Component;

import java.io.IOException;
import java.io.InputStream;
import java.util.UUID;


@Component

@RequiredArgsConstructor
@Slf4j
public class ApplicationInitializer implements CommandLineRunner {

    private final Dotenv dotenv;
    @Value("${spring.mail.host}")
    private String mailHost;
    @Value("${spring.mail.port}")
    private int mailPort;
    @Value("${spring.mail.username}")
    private String mailUsername;
    @Value("${spring.mail.password}")
    private String mailPassword;

    private final MockOrganisationRepository mockOrganisationRepository;
    private final SmtpSettingRepository smtpSettingRepository;
    private final FirebaseSettingRepository firebaseSettingRepository;
    private final DesignTemplateRepository designTemplateRepository;
    private final EmailTemplateRepository emailTemplateRepository;
    private final PushTemplateRepository pushTemplateRepository;


    @Override
    public void run(String... args) {
        log.info("üöÄ D√©marrage du processus d'initialisation des templates et configs internes de l'application...");

        UUID sysOrgId = getUuidFromEnv("SYSTEM_ORGANIZATION_ID");
        UUID smtpSettingId = getUuidFromEnv("SMTP_SETTING_ID");
        UUID firebaseSettingId = getUuidFromEnv("FIREBASE_SETTING_ID");
        UUID designEmailOtpId = getUuidFromEnv("DESIGN_EMAIL_OTP_ID");
        UUID templateEmailOtpId = getUuidFromEnv("TEMPLATE_EMAIL_OTP_ID");
        UUID templatePushNewPlanningId = getUuidFromEnv("TEMPLATE_PUSH_NEW_PLANNING_ID");
        UUID templatePushNewAnnouncementId = getUuidFromEnv("TEMPLATE_PUSH_NEW_ANNOUNCEMENT_ID");
        UUID templatePushAnnouncementAcceptedId = getUuidFromEnv("TEMPLATE_PUSH_ANNOUNCEMENT_ACCEPTED_ID");
        UUID templatePushAnnouncementConfirmedId = getUuidFromEnv("TEMPLATE_PUSH_ANNOUNCEMENT_CONFIRMED_ID");
        UUID templatePushPostulationCancelledId = getUuidFromEnv("TEMPLATE_PUSH_POSTULATION_CANCELLED_ID");

        // NOUVEAUX TEMPLATES POUR LE FLUX CLIENT-PLANNING
        UUID templatePushPlanningBookingRequestedToDriverId = getUuidFromEnv("TEMPLATE_PUSH_PLANNING_BOOKING_REQUESTED_TO_DRIVER_ID");
        UUID templatePushPlanningBookingAcceptedToClientId = getUuidFromEnv("TEMPLATE_PUSH_PLANNING_BOOKING_ACCEPTED_TO_CLIENT_ID");
        UUID templatePushPlanningReservationCancelledId = getUuidFromEnv("TEMPLATE_PUSH_PLANNING_RESERVATION_CANCELLED_ID");


        log.info("‚ÑπÔ∏è Les configurations UUID pour les templates sont lues depuis les variables d'environnement/fichier .env.");

        // √âtape 2: Insertion de l'organisation 'Syst√®me'
        MockOrganisation systemOrg = new MockOrganisation();
        systemOrg.setOrganizationId(sysOrgId);
        systemOrg.setLongName("System Default");
        systemOrg.setDescription("Organisation par d√©faut pour les templates globaux");
        mockOrganisationRepository.save(systemOrg)
            .doOnSuccess(org -> log.info("‚úÖ Organisation 'Syst√®me' ins√©r√©e/mise √† jour: {}", org.getLongName()))
            .doOnError(e -> log.error("‚ùå √âchec de l'insertion de l'organisation syst√®me dans ScyllaDB: {}", e.getMessage()))
            .block();


        log.info("üî∑ √âTAPE 3: Configuration des templates de notification via les d√©p√¥ts...");

        // 3.1 Cr√©ation du Setting SMTP
        SmtpSetting smtpSetting = new SmtpSetting();
        smtpSetting.setId(smtpSettingId);
        smtpSetting.setOrganizationId(sysOrgId);
        smtpSetting.setHost(mailHost);
        smtpSetting.setPort(mailPort);
        smtpSetting.setEncryption("TLS");
        smtpSetting.setUsername(mailUsername);
        smtpSetting.setPassword(mailPassword);
        smtpSetting.setSenderEmail("mbognengj@gmail.com");
        smtpSetting.setSenderName("Freelance Driver App");

        smtpSettingRepository.save(smtpSetting)
            .doOnSuccess(s -> log.info("‚úÖ Template SMTP cr√©√©/mis √† jour."))
            .doOnError(e -> log.error("‚ùå √âchec cr√©ation/mise √† jour SMTP: {}", e.getMessage()))
            .block();

        // 3.2 Cr√©ation du Setting Firebase
        FirebaseSetting firebaseSetting = new FirebaseSetting();
        firebaseSetting.setId(firebaseSettingId);
        firebaseSetting.setOrganizationId(sysOrgId);
        firebaseSetting.setProjectId("freelance-driver-app"); 

        ClassPathResource resource = new ClassPathResource("firebase-service-account-key.json");
        try (InputStream serviceAccount = resource.getInputStream()) {
            String privateKeyJson = new String(serviceAccount.readAllBytes());
            privateKeyJson = privateKeyJson.replace("\"", "\\\"").replace("\n", "").replace("\r", "");
            firebaseSetting.setPrivateKey(privateKeyJson);
        } catch (IOException e) {
            log.error("‚ùå Erreur de lecture du fichier Firebase private key: {}", e.getMessage());
            throw new RuntimeException("Could not load Firebase service account key.", e);
        }

        firebaseSettingRepository.save(firebaseSetting)
            .doOnSuccess(fs -> log.info("‚úÖ Template Firebase cr√©√©/mis √† jour."))
            .doOnError(e -> log.error("‚ùå √âchec cr√©ation/mise √† jour Firebase: {}", e.getMessage()))
            .block();

        // 3.3 Cr√©ation du Design de l'email OTP
        DesignTemplate designOtp = new DesignTemplate();
        designOtp.setId(designEmailOtpId);
        designOtp.setOrganizationId(sysOrgId);
        designOtp.setTitle("Email OTP");
        designOtp.setSubject("Votre code de v√©rification : [[${otpCode}]]");
        designOtp.setHtml("<!DOCTYPE html><html xmlns:th=\"http://www.thymeleaf.org\"><body><h1>Bonjour [[${firstName}]],</h1><p>Votre code de v√©rification est :</p><h2 style='color: #007AFF;'>[[${otpCode}]]</h2></body></html>");

        designTemplateRepository.save(designOtp)
            .doOnSuccess(dt -> log.info("‚úÖ DesignTemplate (OTP) cr√©√©/mis √† jour."))
            .doOnError(e -> log.error("‚ùå √âchec cr√©ation/mise √† jour DesignTemplate (OTP): {}", e.getMessage()))
            .block();

        // 3.4 Cr√©ation de l'EmailTemplate (R√®gle d'envoi OTP)
        EmailTemplate emailOtpTemplate = new EmailTemplate();
        emailOtpTemplate.setId(templateEmailOtpId);
        emailOtpTemplate.setOrganizationId(sysOrgId);
        emailOtpTemplate.setSettingId(smtpSettingId);
        emailOtpTemplate.setDesignTemplateId(designEmailOtpId);
        emailOtpTemplate.setTitle("R√®gle envoi OTP");

        emailTemplateRepository.save(emailOtpTemplate)
            .doOnSuccess(et -> log.info("‚úÖ EmailTemplate (OTP) cr√©√©/mis √† jour."))
            .doOnError(e -> log.error("‚ùå √âchec cr√©ation/mise √† jour EmailTemplate (OTP): {}", e.getMessage()))
            .block();

        PushTemplate pushNewPlanning = new PushTemplate();
        pushNewPlanning.setId(templatePushNewPlanningId);
        pushNewPlanning.setOrganizationId(sysOrgId);
        pushNewPlanning.setSettingId(firebaseSettingId);
        pushNewPlanning.setTitle("Nouveau planning disponible !");
        pushNewPlanning.setBody("Le chauffeur {{driverName}} propose un trajet vers {{destination}} √† {{cost}} FCFA.");
        pushTemplateRepository.save(pushNewPlanning)
            .doOnSuccess(pt -> log.info("‚úÖ PushTemplate (New Planning) cr√©√©/mis √† jour."))
            .doOnError(e -> log.error("‚ùå √âchec cr√©ation/mise √† jour PushTemplate (New Planning): {}", e.getMessage()))
            .block();

        PushTemplate pushNewAnnouncement = new PushTemplate();
        pushNewAnnouncement.setId(templatePushNewAnnouncementId);
        pushNewAnnouncement.setOrganizationId(sysOrgId);
        pushNewAnnouncement.setSettingId(firebaseSettingId);
        pushNewAnnouncement.setTitle("Nouvelle course client !");
        pushNewAnnouncement.setBody("Un client a post√© un nouveau trajet : {{tripTitle}}");
        pushTemplateRepository.save(pushNewAnnouncement)
            .doOnSuccess(pt -> log.info("‚úÖ PushTemplate (New Announcement) cr√©√©/mis √† jour."))
            .doOnError(e -> log.error("‚ùå √âchec cr√©ation/mise √† jour PushTemplate (New Announcement): {}", e.getMessage()))
            .block();

        PushTemplate pushAnnouncementAccepted = new PushTemplate();
        pushAnnouncementAccepted.setId(templatePushAnnouncementAcceptedId);
        pushAnnouncementAccepted.setOrganizationId(sysOrgId);
        pushAnnouncementAccepted.setSettingId(firebaseSettingId);
        pushAnnouncementAccepted.setTitle("Votre course a un chauffeur !");
        pushAnnouncementAccepted.setBody("Le chauffeur {{driverName}} a postul√© pour votre trajet \"{{tripTitle}}\". Appuyez pour accepter.");
        pushTemplateRepository.save(pushAnnouncementAccepted)
            .doOnSuccess(pt -> log.info("‚úÖ PushTemplate (Announcement Accepted - Postulation) cr√©√©/mis √† jour."))
            .doOnError(e -> log.error("‚ùå √âchec cr√©ation/mise √† jour PushTemplate (Announcement Accepted - Postulation): {}", e.getMessage()))
            .block();

        PushTemplate pushAnnouncementConfirmed = new PushTemplate();
        pushAnnouncementConfirmed.setId(templatePushAnnouncementConfirmedId);
        pushAnnouncementConfirmed.setOrganizationId(sysOrgId);
        pushAnnouncementConfirmed.setSettingId(firebaseSettingId);
        pushAnnouncementConfirmed.setTitle("F√©licitations ! Votre postulation a √©t√© accept√©e !");
        pushAnnouncementConfirmed.setBody("Le client {{clientName}} a confirm√© votre postulation pour le trajet \"{{tripTitle}}\". La course est en cours !");
        pushTemplateRepository.save(pushAnnouncementConfirmed)
            .doOnSuccess(pt -> log.info("‚úÖ PushTemplate (Announcement Confirmed - Chauffeur) cr√©√©/mis √† jour."))
            .doOnError(e -> log.error("‚ùå √âchec cr√©ation/mise √† jour PushTemplate (Announcement Confirmed - Chauffeur): {}", e.getMessage()))
            .block();

        PushTemplate pushPostulationCancelled = new PushTemplate();
        pushPostulationCancelled.setId(templatePushPostulationCancelledId);
        pushPostulationCancelled.setOrganizationId(sysOrgId);
        pushPostulationCancelled.setSettingId(firebaseSettingId);
        pushPostulationCancelled.setTitle("Annulation de postulation !");
        pushPostulationCancelled.setBody("Le chauffeur {{driverName}} a annul√© sa postulation pour votre annonce \"{{tripTitle}}\". L'annonce est de nouveau publi√©e.");
        pushTemplateRepository.save(pushPostulationCancelled)
            .doOnSuccess(pt -> log.info("‚úÖ PushTemplate (Postulation Cancelled) cr√©√©/mis √† jour."))
            .doOnError(e -> log.error("‚ùå √âchec cr√©ation/mise √† jour PushTemplate (Postulation Cancelled): {}", e.getMessage()))
            .block();

        // NOUVEAU : Template pour la notification au CHAUFFEUR quand le client DEMANDE √† r√©server son planning
        PushTemplate pushPlanningBookingRequestedToDriver = new PushTemplate();
        pushPlanningBookingRequestedToDriver.setId(templatePushPlanningBookingRequestedToDriverId);
        pushPlanningBookingRequestedToDriver.setOrganizationId(sysOrgId);
        pushPlanningBookingRequestedToDriver.setSettingId(firebaseSettingId);
        pushPlanningBookingRequestedToDriver.setTitle("Demande de r√©servation re√ßue !");
        pushPlanningBookingRequestedToDriver.setBody("Le client {{clientName}} souhaite r√©server votre planning \"{{tripTitle}}\". Appuyez pour accepter ou refuser.");
        pushTemplateRepository.save(pushPlanningBookingRequestedToDriver)
            .doOnSuccess(pt -> log.info("‚úÖ PushTemplate (Planning Booking Requested To Driver) cr√©√©/mis √† jour."))
            .doOnError(e -> log.error("‚ùå √âchec cr√©ation/mise √† jour PushTemplate (Planning Booking Requested To Driver): {}", e.getMessage()))
            .block();

        // NOUVEAU : Template pour la notification au CLIENT quand le chauffeur ACCEPTE sa demande de r√©servation de planning
        PushTemplate pushPlanningBookingAcceptedToClient = new PushTemplate();
        pushPlanningBookingAcceptedToClient.setId(templatePushPlanningBookingAcceptedToClientId);
        pushPlanningBookingAcceptedToClient.setOrganizationId(sysOrgId);
        pushPlanningBookingAcceptedToClient.setSettingId(firebaseSettingId);
        pushPlanningBookingAcceptedToClient.setTitle("Votre r√©servation a √©t√© accept√©e !");
        pushPlanningBookingAcceptedToClient.setBody("Le chauffeur {{driverName}} a accept√© votre demande de r√©servation pour le planning \"{{tripTitle}}\". La course est en cours !");
        pushTemplateRepository.save(pushPlanningBookingAcceptedToClient)
            .doOnSuccess(pt -> log.info("‚úÖ PushTemplate (Planning Booking Accepted To Client) cr√©√©/mis √† jour."))
            .doOnError(e -> log.error("‚ùå √âchec cr√©ation/mise √† jour PushTemplate (Planning Booking Accepted To Client): {}", e.getMessage()))
            .block();

        // NOUVEAU : Template pour la notification au CHAUFFEUR quand le client ANNULE sa r√©servation de planning
        PushTemplate pushPlanningReservationCancelled = new PushTemplate();
        pushPlanningReservationCancelled.setId(templatePushPlanningReservationCancelledId);
        pushPlanningReservationCancelled.setOrganizationId(sysOrgId);
        pushPlanningReservationCancelled.setSettingId(firebaseSettingId);
        pushPlanningReservationCancelled.setTitle("R√©servation de planning annul√©e !");
        pushPlanningReservationCancelled.setBody("Le client {{clientName}} a annul√© sa r√©servation pour votre planning \"{{tripTitle}}\". Le planning est de nouveau publi√©.");
        pushTemplateRepository.save(pushPlanningReservationCancelled)
            .doOnSuccess(pt -> log.info("‚úÖ PushTemplate (Planning Reservation Cancelled) cr√©√©/mis √† jour."))
            .doOnError(e -> log.error("‚ùå √âchec cr√©ation/mise √† jour PushTemplate (Planning Reservation Cancelled): {}", e.getMessage()))
            .block();

        log.info("\nüéâ --- INITIALISATION INTERNE TERMIN√âE ---");
    }

    private UUID getUuidFromEnv(String key) {
        String value = dotenv.get(key);
        if (value == null || value.isEmpty()) {
            log.error("‚ùå Variable d'environnement UUID '{}' non trouv√©e ou vide dans .env ou les variables syst√®me. L'initialisation va √©chouer.", key);
            throw new IllegalStateException("Missing or empty UUID environment variable: " + key);
        }
        try {
            return UUID.fromString(value);
        } catch (IllegalArgumentException e) {
            log.error("‚ùå La valeur '{}' pour la variable d'environnement '{}' n'est pas un UUID valide. L'initialisation va √©chouer.", value, key);
            throw new IllegalStateException("Invalid UUID format for environment variable: " + key, e);
        }
    }
}

// END OF FILE: src/main/java/com/freelance/driver_backend/initializer/ApplicationInitializer.java

//---> PATH: /home/mbogneng-junior/freelance-driver_Sylladb/backend/src/main/java/com/freelance/driver_backend/model/AnnouncementStatus.java

package com.freelance.driver_backend.model;

public enum AnnouncementStatus {
    DRAFT, // Annonce cr√©√©e mais pas encore visible
    PUBLISHED, // Annonce visible pour les chauffeurs ou Planning visible pour les clients
    PENDING_CONFIRMATION, // Un chauffeur a postul√©, en attente de la confirmation du client (pour ANNONCE)
    PENDING_DRIVER_CONFIRMATION, // Un client a demand√© une r√©servation, en attente de la confirmation du chauffeur (pour PLANNING)
    CONFIRMED, // Le client a confirm√© le chauffeur (pour ANNONCE) ou le planning est confirm√© (pour PLANNING) - note: CONFIRMED est souvent une √©tape avant ONGOING
    ONGOING, // La course est en cours
    TERMINATED, // La course est termin√©e
    CANCELLED // La course est annul√©e
}// END OF FILE: src/main/java/com/freelance/driver_backend/model/AnnouncementStatus.java

//---> PATH: /home/mbogneng-junior/freelance-driver_Sylladb/backend/src/main/java/com/freelance/driver_backend/model/ClientProfile.java

package com.freelance.driver_backend.model;

import lombok.Data;
import org.springframework.data.cassandra.core.mapping.Column;
import org.springframework.data.cassandra.core.mapping.PrimaryKey;
import org.springframework.data.cassandra.core.mapping.Table;
import java.util.UUID;
import org.springframework.data.cassandra.core.mapping.Indexed;

@Table("client_profiles")
@Data
public class ClientProfile {
    @PrimaryKey
    private UUID id;

    @Indexed
    @Column("user_id")
    private UUID userId;

    @Column("organisation_id")
    private UUID organisationId;

    @Column("profile_image_url")
    private String profileImageUrl;

    // Informations de l'entreprise
    @Column("company_name")
    private String companyName;

    // Informations du contact principal
    @Column("first_name")
    private String firstName;

    @Column("last_name")
    private String lastName;

    @Column("nickname")
    private String nickname;

    @Column("contact_email")
    private String contactEmail;

    @Column("phone_number")
    private String phoneNumber;

    // Informations personnelles additionnelles
    @Column("birth_date")
    private String birthDate;

    @Column("nationality")
    private String nationality;

    @Column("gender")
    private String gender;

    @Column("language")
    private String language;
}// END OF FILE: src/main/java/com/freelance/driver_backend/model/ClientProfile.java

//---> PATH: /home/mbogneng-junior/freelance-driver_Sylladb/backend/src/main/java/com/freelance/driver_backend/model/DesignTemplate.java

package com.freelance.driver_backend.model;

import lombok.Data;
import org.springframework.data.cassandra.core.mapping.Column;
import org.springframework.data.cassandra.core.mapping.PrimaryKey;
import org.springframework.data.cassandra.core.mapping.Table;
import java.util.UUID;

@Table("design_templates")
@Data
public class DesignTemplate {
    @PrimaryKey
    private UUID id;
    @Column("organization_id")
    private UUID organizationId;
    private String title;
    private String html;
    private String subject;
}// END OF FILE: src/main/java/com/freelance/driver_backend/model/DesignTemplate.java

//---> PATH: /home/mbogneng-junior/freelance-driver_Sylladb/backend/src/main/java/com/freelance/driver_backend/model/DeviceToken.java

package com.freelance.driver_backend.model;

import lombok.Data;
import org.springframework.data.cassandra.core.cql.PrimaryKeyType;
import org.springframework.data.cassandra.core.mapping.Column;
import org.springframework.data.cassandra.core.mapping.PrimaryKeyColumn;
import org.springframework.data.cassandra.core.mapping.Table;
import java.util.UUID;

@Table("device_tokens")
@Data
public class DeviceToken {

    @PrimaryKeyColumn(name = "user_id", ordinal = 0, type = PrimaryKeyType.PARTITIONED)
    @Column("user_id")
    private UUID userId;

    @PrimaryKeyColumn(name = "device_token", ordinal = 1, type = PrimaryKeyType.CLUSTERED)
    @Column("device_token")
    private String token;
}// END OF FILE: src/main/java/com/freelance/driver_backend/model/DeviceToken.java

//---> PATH: /home/mbogneng-junior/freelance-driver_Sylladb/backend/src/main/java/com/freelance/driver_backend/model/DriverProfile.java

package com.freelance.driver_backend.model;

import org.springframework.data.cassandra.core.mapping.Column;
import org.springframework.data.cassandra.core.mapping.PrimaryKey;
import org.springframework.data.cassandra.core.mapping.Table;
import org.springframework.data.cassandra.core.mapping.Indexed;
import java.util.UUID;
import lombok.Data;

@Table("driver_profiles")
@Data
public class DriverProfile {

    @PrimaryKey
    private UUID id;

    @Indexed
    @Column("user_id")
    private UUID userId;

    @Column("organisation_id")
    private UUID organisationId;

    @Column("first_name")
    private String firstName;

    @Column("last_name")
    private String lastName;

    @Column("phone_number")
    private String phoneNumber;

    @Column("license_number")
    private String licenseNumber;

    @Column("vehicle_details")
    private String vehicleDetails;

    @Column("profile_image_url")
    private String profileImageUrl;

    @Column("nickname")
    private String nickname;
    @Column("birth_date")
    private String birthDate; // On garde en String pour la simplicit√©
    @Column("nationality")
    private String nationality;
    @Column("gender")
    private String gender;
    @Column("language")
    private String language;
    @Column("biography")
    private String biography;
}
// END OF FILE: src/main/java/com/freelance/driver_backend/model/DriverProfile.java

//---> PATH: /home/mbogneng-junior/freelance-driver_Sylladb/backend/src/main/java/com/freelance/driver_backend/model/EmailTemplate.java

package com.freelance.driver_backend.model;

import com.fasterxml.jackson.annotation.JsonProperty; // <-- AJOUTER CET IMPORT
import lombok.Data;
import org.springframework.data.cassandra.core.mapping.Column;
import org.springframework.data.cassandra.core.mapping.PrimaryKey;
import org.springframework.data.cassandra.core.mapping.Table;
import java.util.UUID;

@Table("email_templates")
@Data
public class EmailTemplate {
    @PrimaryKey
    private UUID id;
    
    @Column("organization_id")
    @JsonProperty("organization_id")
    private UUID organizationId;
    
    @Column("setting_id")
    @JsonProperty("setting_id") // <-- CORRECTION ICI
    private UUID settingId;
    
    @Column("design_template_id")
    @JsonProperty("design_template_id") // <-- CORRECTION ICI
    private UUID designTemplateId;
    
    private String title;
}// END OF FILE: src/main/java/com/freelance/driver_backend/model/EmailTemplate.java

//---> PATH: /home/mbogneng-junior/freelance-driver_Sylladb/backend/src/main/java/com/freelance/driver_backend/model/FirebaseSetting.java

package com.freelance.driver_backend.model;

import lombok.Data;
import org.springframework.data.cassandra.core.mapping.*;
import java.util.UUID;

@Table("firebase_settings")
@Data
public class FirebaseSetting {
    @PrimaryKey
    private UUID id;
    @Column("organization_id")
    private UUID organizationId;
    @Column("project_id")
    private String projectId;
    @Column("private_key")
    private String privateKey; // Stocker le JSON de la cl√© de service
}// END OF FILE: src/main/java/com/freelance/driver_backend/model/FirebaseSetting.java

//---> PATH: /home/mbogneng-junior/freelance-driver_Sylladb/backend/src/main/java/com/freelance/driver_backend/model/mock/MockOrganisation.java

package com.freelance.driver_backend.model.mock; // <-- V√©rifiez ce package

import lombok.Data;
import org.springframework.data.cassandra.core.mapping.*;
import java.util.UUID;

@Table("mock_organisations") // <-- V√©rifiez le nom de la table
@Data
public class MockOrganisation {
    @PrimaryKey
    @Column("organization_id")
    private UUID organizationId;

    @Column("long_name")
    private String longName;

    private String description;

    @Indexed
    @Column("owner_user_id")
    private UUID ownerUserId;
}// END OF FILE: src/main/java/com/freelance/driver_backend/model/mock/MockOrganisation.java

//---> PATH: /home/mbogneng-junior/freelance-driver_Sylladb/backend/src/main/java/com/freelance/driver_backend/model/mock/MockUser.java

// Fichier : src/main/java/com/freelance/driver_backend/model/mock/MockUser.java
package com.freelance.driver_backend.model.mock;

import lombok.Data;
import org.springframework.data.cassandra.core.cql.Ordering;
import org.springframework.data.cassandra.core.cql.PrimaryKeyType;
import org.springframework.data.cassandra.core.mapping.*;

import java.util.UUID;

@Table("mock_users")
@Data
public class MockUser {
    @PrimaryKey
    private UUID id;

    @Indexed // Permet de chercher rapidement par email
    private String email;
    
    private String username;
    private String password; // ATTENTION: En DEV seulement, ne jamais stocker de mdp en clair en prod.
    
    @Column("first_name")
    private String firstName;
    
    @Column("last_name")
    private String lastName;
    
    @Column("phone_number")
    private String phoneNumber;

    // IMPORTANT : On ajoute une colonne pour savoir √† quelle organisation cet utilisateur est li√©.
    @Column("organisation_id")
    private UUID organisationId;
}// END OF FILE: src/main/java/com/freelance/driver_backend/model/mock/MockUser.java

//---> PATH: /home/mbogneng-junior/freelance-driver_Sylladb/backend/src/main/java/com/freelance/driver_backend/model/OtpVerification.java

package com.freelance.driver_backend.model;

import lombok.Data;
import org.springframework.data.cassandra.core.mapping.PrimaryKey;
import org.springframework.data.cassandra.core.mapping.Table;

import java.time.Instant;

@Table("otp_verifications")
@Data
public class OtpVerification {
    @PrimaryKey // L'email de l'utilisateur est la cl√© unique
    private String email;
    
    private String otpCode;
    
    private Instant expiresAt;
}// END OF FILE: src/main/java/com/freelance/driver_backend/model/OtpVerification.java

//---> PATH: /home/mbogneng-junior/freelance-driver_Sylladb/backend/src/main/java/com/freelance/driver_backend/model/Product.java

// src/main/java/com/freelance/driver_backend/model/Product.java

package com.freelance.driver_backend.model;

import lombok.Data;
import org.springframework.data.cassandra.core.mapping.Column;
import org.springframework.data.cassandra.core.mapping.Indexed;
import org.springframework.data.cassandra.core.mapping.PrimaryKey;
import org.springframework.data.cassandra.core.mapping.Table;
import java.math.BigDecimal;
import java.util.Map;
import java.util.UUID;

import org.springframework.data.annotation.Transient;

@Table("products")
@Data
public class Product {
    @PrimaryKey
    private ProductKey key;

    // --- Champs Communs ---
    private String name; // Utilis√© pour le titre de l'annonce/planning, le mod√®le du v√©hicule, le titre de l'adresse...
    
    @Column("short_description")
    private String shortDescription; // Utilis√© pour les bagages, la description du v√©hicule, le code postal...
    
    @Indexed
    @Column("category_id")
    private UUID categoryId; // L'identifiant qui distingue un v√©hicule d'une annonce, etc.
    
    @Column("is_active")
    private Boolean isActive;

    @Column("status")
    private String status; // Draft, Published, Confirmed, Terminated, METADATA, etc.
    
    @Column("default_sell_price")
    private BigDecimal defaultSellPrice; // Co√ªt de la course, etc.

    // --- Champs Sp√©cifiques au Trajet (Annonces & Plannings) ---
    @Column("pickup_location")
    private String pickupLocation;
    
    @Column("dropoff_location")
    private String dropoffLocation;
    
    @Column("start_date")
    private String startDate;
    
    @Column("start_time")
    private String startTime;

    @Column("end_date")
    private String endDate;

    @Column("end_time")
    private String endTime;

    @Column("baggage_info")
    private String baggageInfo;
    
    @Column("is_negotiable")
    private Boolean isNegotiable;
    
    @Column("payment_method")
    private String paymentMethod;
    
    // --- Info sur l'Auteur (client ou conducteur) ---
    @Indexed
    @Column("client_id")
    private UUID clientId; // L'ID de l'utilisateur qui a cr√©√© ce "produit"
    
    @Column("client_name")
    private String clientName;

    @Column("client_phone_number")
    private String clientPhoneNumber;

    @Column("client_profile_image_url")
    private String clientProfileImageUrl; // Utilis√© pour l'avatar de l'auteur, ou la photo principale du v√©hicule

    // --- Info sur la R√©servation ---
    @Indexed
    @Column("reserved_by_driver_id")
    private UUID reservedByDriverId; // ID du chauffeur (pour une annonce) ou du client (pour un planning)

    @Column("reserved_by_driver_name")
    private String reservedByDriverName;

    // --- Stockage flexible pour les champs non-standards ---
    @Column("metadata") 
    private Map<String, String> metadata; // Pour les d√©tails du v√©hicule, les options de paiement du planning, etc.

    // --- Champs Transitoires pour l'enrichissement ---
    @Transient
    private UUID authorId;
    @Transient
    private String authorName;
    @Transient
    private String authorPhoneNumber;
    @Transient
    private String authorProfileImageUrl;


    // --- M√©thodes d'acc√®s pratiques ---
    public UUID getId() { return this.key != null ? this.key.getId() : null; }
    public UUID getOrganizationId() { return this.key != null ? this.key.getOrganizationId() : null; }
}// END OF FILE: src/main/java/com/freelance/driver_backend/model/Product.java

//---> PATH: /home/mbogneng-junior/freelance-driver_Sylladb/backend/src/main/java/com/freelance/driver_backend/model/ProductKey.java

package com.freelance.driver_backend.model;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;
import org.springframework.data.cassandra.core.cql.PrimaryKeyType;
import org.springframework.data.cassandra.core.mapping.PrimaryKeyClass;
import org.springframework.data.cassandra.core.mapping.PrimaryKeyColumn;
import java.io.Serializable;
import java.util.UUID;

@PrimaryKeyClass
@Data
@AllArgsConstructor
@NoArgsConstructor
public class ProductKey implements Serializable {
    @PrimaryKeyColumn(name = "organization_id", ordinal = 0, type = PrimaryKeyType.PARTITIONED)
    private UUID organizationId;

    @PrimaryKeyColumn(name = "id", ordinal = 1, type = PrimaryKeyType.CLUSTERED)
    private UUID id;
}// END OF FILE: src/main/java/com/freelance/driver_backend/model/ProductKey.java

//---> PATH: /home/mbogneng-junior/freelance-driver_Sylladb/backend/src/main/java/com/freelance/driver_backend/model/PushTemplate.java

package com.freelance.driver_backend.model;

import lombok.Data;
import org.springframework.data.cassandra.core.mapping.*;
import java.util.UUID;

@Table("push_templates")
@Data
public class PushTemplate {
    @PrimaryKey
    private UUID id;
    @Column("organization_id")
    private UUID organizationId;
    @Column("setting_id")
    private UUID settingId; // Lien vers FirebaseSetting
    private String title;   // Ex: "Nouvelle course disponible !"
    private String body;    // Ex: "Acceptez la course de {{clientName}} pour {{destination}}."
}// END OF FILE: src/main/java/com/freelance/driver_backend/model/PushTemplate.java

//---> PATH: /home/mbogneng-junior/freelance-driver_Sylladb/backend/src/main/java/com/freelance/driver_backend/model/Resource.java


package com.freelance.driver_backend.model;

import com.fasterxml.jackson.annotation.JsonAlias;
import com.fasterxml.jackson.annotation.JsonProperty;
import lombok.Data;
import org.springframework.data.cassandra.core.mapping.Column;
import org.springframework.data.cassandra.core.mapping.PrimaryKey;
import org.springframework.data.cassandra.core.mapping.Table;

import java.math.BigDecimal;
import org.springframework.data.annotation.Transient;
import java.time.Instant;
import java.util.Map; // Ajout de l'import
import java.util.UUID;

@Table("resources")
@Data
public class Resource {

@PrimaryKey
private ResourceKey key;

private String name;

// =====================================================================
//                         CORRECTION PRINCIPALE
// =====================================================================
// @JsonProperty est pour la SORTIE (Java -> JSON)
// @JsonAlias est pour l'ENTR√âE (JSON -> Java). Il permet plusieurs noms pour un m√™me champ.

@Column("short_description")
@JsonProperty("short_description")
@JsonAlias("baggageInfo") // Accepte "baggageInfo" en entr√©e
private String shortDescription;

@Column("long_description")
@JsonProperty("long_description")
@JsonAlias("dropoffLocation") // Accepte "dropoffLocation" en entr√©e
private String longDescription;

@Column("storage_condition")
@JsonProperty("storage_condition")
@JsonAlias("pickupLocation") // Accepte "pickupLocation" en entr√©e
private String storageCondition;

@Column("base_price")
@JsonProperty("base_price")
@JsonAlias("cost") // Accepte "cost" en entr√©e
private BigDecimal basePrice;

@Column("sku_code")
@JsonProperty("sku_code")
@JsonAlias("paymentMethod") // Accepte "paymentMethod" en entr√©e
private String skuCode;

@Column("expires_at")
@JsonProperty("expires_at")
@JsonAlias("expiresAt") // Accepte "expiresAt" en entr√©e
private Instant expiresAt;

// --- Champs restants ---
private String state;

@Column("product_type")
@JsonProperty("product_type")
private String productType;

private String accessibility;

@Column("iot_number")
@JsonProperty("iot_number")
private String iotNumber;

@Column("available_quantity")
@JsonProperty("available_quantity")
private Integer availableQuantity;

@Column("is_tangible")
@JsonProperty("is_tangible")
private boolean isTangible;

@Column("created_at")
@JsonProperty("created_at")
private Instant createdAt;

@Column("updated_at")
@JsonProperty("updated_at")
private Instant updatedAt;

@Transient 
private Map<String, String> metadata;   


// M√©thodes utilitaires (inchang√©es)
public UUID getResourceId() { return this.key != null ? this.key.getResourceId() : null; }
public UUID getOrganizationId() { return this.key != null ? this.key.getOrganizationId() : null; }
public String getCategoryId() { return this.key != null ? this.key.getCategoryId() : null; }
public void setResourceId(UUID id) { if(this.key == null) this.key = new ResourceKey(); this.key.setResourceId(id); }
public void setOrganizationId(UUID id) { if(this.key == null) this.key = new ResourceKey(); this.key.setOrganizationId(id); }
public void setCategoryId(String id) { if(this.key == null) this.key = new ResourceKey(); this.key.setCategoryId(id); }
}// END OF FILE: src/main/java/com/freelance/driver_backend/model/Resource.java

//---> PATH: /home/mbogneng-junior/freelance-driver_Sylladb/backend/src/main/java/com/freelance/driver_backend/model/ResourceKey.java

package com.freelance.driver_backend.model;

import lombok.Data;
import org.springframework.data.cassandra.core.cql.Ordering;
import org.springframework.data.cassandra.core.cql.PrimaryKeyType;
import org.springframework.data.cassandra.core.mapping.PrimaryKeyClass;
import org.springframework.data.cassandra.core.mapping.PrimaryKeyColumn;

import java.io.Serializable;
import java.util.UUID;

@PrimaryKeyClass
@Data
public class ResourceKey implements Serializable {

    @PrimaryKeyColumn(name = "organization_id", ordinal = 0, type = PrimaryKeyType.PARTITIONED)
    private UUID organizationId;

    @PrimaryKeyColumn(name = "category_id", ordinal = 1, type = PrimaryKeyType.CLUSTERED)
    private String categoryId;

    @PrimaryKeyColumn(name = "resource_id", ordinal = 2, type = PrimaryKeyType.CLUSTERED, ordering = Ordering.DESCENDING)
    private UUID resourceId;
}// END OF FILE: src/main/java/com/freelance/driver_backend/model/ResourceKey.java

//---> PATH: /home/mbogneng-junior/freelance-driver_Sylladb/backend/src/main/java/com/freelance/driver_backend/model/Review.java

package com.freelance.driver_backend.model;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;
import org.springframework.data.cassandra.core.mapping.PrimaryKey;
import org.springframework.data.cassandra.core.mapping.Table;
import java.util.UUID;

@Table("reviews")
@Data
@NoArgsConstructor
@AllArgsConstructor
public class Review {

    @PrimaryKey
    private UUID id;

    private UUID targetUserId; // L'utilisateur qui est not√©
    private UUID authorId;     // L'utilisateur qui a √©crit la note
    private String authorFirstName;
    private String authorLastName;
    private String authorProfileImageUrl;
    private int score;
    private String comment;
    private long createdAt;
}
// END OF FILE: src/main/java/com/freelance/driver_backend/model/Review.java

//---> PATH: /home/mbogneng-junior/freelance-driver_Sylladb/backend/src/main/java/com/freelance/driver_backend/model/SmtpSetting.java

package com.freelance.driver_backend.model;

import com.fasterxml.jackson.annotation.JsonProperty; // <-- AJOUTER CET IMPORT
import lombok.Data;
import org.springframework.data.cassandra.core.mapping.Column;
import org.springframework.data.cassandra.core.mapping.PrimaryKey;
import org.springframework.data.cassandra.core.mapping.Table;
import java.util.UUID;

@Table("smtp_settings")
@Data
public class SmtpSetting {
    @PrimaryKey
    private UUID id;
    
    @Column("organization_id")
    @JsonProperty("organization_id") // Pour la sortie JSON
    private UUID organizationId;
    
    private String host;
    private int port;
    private String encryption;
    private String username;
    private String password;
    
    @Column("sender_email")
    @JsonProperty("sender_email") // <-- CORRECTION ICI
    private String senderEmail;
    
    @Column("sender_name")
    @JsonProperty("sender_name") // <-- CORRECTION ICI
    private String senderName;
}// END OF FILE: src/main/java/com/freelance/driver_backend/model/SmtpSetting.java

//---> PATH: /home/mbogneng-junior/freelance-driver_Sylladb/backend/src/main/java/com/freelance/driver_backend/repository/ClientProfileRepository.java

package com.freelance.driver_backend.repository;

import com.freelance.driver_backend.model.ClientProfile;


import reactor.core.publisher.Mono;

import org.springframework.data.cassandra.repository.ReactiveCassandraRepository;
import org.springframework.stereotype.Repository;
import java.util.UUID;

@Repository
public interface ClientProfileRepository extends ReactiveCassandraRepository<ClientProfile, UUID> {

    // AJOUT DE CETTE M√âTHODE
    // Spring Data comprendra automatiquement qu'il faut chercher sur la colonne "user_id"
    Mono<ClientProfile> findByUserId(UUID userId);
}
// END OF FILE: src/main/java/com/freelance/driver_backend/repository/ClientProfileRepository.java

//---> PATH: /home/mbogneng-junior/freelance-driver_Sylladb/backend/src/main/java/com/freelance/driver_backend/repository/DesignTemplateRepository.java

package com.freelance.driver_backend.repository;

import com.freelance.driver_backend.model.DesignTemplate;
import org.springframework.data.cassandra.repository.ReactiveCassandraRepository;
import java.util.UUID;

public interface DesignTemplateRepository extends ReactiveCassandraRepository<DesignTemplate, UUID> {}// END OF FILE: src/main/java/com/freelance/driver_backend/repository/DesignTemplateRepository.java

//---> PATH: /home/mbogneng-junior/freelance-driver_Sylladb/backend/src/main/java/com/freelance/driver_backend/repository/DeviceTokenRepository.java

package com.freelance.driver_backend.repository;

import com.freelance.driver_backend.model.DeviceToken;
import org.springframework.data.cassandra.repository.ReactiveCassandraRepository;
import org.springframework.stereotype.Repository;
import reactor.core.publisher.Flux;
import java.util.UUID;

@Repository
public interface DeviceTokenRepository extends ReactiveCassandraRepository<DeviceToken, UUID> {
    Flux<DeviceToken> findByUserId(UUID userId);
}// END OF FILE: src/main/java/com/freelance/driver_backend/repository/DeviceTokenRepository.java

//---> PATH: /home/mbogneng-junior/freelance-driver_Sylladb/backend/src/main/java/com/freelance/driver_backend/repository/DriverProfileRepository.java

package com.freelance.driver_backend.repository;

import com.freelance.driver_backend.model.DriverProfile;

import reactor.core.publisher.Mono;

import org.springframework.data.cassandra.repository.ReactiveCassandraRepository;
import org.springframework.stereotype.Repository;
import java.util.UUID;

@Repository
public interface DriverProfileRepository extends ReactiveCassandraRepository<DriverProfile, UUID> {


    // AJOUT DE CETTE M√âTHODE
    // Spring Data comprendra automatiquement qu'il faut chercher sur la colonne "user_id"
    Mono<DriverProfile> findByUserId(UUID userId);
}// END OF FILE: src/main/java/com/freelance/driver_backend/repository/DriverProfileRepository.java

//---> PATH: /home/mbogneng-junior/freelance-driver_Sylladb/backend/src/main/java/com/freelance/driver_backend/repository/EmailTemplateRepository.java

package com.freelance.driver_backend.repository;

import com.freelance.driver_backend.model.EmailTemplate;
import org.springframework.data.cassandra.repository.ReactiveCassandraRepository;
import java.util.UUID;

public interface EmailTemplateRepository extends ReactiveCassandraRepository<EmailTemplate, UUID> {}// END OF FILE: src/main/java/com/freelance/driver_backend/repository/EmailTemplateRepository.java

//---> PATH: /home/mbogneng-junior/freelance-driver_Sylladb/backend/src/main/java/com/freelance/driver_backend/repository/FirebaseSettingRepository.java

package com.freelance.driver_backend.repository;

import com.freelance.driver_backend.model.FirebaseSetting;
import org.springframework.data.cassandra.repository.ReactiveCassandraRepository;
import java.util.UUID;

public interface FirebaseSettingRepository extends ReactiveCassandraRepository<FirebaseSetting, UUID> {}// END OF FILE: src/main/java/com/freelance/driver_backend/repository/FirebaseSettingRepository.java

//---> PATH: /home/mbogneng-junior/freelance-driver_Sylladb/backend/src/main/java/com/freelance/driver_backend/repository/mock/MockOrganisationRepository.java

package com.freelance.driver_backend.repository.mock;

import com.freelance.driver_backend.model.mock.MockOrganisation;
import org.springframework.data.cassandra.repository.ReactiveCassandraRepository;
import reactor.core.publisher.Flux;
import java.util.UUID;

public interface MockOrganisationRepository extends ReactiveCassandraRepository<MockOrganisation, UUID> {
    Flux<MockOrganisation> findByOwnerUserId(UUID ownerUserId);
}// END OF FILE: src/main/java/com/freelance/driver_backend/repository/mock/MockOrganisationRepository.java

//---> PATH: /home/mbogneng-junior/freelance-driver_Sylladb/backend/src/main/java/com/freelance/driver_backend/repository/mock/MockUserCassandraRepository.java

package com.freelance.driver_backend.repository.mock;

import com.freelance.driver_backend.model.mock.MockUser;
import org.springframework.data.cassandra.repository.AllowFiltering;
import org.springframework.data.cassandra.repository.ReactiveCassandraRepository;
import org.springframework.stereotype.Repository;
import reactor.core.publisher.Mono;

import java.util.UUID;

@Repository
public interface MockUserCassandraRepository extends ReactiveCassandraRepository<MockUser, UUID> {
    
    @AllowFiltering
    Mono<MockUser> findByEmail(String email);
    
    @AllowFiltering
    Mono<MockUser> findByUsername(String username);
}// END OF FILE: src/main/java/com/freelance/driver_backend/repository/mock/MockUserCassandraRepository.java

//---> PATH: /home/mbogneng-junior/freelance-driver_Sylladb/backend/src/main/java/com/freelance/driver_backend/repository/mock/MockUserRepository.java

package com.freelance.driver_backend.repository.mock;

import com.freelance.driver_backend.model.mock.MockUser;
import org.springframework.data.cassandra.repository.AllowFiltering;
import org.springframework.data.cassandra.repository.ReactiveCassandraRepository;
import org.springframework.stereotype.Repository;
import reactor.core.publisher.Mono;

import java.util.UUID;

@Repository
public interface MockUserRepository extends ReactiveCassandraRepository<MockUser, UUID> {
    
    @AllowFiltering
    Mono<MockUser> findByEmail(String email);
    
    @AllowFiltering
    Mono<MockUser> findByUsername(String username);
}// END OF FILE: src/main/java/com/freelance/driver_backend/repository/mock/MockUserRepository.java

//---> PATH: /home/mbogneng-junior/freelance-driver_Sylladb/backend/src/main/java/com/freelance/driver_backend/repository/OtpVerificationRepository.java

package com.freelance.driver_backend.repository;

import com.freelance.driver_backend.model.OtpVerification;
import org.springframework.data.cassandra.repository.ReactiveCassandraRepository;
import org.springframework.stereotype.Repository;

@Repository
public interface OtpVerificationRepository extends ReactiveCassandraRepository<OtpVerification, String> {
    // Spring Data se charge de tout, cette interface peut rester vide.
}// END OF FILE: src/main/java/com/freelance/driver_backend/repository/OtpVerificationRepository.java

//---> PATH: /home/mbogneng-junior/freelance-driver_Sylladb/backend/src/main/java/com/freelance/driver_backend/repository/ProductRepository.java

package com.freelance.driver_backend.repository;

import com.freelance.driver_backend.model.Product;
import com.freelance.driver_backend.model.ProductKey;
import org.springframework.data.cassandra.repository.Query;
import org.springframework.data.cassandra.repository.ReactiveCassandraRepository;
import reactor.core.publisher.Flux;
import java.util.UUID;

public interface ProductRepository extends ReactiveCassandraRepository<Product, ProductKey> {

    Flux<Product> findByKeyOrganizationIdAndCategoryId(UUID organizationId, UUID categoryId);

    @Query("SELECT * FROM products WHERE category_id = ?0 ALLOW FILTERING")
    Flux<Product> findByCategoryId(UUID categoryId);
    
    Flux<Product> findByKeyOrganizationId(UUID organizationId);

    @Query("SELECT * FROM products WHERE client_id = ?0 AND category_id = ?1 ALLOW FILTERING")
    Flux<Product> findByClientIdAndCategoryId(UUID clientId, UUID categoryId);
    
    @Query("SELECT * FROM products WHERE reserved_by_driver_id = ?0 ALLOW FILTERING")
    Flux<Product> findByReservedByDriverId(UUID driverId);
}// END OF FILE: src/main/java/com/freelance/driver_backend/repository/ProductRepository.java

//---> PATH: /home/mbogneng-junior/freelance-driver_Sylladb/backend/src/main/java/com/freelance/driver_backend/repository/PushTemplateRepository.java

package com.freelance.driver_backend.repository;

import com.freelance.driver_backend.model.PushTemplate;
import org.springframework.data.cassandra.repository.ReactiveCassandraRepository;
import java.util.UUID;

public interface PushTemplateRepository extends ReactiveCassandraRepository<PushTemplate, UUID> {}// END OF FILE: src/main/java/com/freelance/driver_backend/repository/PushTemplateRepository.java

//---> PATH: /home/mbogneng-junior/freelance-driver_Sylladb/backend/src/main/java/com/freelance/driver_backend/repository/ResourceRepository.java

package com.freelance.driver_backend.repository;

import com.freelance.driver_backend.model.Resource;
import com.freelance.driver_backend.model.ResourceKey; // <-- Import de la nouvelle cl√©
import org.springframework.data.cassandra.repository.Query;
import org.springframework.data.cassandra.repository.ReactiveCassandraRepository;
import org.springframework.stereotype.Repository;
import reactor.core.publisher.Flux;
import java.util.UUID;

@Repository
// Le deuxi√®me param√®tre g√©n√©rique est maintenant ResourceKey
public interface ResourceRepository extends ReactiveCassandraRepository<Resource, ResourceKey> { 
    
    // Cette m√©thode est maintenant beaucoup plus efficace !
    Flux<Resource> findByKeyOrganizationIdAndKeyCategoryId(UUID organizationId, String categoryId);
    
    // On doit ajouter ALLOW FILTERING car category_id n'est pas la cl√© de partition
    @Query("SELECT * FROM resources WHERE category_id = ?0 ALLOW FILTERING")
    Flux<Resource> findByKeyCategoryId(String categoryId);
}// END OF FILE: src/main/java/com/freelance/driver_backend/repository/ResourceRepository.java

//---> PATH: /home/mbogneng-junior/freelance-driver_Sylladb/backend/src/main/java/com/freelance/driver_backend/repository/ReviewRepository.java

package com.freelance.driver_backend.repository;

import com.freelance.driver_backend.model.Review;
import org.springframework.data.cassandra.repository.AllowFiltering;
import org.springframework.data.cassandra.repository.ReactiveCassandraRepository;
import reactor.core.publisher.Flux;
import java.util.UUID;

public interface ReviewRepository extends ReactiveCassandraRepository<Review, UUID> {
    @AllowFiltering
    Flux<Review> findByTargetUserId(UUID targetUserId);
}
// END OF FILE: src/main/java/com/freelance/driver_backend/repository/ReviewRepository.java

//---> PATH: /home/mbogneng-junior/freelance-driver_Sylladb/backend/src/main/java/com/freelance/driver_backend/repository/SmtpSettingRepository.java

package com.freelance.driver_backend.repository;

import com.freelance.driver_backend.model.SmtpSetting;
import org.springframework.data.cassandra.repository.ReactiveCassandraRepository;
import java.util.UUID;

public interface SmtpSettingRepository extends ReactiveCassandraRepository<SmtpSetting, UUID> {}// END OF FILE: src/main/java/com/freelance/driver_backend/repository/SmtpSettingRepository.java

//---> PATH: /home/mbogneng-junior/freelance-driver_Sylladb/backend/src/main/java/com/freelance/driver_backend/service/external/AuthService.java

package com.freelance.driver_backend.service.external;

import com.freelance.driver_backend.dto.external.*;
import reactor.core.publisher.Mono;

/**
 * Interface d√©finissant le contrat pour les interactions avec le service d'authentification externe.
 * Cela permet de d√©coupler la logique m√©tier des impl√©mentations concr√®tes (API r√©elle vs Mock local).
 */
public interface AuthService {

    /**
     * Obtient un token de type Machine-to-Machine (M2M) en utilisant les client credentials.
     * @param clientId L'ID du client OAuth2.
     * @param clientSecret Le secret du client OAuth2.
     * @return Un Mono contenant la r√©ponse avec le token.
     */
    Mono<OAuthTokenResponse> getClientCredentialsToken(String clientId, String clientSecret);

    /**
     * Enregistre un nouvel utilisateur aupr√®s du service d'authentification.
     * @param request Les donn√©es d'inscription de l'utilisateur.
     * @param m2mBearerToken Le token M2M n√©cessaire pour autoriser cette op√©ration.
     * @return Un Mono contenant les informations de l'utilisateur cr√©√©.
     */
   

     Mono<UserDto> registerUser(RegistrationRequest request, String m2mBearerToken);

    /**
     * Connecte un utilisateur pour obtenir un token d'acc√®s personnel.
     * @param request Les identifiants de l'utilisateur.
     * @param m2mBearerToken Le token M2M n√©cessaire pour autoriser cette op√©ration.
     * @return Un Mono contenant la r√©ponse de connexion compl√®te (token, infos utilisateur, etc.).
     */
     Mono<LoginResponse> loginUser(LoginRequest request, String m2mBearerToken);



    
}// END OF FILE: src/main/java/com/freelance/driver_backend/service/external/AuthService.java

//---> PATH: /home/mbogneng-junior/freelance-driver_Sylladb/backend/src/main/java/com/freelance/driver_backend/service/external/AuthServiceWebClientImpl.java

package com.freelance.driver_backend.service.external;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.DeserializationFeature;
import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.freelance.driver_backend.dto.external.*;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.context.annotation.Profile;
import org.springframework.http.HttpStatusCode;
import org.springframework.http.MediaType;
import org.springframework.stereotype.Component;
import org.springframework.util.LinkedMultiValueMap;
import org.springframework.util.MultiValueMap;
import org.springframework.web.reactive.function.BodyInserters;
import org.springframework.web.reactive.function.client.WebClient;
import reactor.core.publisher.Mono;

@Component
@Slf4j
public class AuthServiceWebClientImpl implements AuthService {

    private final WebClient webClient;
    private final WebClient mockWebClient;

    // Le Qualifier pointe toujours vers le Bean d√©fini dans WebClientConfig
    public AuthServiceWebClientImpl(@Qualifier("authServiceWebClient") WebClient webClient,@Qualifier("mockWebClient") WebClient mockWebClient) {
        this.webClient = webClient;
        this.mockWebClient = mockWebClient;
    }

    @Override
    public Mono<OAuthTokenResponse> getClientCredentialsToken(String clientId, String clientSecret) {
        log.info("Requesting M2M token with client_id: {}", clientId);

        MultiValueMap<String, String> formData = new LinkedMultiValueMap<>();
        formData.add("grant_type", "client_credentials");
        formData.add("client_id", clientId);
        formData.add("client_secret", clientSecret);
        formData.add("scope", "read write manage_api");

        return webClient.post()
                .uri("/oauth/token")
                .contentType(MediaType.APPLICATION_FORM_URLENCODED)
                .body(BodyInserters.fromFormData(formData))
                .retrieve()
                .onStatus(HttpStatusCode::isError, response ->
                        response.bodyToMono(String.class)
                                .flatMap(errorBody -> {
                                    log.error("Error obtaining client credentials token: {} - {}", response.statusCode(), errorBody);
                                    return Mono.error(new RuntimeException("Could not obtain M2M token: " + errorBody));
                                })
                )
                .bodyToMono(OAuthTokenResponse.class);
    }


    //On desactive m2m bearer token pour l'instant
    // public Mono<UserDto> registerUser(RegistrationRequest  request,String m2mBearerToken) {
    public Mono<UserDto> registerUser(RegistrationRequest  request, String m2mBearerToken) {
        log.info("√âtape 1: Sending mock registration request for {}", request.getEmail());
        
        return mockWebClient.post()
                .uri("/api/mock_user/register")
                .bodyValue(request)
                .retrieve()
                .onStatus(HttpStatusCode::isError, response ->
                        response.bodyToMono(String.class)
                                .flatMap(errorBody -> {
                                    log.error("Error during mock user registration for {}: {} - {}", 
                                            request.getEmail(), response.statusCode(), errorBody);

                                    String clientErrorMessage = "Mock registration failed with status " + response.statusCode();
                                    
                                    // Log la r√©ponse brute pour le d√©bogage
                                    clientErrorMessage += ": Mock service responded with: " + 
                                            (errorBody != null && !errorBody.isEmpty() ? errorBody : "[Empty or Null Body]");

                                    try {
                                        ObjectMapper mapper = new ObjectMapper();
                                        mapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);
                                        JsonNode root = mapper.readTree(errorBody);

                                        // Extraction de messages d'erreur sp√©cifiques
                                        if (root.has("message") && root.get("message").isTextual()) {
                                            clientErrorMessage = root.get("message").asText();
                                        } else if (root.has("error") && root.get("error").isTextual()) {
                                            clientErrorMessage = root.get("error").asText();
                                        }
                                        
                                        if (root.has("errors") && root.get("errors").isObject()) {
                                            clientErrorMessage += " (Details: " + root.get("errors").toString() + ")";
                                        }
                                        
                                    } catch (JsonProcessingException e) {
                                        log.warn("Could not parse errorBody from mock service as JSON: {}", errorBody, e);
                                    } catch (Exception e) {
                                        log.error("Unexpected error while processing errorBody from mock service: {}", errorBody, e);
                                    }
    
                                    return Mono.error(new RuntimeException(clientErrorMessage));
                                })
                )
                .bodyToMono(UserDto.class);
    }
    
    //On desactive m2m bearer token pour l'instant
    // public Mono<LoginResponse> loginUser(LoginRequest request, String m2mBearerToken) {
    public Mono<LoginResponse> loginUser(LoginRequest request, String m2mBearerToken) {
        log.info("√âtape 2: Sending mock login request for {}", request.getUsername());
        
        return mockWebClient.post()
                .uri("/api/mock_user/login")
                .bodyValue(request)
                .retrieve()
                .onStatus(HttpStatusCode::isError, response ->
                        response.bodyToMono(String.class)
                                .flatMap(errorBody -> {
                                    log.error("HTTP Error during mock login for user {}: {} - {}", 
                                            request.getUsername(), response.statusCode(), errorBody);
                                    return Mono.error(new RuntimeException("Mock login failed with HTTP status: " + response.statusCode()));
                                })
                )
                .bodyToMono(String.class)
                .flatMap(rawBody -> {
                    log.info("Raw JSON response from mock /api/mock_user/login for user {}: {}", 
                            request.getUsername(), rawBody);
                    
                    try {
                        ObjectMapper objectMapper = new ObjectMapper();
                        objectMapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);

                        JsonNode rootNode = objectMapper.readTree(rawBody);
                        
                        // V√©rifier si l'API mock renvoie un statut FAILED
                        if (rootNode.has("status") && "FAILED".equals(rootNode.get("status").asText())) {
                            String errorMessage = rootNode.get("message").asText("Invalid Credentials");
                            log.warn("Mock login failed for user '{}': {}", request.getUsername(), errorMessage);
                            return Mono.empty(); // Retourner un Mono vide pour signaler l'√©chec
                        }

                        // Si succ√®s, parser la r√©ponse compl√®te
                        LoginResponse loginResponse = objectMapper.readValue(rawBody, LoginResponse.class);
                        return Mono.just(loginResponse);

                    } catch (JsonProcessingException e) {
                        log.error("Failed to parse mock login response JSON", e);
                        return Mono.error(new RuntimeException("Failed to parse mock login response JSON", e));
                    }
                });
    }
    
    /* 
    @Override
    public Mono<UserDto> registerUser(RegistrationRequest request, String m2mBearerToken) {
        log.info("√âtape 1: Sending registration request for {}", request.getEmail());
        return webClient.post()
                .uri("/api/register")
                .header("Authorization", m2mBearerToken)
                .bodyValue(request)
                .retrieve()
                .onStatus(HttpStatusCode::isError, response ->
                        response.bodyToMono(String.class)
                                .flatMap(errorBody -> {
                                    log.error("Error during user registration for {}: {} - {}", request.getEmail(), response.statusCode(), errorBody);

                                    String clientErrorMessage = "Registration failed with status " + response.statusCode();
                                    
                                    // AJOUT ICI : Log la r√©ponse brute pour le d√©bogage c√¥t√© frontend
                                    clientErrorMessage += ": External service responded with: " + (errorBody != null && !errorBody.isEmpty() ? errorBody : "[Empty or Null Body]");

                                    try {
                                        ObjectMapper mapper = new ObjectMapper();
                                        mapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false); // Ignorer les champs inconnus
                                        JsonNode root = mapper.readTree(errorBody);

                                        // Tentative d'extraction de messages d'erreur plus sp√©cifiques
                                        if (root.has("message") && root.get("message").isTextual()) {
                                            clientErrorMessage = root.get("message").asText();
                                        } else if (root.has("error") && root.get("error").isTextual()) {
                                            clientErrorMessage = root.get("error").asText();
                                        }
                                        
                                        if (root.has("errors") && root.get("errors").isObject()) {
                                            // Ajoute les d√©tails des erreurs de validation si pr√©sents
                                            clientErrorMessage += " (Details: " + root.get("errors").toString() + ")";
                                        }
                                        
                                    } catch (JsonProcessingException e) {
                                        log.warn("Could not parse errorBody from external auth service as JSON: {}", errorBody, e);
                                        // Le clientErrorMessage inclut d√©j√† le corps brut, donc pas besoin de l'ajouter ici
                                    } catch (Exception e) {
                                        log.error("Unexpected error while processing errorBody from external auth service: {}", errorBody, e);
                                        // Le clientErrorMessage inclut d√©j√† le corps brut
                                    }
    
                                    return Mono.error(new RuntimeException(clientErrorMessage));
                                })
                )
                .bodyToMono(UserDto.class);
    }

    @Override
    public Mono<LoginResponse> loginUser(LoginRequest request, String m2mBearerToken) {
        log.info("√âtape 2: Sending login request for {}", request.getUsername());
        return webClient.post()
                .uri("/api/login")
                .header("Authorization", m2mBearerToken)
                .bodyValue(request)
                .retrieve()
                .onStatus(HttpStatusCode::isError, response ->
                        response.bodyToMono(String.class)
                                .flatMap(errorBody -> {
                                    log.error("HTTP Error during login for user {}: {} - {}", request.getUsername(), response.statusCode(), errorBody);
                                    return Mono.error(new RuntimeException("Login failed with HTTP status: " + response.statusCode()));
                                })
                )
                .bodyToMono(String.class)
                .flatMap(rawBody -> {
                    log.info("Raw JSON response from /api/login for user {}: {}", request.getUsername(), rawBody);
                    try {
                        ObjectMapper objectMapper = new ObjectMapper();
                        objectMapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);

                        JsonNode rootNode = objectMapper.readTree(rawBody);
                        
                        // --- D√âBUT DE LA CORRECTION ---
                        // Si l'API renvoie un statut FAILED (identifiants invalides)
                        if (rootNode.has("status") && "FAILED".equals(rootNode.get("status").asText())) {
                            String errorMessage = rootNode.get("message").asText("Invalid Credentials");
                            log.warn("Login failed for user '{}': {}", request.getUsername(), errorMessage);
                            // On retourne un Mono vide pour signaler l'√©chec sans crasher l'application
                            return Mono.empty(); 
                        }
                        // --- FIN DE LA CORRECTION ---

                        // Si le statut est un succ√®s, on parse la r√©ponse compl√®te
                        LoginResponse loginResponse = objectMapper.readValue(rawBody, LoginResponse.class);
                        return Mono.just(loginResponse);

                    } catch (JsonProcessingException e) {
                        log.error("Failed to parse login response JSON", e);
                        return Mono.error(new RuntimeException("Failed to parse login response JSON", e));
                    }
                });
    } */
}// END OF FILE: src/main/java/com/freelance/driver_backend/service/external/AuthServiceWebClientImpl.java

//---> PATH: /home/mbogneng-junior/freelance-driver_Sylladb/backend/src/main/java/com/freelance/driver_backend/service/external/ChatService.java

package com.freelance.driver_backend.service.external;

import com.freelance.driver_backend.dto.external.ChatUserCreationPayload;
import com.freelance.driver_backend.dto.external.ChatUserLoginPayload;
import com.freelance.driver_backend.dto.external.ChatUserLoginResponse;
import reactor.core.publisher.Mono;

public interface ChatService {
    Mono<ChatUserLoginResponse> registerAndLoginChatUser(ChatUserCreationPayload payload);
    Mono<ChatUserLoginResponse> loginChatUser(ChatUserLoginPayload payload);
}// END OF FILE: src/main/java/com/freelance/driver_backend/service/external/ChatService.java

//---> PATH: /home/mbogneng-junior/freelance-driver_Sylladb/backend/src/main/java/com/freelance/driver_backend/service/external/ChatServiceWebClientImpl.java

package com.freelance.driver_backend.service.external;

import com.freelance.driver_backend.dto.external.*;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Profile;
import org.springframework.http.HttpStatusCode;
import org.springframework.stereotype.Component;
import org.springframework.web.reactive.function.client.WebClient;
import reactor.core.publisher.Mono;

@Component

@Slf4j
public class ChatServiceWebClientImpl implements ChatService {

    private final WebClient webClient;
    private final String projectId;

    public ChatServiceWebClientImpl(@Qualifier("chatServiceWebClient") WebClient webClient,
                                  @Value("${freelancedriver.chat.project-id}") String projectId) {
        this.webClient = webClient;
        this.projectId = projectId;
    }

    private Mono<Void> createUserInChatSystem(ChatUserCreationPayload payload) {
        log.info("Chat API Call: Creating user {}", payload.getLogin());
        payload.setProjectId(this.projectId);
        return webClient.post().uri("/users/create")
                .bodyValue(payload)
                .retrieve()
                .onStatus(HttpStatusCode::isError, response -> response.bodyToMono(String.class)
                        .flatMap(error -> Mono.error(new RuntimeException("Chat user creation failed: " + error))))
                .bodyToMono(Void.class);
    }

    @Override
    public Mono<ChatUserLoginResponse> registerAndLoginChatUser(ChatUserCreationPayload payload) {
        return createUserInChatSystem(payload)
                .then(loginChatUser(new ChatUserLoginPayload(null, payload.getLogin(), payload.getSecret())));
    }

    
    @Override
    public Mono<ChatUserLoginResponse> loginChatUser(ChatUserLoginPayload payload) {
        log.info("Chat API Call: Logging in user {}", payload.getLogin());
        payload.setProjectId(this.projectId);
        return webClient.post().uri("/auth/user")
                .bodyValue(payload)
                .retrieve()
                .onStatus(HttpStatusCode::isError, response -> response.bodyToMono(String.class)
                        .flatMap(error -> Mono.error(new RuntimeException("Chat login failed: " + error))))
                .bodyToMono(ChatUserLoginResponse.class);
    }
}// END OF FILE: src/main/java/com/freelance/driver_backend/service/external/ChatServiceWebClientImpl.java

//---> PATH: /home/mbogneng-junior/freelance-driver_Sylladb/backend/src/main/java/com/freelance/driver_backend/service/external/mock/MockNotificationServiceImpl.java

package com.freelance.driver_backend.service.external.mock;

import com.freelance.driver_backend.dto.external.NotificationRequest;
import com.freelance.driver_backend.repository.DesignTemplateRepository;
import com.freelance.driver_backend.repository.EmailTemplateRepository;
import com.freelance.driver_backend.repository.PushTemplateRepository;
import com.freelance.driver_backend.repository.SmtpSettingRepository;
import com.freelance.driver_backend.service.external.NotificationService;
import com.freelance.driver_backend.service.FcmHttpClient;
import jakarta.mail.internet.MimeMessage;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.context.annotation.Profile;
import org.springframework.mail.javamail.JavaMailSender;
import org.springframework.mail.javamail.MimeMessageHelper;
import org.springframework.stereotype.Service;
import org.thymeleaf.context.Context;
import org.thymeleaf.spring6.SpringTemplateEngine;
import reactor.core.publisher.Mono;
import reactor.core.scheduler.Schedulers;

import java.nio.charset.StandardCharsets;
import java.util.List;
import java.util.Map;
import java.util.UUID;
import java.util.stream.Collectors;

import com.google.firebase.FirebaseApp;

@Service

@RequiredArgsConstructor
@Slf4j
public class MockNotificationServiceImpl implements NotificationService {

    private final EmailTemplateRepository emailTemplateRepository;
    private final DesignTemplateRepository designTemplateRepository;
    private final SmtpSettingRepository smtpSettingRepository;
    private final JavaMailSender javaMailSender;
    private final SpringTemplateEngine thymeleafTemplateEngine;
    private final PushTemplateRepository pushTemplateRepository;
    private final FirebaseApp firebaseApp; 
    private final FcmHttpClient fcmHttpClient;

    @Override
    public Mono<Boolean> sendEmailNotification(UUID organisationId, NotificationRequest request, String userBearerToken, String publicKey) {
        log.warn("==================== [LOCAL EMAIL SERVICE - REAL SEND] ====================");
        
        if (request.getRecipients() == null || request.getRecipients().isEmpty()) {
            return Mono.error(new IllegalArgumentException("Recipients list cannot be empty."));
        }

        return emailTemplateRepository.findById(request.getTemplateId())
            .flatMap(emailTemplate -> 
                Mono.zip(
                    designTemplateRepository.findById(emailTemplate.getDesignTemplateId()),
                    smtpSettingRepository.findById(emailTemplate.getSettingId())
                )
            )
            .flatMap(tuple -> {
                var designTemplate = tuple.getT1();
                var smtpSetting = tuple.getT2();
                Context thymeleafContext = new Context();
                if (request.getMetadata() != null) {
                    request.getMetadata().forEach(thymeleafContext::setVariable);
                }
                String finalSubject = thymeleafTemplateEngine.process(designTemplate.getSubject(), thymeleafContext);
                String finalHtmlBody = thymeleafTemplateEngine.process(designTemplate.getHtml(), thymeleafContext);

                return Mono.fromCallable(() -> {
                    try {
                        MimeMessage message = javaMailSender.createMimeMessage();
                        MimeMessageHelper helper = new MimeMessageHelper(message, true, StandardCharsets.UTF_8.name());
                        helper.setTo(request.getRecipients().toArray(new String[0]));
                        helper.setSubject(finalSubject);
                        helper.setText(finalHtmlBody, true);
                        helper.setFrom(smtpSetting.getSenderEmail(), smtpSetting.getSenderName());

                        javaMailSender.send(message);
                        log.warn(">>> REAL EMAIL SENT via LOCAL Service to {} <<<", request.getRecipients());
                        return true;
                    } catch (Exception e) {
                        log.error("==================== ERREUR SMTP ====================");
                        log.error("√âchec de l'envoi de l'email. Cause: {}", e.getMessage());
                        log.error("V√©rifiez vos identifiants dans application.properties et le mot de passe d'application Google.");
                        log.error("=====================================================");
                        throw new RuntimeException("Failed to send email", e);
                    }
                })
                .subscribeOn(Schedulers.boundedElastic())
                .onErrorReturn(false);
            })
            .defaultIfEmpty(false);
    }

    @Override
    public Mono<Boolean> sendPushNotification(UUID organisationId, NotificationRequest request, String userBearerToken, String publicKey) {
        log.warn("==================== [LOCAL PUSH SERVICE - REAL SEND VIA FCM HTTP CLIENT] ====================");
        
        if (request.getRecipients() == null || request.getRecipients().isEmpty()) {
            log.warn("[LOCAL PUSH SERVICE] Aucuns destinataires pour la notification push.");
            return Mono.just(false);
        }

        return pushTemplateRepository.findById(request.getTemplateId())
            .flatMap(pushTemplate -> {
                String finalTitle = replaceMetadata(pushTemplate.getTitle(), request.getMetadata());
                String finalBody = replaceMetadata(pushTemplate.getBody(), request.getMetadata());

                // --- MODIFICATION ICI : Appeler FcmHttpClient avec le dataPayload ---
                return fcmHttpClient.sendNotifications(request.getRecipients(), finalTitle, finalBody, request.getData()) // <-- AJOUT DE request.getData()
                           .then(Mono.just(true)) 
                           .onErrorResume(e -> { 
                               log.error("‚ùå Erreur lors de l'envoi de notifications push via FcmHttpClient: {}", e.getMessage());
                               return Mono.just(false);
                           });
            })
            .defaultIfEmpty(false)
            .doOnError(e -> log.error("Error during local push sending process (outside flatMap)", e))
            .onErrorReturn(false);
    }

    private String replaceMetadata(String text, Map<String, String> metadata) {
        if (text == null || metadata == null) return text;
        for (Map.Entry<String, String> entry : metadata.entrySet()) {
            text = text.replace("{{" + entry.getKey() + "}}", entry.getValue());
        }
        return text;
    }
}// END OF FILE: src/main/java/com/freelance/driver_backend/service/external/mock/MockNotificationServiceImpl.java

//---> PATH: /home/mbogneng-junior/freelance-driver_Sylladb/backend/src/main/java/com/freelance/driver_backend/service/external/mock/MockOrganisationServiceImpl.java

package com.freelance.driver_backend.service.external.mock;

import com.freelance.driver_backend.dto.external.OrganisationCreationRequest;
import com.freelance.driver_backend.dto.external.OrganisationDto;
import com.freelance.driver_backend.model.mock.MockOrganisation;
import com.freelance.driver_backend.repository.mock.MockOrganisationRepository;
import com.freelance.driver_backend.service.external.OrganisationService;
import com.freelance.driver_backend.util.JwtUtil; // Utilitaire pour d√©coder le token
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;

import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.context.annotation.Profile;
import org.springframework.security.oauth2.jwt.Jwt;
import org.springframework.security.oauth2.jwt.JwtDecoder;

import org.springframework.security.oauth2.jwt.JwtException;
import org.springframework.security.oauth2.jwt.ReactiveJwtDecoder;
import org.springframework.stereotype.Service;
import reactor.core.publisher.Mono;

import java.util.List;
import java.util.UUID;

@Service

@RequiredArgsConstructor
@Slf4j
public class MockOrganisationServiceImpl implements OrganisationService {

    private final MockOrganisationRepository mockOrganisationRepository;
    private final ReactiveJwtDecoder jwtDecoder; // On injecte le d√©codeur de JWT

    @Qualifier("localJwtDecoder")
    private final JwtDecoder localJwtDecoder;

    @Override
    public Mono<OrganisationDto> createOrganisation(OrganisationCreationRequest request, String bearerToken, String publicKey) {
        log.warn("[MOCK-ORG] Creating organisation '{}' in local DB.", request.getLongName());

        // On d√©code le VRAI token pour obtenir le VRAI userId
        return decodeTokenMock(bearerToken)
            .flatMap(jwt -> {
                UUID ownerId = JwtUtil.getUserIdFromToken(jwt);
                log.info("[MOCK-ORG] Extracted real userId {} from token for new organisation.", ownerId);

                MockOrganisation newOrg = new MockOrganisation();
                newOrg.setOrganizationId(UUID.randomUUID());
                newOrg.setLongName(request.getLongName());
                newOrg.setDescription(request.getDescription());
                newOrg.setOwnerUserId(ownerId); // On utilise le vrai ID !

                return mockOrganisationRepository.save(newOrg).map(this::mapToDto);
            });
    }

    @Override
    public Mono<List<OrganisationDto>> getUserOrganisations(String userBearerToken, String publicKey) {
        log.warn("[MOCK-ORG] Getting user organisations from local DB using real user token.");
        
        return decodeTokenMock(userBearerToken)
            .flatMap(jwt -> {
                UUID ownerId = JwtUtil.getUserIdFromToken(jwt);
                log.info("[MOCK-ORG] Finding organisations for real userId {}.", ownerId);
                return mockOrganisationRepository.findByOwnerUserId(ownerId)
                    .map(this::mapToDto)
                    .collectList();
            });
    }

    @Override
    public Mono<OrganisationDto> getOrganisationById(UUID organisationId, String userBearerToken, String publicKey) {
         return mockOrganisationRepository.findById(organisationId).map(this::mapToDto);
    }
    
    private OrganisationDto mapToDto(MockOrganisation org) {
        OrganisationDto dto = new OrganisationDto();
        dto.setOrganizationId(org.getOrganizationId());
        dto.setLongName(org.getLongName());
        dto.setDescription(org.getDescription());
        dto.setStatus("ACTIVE"); // Simule un statut actif
        return dto;
    }

    // M√©thode utilitaire pour d√©coder le token JWT r√©el. On le decommentera plus tard

    /* 
    private Mono<Jwt> decodeToken(String bearerToken) {
        if (bearerToken == null || !bearerToken.startsWith("Bearer ")) {
            return Mono.error(new IllegalArgumentException("Invalid Authorization header format"));
        }
        String token = bearerToken.substring(7);
        return jwtDecoder.decode(token)
            .doOnError(JwtException.class, e -> log.error("Failed to decode JWT token", e));
    }*/



     // Methode utilitaire pour decoder les mocks token
    private Mono<Jwt> decodeTokenMock(String bearerToken) {
        if (bearerToken == null || !bearerToken.startsWith("Bearer ")) {
            return Mono.error(new IllegalArgumentException("Invalid Authorization header format"));
        }
        String token = bearerToken.substring(7);
        
        try {
            // Utiliser le d√©codeur LOCAL synchrone au lieu du r√©actif externe
            Jwt jwt = localJwtDecoder.decode(token);
            return Mono.just(jwt);
        } catch (JwtException e) {
            log.error("Failed to decode local JWT token", e);
            return Mono.error(e);
        }
    }
}// END OF FILE: src/main/java/com/freelance/driver_backend/service/external/mock/MockOrganisationServiceImpl.java

//---> PATH: /home/mbogneng-junior/freelance-driver_Sylladb/backend/src/main/java/com/freelance/driver_backend/service/external/NotificationService.java

package com.freelance.driver_backend.service.external;

import com.freelance.driver_backend.dto.external.NotificationRequest;
import reactor.core.publisher.Mono;
import java.util.UUID;

public interface NotificationService {

    /**
     * Envoie une notification par email en utilisant le service de notification.
     *
     * @param organisationId L'ID de l'organisation qui envoie la notification.
     * @param request        L'objet contenant les d√©tails de la notification (template, destinataires, etc.).
     * @param userBearerToken  Le token de l'utilisateur authentifi√©.
     * @param publicKey      La cl√© publique de l'API.
     * @return Un Mono<Boolean> qui retourne true si la notification a √©t√© accept√©e pour envoi.
     */
    Mono<Boolean> sendEmailNotification(UUID organisationId, NotificationRequest request, String userBearerToken, String publicKey);
    Mono<Boolean> sendPushNotification(UUID organisationId, NotificationRequest request, String userBearerToken, String publicKey);

}// END OF FILE: src/main/java/com/freelance/driver_backend/service/external/NotificationService.java

//---> PATH: /home/mbogneng-junior/freelance-driver_Sylladb/backend/src/main/java/com/freelance/driver_backend/service/external/OrganisationService.java

package com.freelance.driver_backend.service.external;

import com.freelance.driver_backend.dto.external.OrganisationCreationRequest;
import com.freelance.driver_backend.dto.external.OrganisationDto;
import reactor.core.publisher.Mono;
import java.util.List;
import java.util.UUID;

public interface OrganisationService {
    // La signature est maintenant Mono<OrganisationDto> pour refl√©ter la r√©ponse de l'API
    Mono<OrganisationDto> createOrganisation(OrganisationCreationRequest request, String bearerToken, String publicKey);

    Mono<List<OrganisationDto>> getUserOrganisations(String userBearerToken, String publicKey);
    Mono<OrganisationDto> getOrganisationById(UUID organisationId, String userBearerToken, String publicKey);
}// END OF FILE: src/main/java/com/freelance/driver_backend/service/external/OrganisationService.java

//---> PATH: /home/mbogneng-junior/freelance-driver_Sylladb/backend/src/main/java/com/freelance/driver_backend/service/FcmHttpClient.java

package com.freelance.driver_backend.service;

import com.google.auth.oauth2.GoogleCredentials;
import com.google.firebase.FirebaseApp;
import lombok.extern.slf4j.Slf4j;
import org.springframework.core.io.ClassPathResource;
import org.springframework.http.MediaType;
import org.springframework.stereotype.Service;
import org.springframework.web.reactive.function.client.WebClient;
import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;
import org.springframework.http.HttpStatusCode;
import java.util.HashMap;

import java.io.IOException;
import java.io.InputStream;
import java.util.Collections;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;

@Service
@Slf4j
public class FcmHttpClient {

    private final WebClient webClient;
    private final FirebaseApp firebaseApp; 
    private final String projectId;        

    public FcmHttpClient(FirebaseApp firebaseApp) { 
        this.firebaseApp = firebaseApp;
        this.projectId = firebaseApp.getOptions().getProjectId(); 
        
        if (this.projectId == null || this.projectId.isBlank()) {
            throw new IllegalStateException("Firebase Project ID not configured in FirebaseApp options.");
        }

        this.webClient = WebClient.builder()
                .baseUrl("https://fcm.googleapis.com") 
                .build();
    }

    private Mono<String> getAccessToken() {
        return Mono.fromCallable(() -> {
            ClassPathResource resource = new ClassPathResource("firebase-service-account-key.json"); 
            try (InputStream stream = resource.getInputStream()) {
                GoogleCredentials credentials = GoogleCredentials.fromStream(stream)
                    .createScoped(Collections.singletonList("https://www.googleapis.com/auth/firebase.messaging"));
                
                credentials.refreshIfExpired(); 
                return credentials.getAccessToken().getTokenValue();
            }
        }).onErrorMap(IOException.class, e -> new RuntimeException("Impossible d'obtenir le token d'acc√®s Google pour FCM.", e));
    }

    // NOUVELLE SIGNATURE : Accepte un dataPayload
    public Mono<Void> sendNotifications(List<String> tokens, String title, String body, Map<String, String> dataPayload) {
        if (tokens == null || tokens.isEmpty()) {
            log.warn("[FCM HTTP CLIENT] Aucun token fourni, l'envoi de notification est annul√©.");
            return Mono.empty();
        }
        
        log.info("‚ñ∂Ô∏è [FCM HTTP CLIENT] Pr√©paration de l'envoi de la notification '{}' √† {} appareil(s). Projet: {}", title, tokens.size(), this.projectId);

        return getAccessToken().flatMap(token ->
            Flux.fromIterable(tokens)
                .flatMap(singleToken -> { 
                    // Construction du corps de la requ√™te JSON pour l'API FCM v1
                    Map<String, Object> messageContent = new HashMap<>();
                    messageContent.put("token", singleToken);
                    messageContent.put("notification", Map.of("title", title, "body", body));
                    
                    // AJOUT : Inclure le dataPayload si pr√©sent
                    if (dataPayload != null && !dataPayload.isEmpty()) {
                        messageContent.put("data", dataPayload);
                    }

                    Map<String, Object> notificationPayload = Map.of(
                        "message", messageContent
                    );

                    return webClient.post()
                        .uri("/v1/projects/{projectId}/messages:send", this.projectId)
                        .headers(headers -> headers.setBearerAuth(token))
                        .contentType(MediaType.APPLICATION_JSON)
                        .bodyValue(notificationPayload)
                        .retrieve()
                        .onStatus(HttpStatusCode::isError, response -> 
                            response.bodyToMono(String.class)
                                    .map(errorBody -> {
                                        log.error("‚ùå [FCM HTTP CLIENT] Erreur HTTP lors de l'envoi √† FCM (Status: {}): {}", response.statusCode(), errorBody);
                                        return new RuntimeException("√âchec d'envoi FCM: " + errorBody);
                                    })
                                    .switchIfEmpty(Mono.defer(() -> {
                                        log.error("‚ùå [FCM HTTP CLIENT] √âchec d'envoi FCM: corps d'erreur vide. Status: {}", response.statusCode());
                                        return Mono.just(new RuntimeException("√âchec d'envoi FCM: corps d'erreur vide. Status: " + response.statusCode()));
                                    }))
                        )
                        // <-- LA PARENTH√àSE EN TROP √âTAIT ICI, JE L'AI SUPPRIM√âE !
                        .bodyToMono(String.class) 
                        .doOnSuccess(responseBody -> log.info("‚úÖ [FCM HTTP CLIENT] R√©ponse de FCM pour token {}: {}", singleToken.substring(0, 10) + "...", responseBody)) 
                        .doOnError(e -> log.error("‚ùå [FCM HTTP CLIENT] √âchec de l'envoi √† FCM pour token {}: {}", singleToken.substring(0, 10) + "...", e.getMessage())) 
                        .onErrorResume(e -> Mono.empty()); 
                })
                .then() // <-- C'est ici que le Mono<Void> est g√©n√©r√©.
        );
    }
}// END OF FILE: src/main/java/com/freelance/driver_backend/service/FcmHttpClient.java

//---> PATH: /home/mbogneng-junior/freelance-driver_Sylladb/backend/src/main/java/com/freelance/driver_backend/service/FirebaseService.java

package com.freelance.driver_backend.service;

import com.google.auth.oauth2.GoogleCredentials;
import com.google.firebase.FirebaseApp;
import com.google.firebase.FirebaseOptions;
import jakarta.annotation.PostConstruct;
import lombok.extern.slf4j.Slf4j;
import org.springframework.core.io.ClassPathResource;
import org.springframework.stereotype.Service;

import java.io.InputStream;

@Service
@Slf4j
public class FirebaseService {

    @PostConstruct // Cette m√©thode sera ex√©cut√©e au d√©marrage de Spring
    public void initialize() {
        try {
            // Assurez-vous que votre fichier de cl√© de service Firebase
            // est plac√© dans src/main/resources
            ClassPathResource resource = new ClassPathResource("firebase-service-account-key.example");
            InputStream serviceAccount = resource.getInputStream();

            FirebaseOptions options = FirebaseOptions.builder()
                .setCredentials(GoogleCredentials.fromStream(serviceAccount))
                .build();

            if (FirebaseApp.getApps().isEmpty()) {
                FirebaseApp.initializeApp(options);
                log.info("Firebase Admin SDK a √©t√© initialis√© avec succ√®s.");
            } else {
                log.warn("Firebase Admin SDK est d√©j√† initialis√©.");
            }
        } catch (Exception e) {
            log.error("Erreur lors de l'initialisation du Firebase Admin SDK. Les notifications push ne fonctionneront pas.", e);
        }
    }
}// END OF FILE: src/main/java/com/freelance/driver_backend/service/FirebaseService.java

//---> PATH: /home/mbogneng-junior/freelance-driver_Sylladb/backend/src/main/java/com/freelance/driver_backend/service/internal/ExternalMediaStorageService.java

package com.freelance.driver_backend.service.internal;

import com.freelance.driver_backend.dto.external.MediaApiResponseDto;
// SUPPRESSION : import com.freelance.driver_backend.dto.external.OAuthTokenResponse;
import com.freelance.driver_backend.dto.external.UploadMediaResponse;
import com.freelance.driver_backend.service.StorageService;
// SUPPRESSION : import com.freelance.driver_backend.service.external.AuthService;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Primary;
// SUPPRESSION : import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpStatusCode;
import org.springframework.http.MediaType;
import org.springframework.http.codec.multipart.FilePart;
import org.springframework.stereotype.Service;
import org.springframework.util.LinkedMultiValueMap;
import org.springframework.util.MultiValueMap;
import org.springframework.web.reactive.function.BodyInserters;
import org.springframework.web.reactive.function.client.WebClient;
import reactor.core.publisher.Mono;

import java.util.UUID;

@Service
@Primary
@Slf4j
public class ExternalMediaStorageService implements StorageService {

    private final WebClient externalMediaServiceWebClient;
    private final String mediaServiceBaseUrl;

    public ExternalMediaStorageService(
            @Qualifier("externalMediaServiceWebClient") WebClient externalMediaServiceWebClient,
            @Value("${microservices.media-service.url}") String mediaServiceBaseUrl
    ) {
        this.externalMediaServiceWebClient = externalMediaServiceWebClient;
        this.mediaServiceBaseUrl = mediaServiceBaseUrl.endsWith("/") ? mediaServiceBaseUrl.substring(0, mediaServiceBaseUrl.length() - 1) : mediaServiceBaseUrl;
    }

    // ==============================================================================
    //                       M√âTHODE saveFile SIMPLIFI√âE
    // ==============================================================================
    @Override
    public Mono<UploadMediaResponse> saveFile(String serviceContext, String frontendLogicalType, UUID uploaderUserId,
            UUID targetResourceId, String originalFileName, FilePart file) {

        log.info("[ADAPTED & SIMPLIFIED] Appel √† la NOUVELLE API publique de m√©dias.");
        
        String location = String.format("%s/%s", frontendLogicalType, targetResourceId.toString());

        MultiValueMap<String, Object> body = new LinkedMultiValueMap<>();
        body.add("file", file);
        body.add("service", serviceContext);
        body.add("location", location);

        return externalMediaServiceWebClient.post()
                .uri("/media/upload")
                // SUPPRESSION : Plus besoin de header d'autorisation
                .contentType(MediaType.MULTIPART_FORM_DATA)
                .body(BodyInserters.fromMultipartData(body))
                .retrieve()
                .onStatus(HttpStatusCode::isError, response -> response.bodyToMono(String.class)
                        .flatMap(errorBody -> {
                            log.error("‚ùå Erreur de la NOUVELLE API (upload) : {}", errorBody);
                            // On v√©rifie le cas o√π la r√©ponse est du HTML (signe d'une erreur non-JSON)
                            if (response.headers().contentType().orElse(MediaType.APPLICATION_JSON).isCompatibleWith(MediaType.TEXT_HTML)) {
                                 log.error("La r√©ponse d'erreur est du HTML, ce qui est inattendu. Le service de m√©dias est peut-√™tre mal configur√© ou en panne.");
                                 return Mono.error(new RuntimeException("Le service de m√©dias a retourn√© une page d'erreur HTML."));
                            }
                            return Mono.error(new RuntimeException("√âchec du t√©l√©versement : " + errorBody));
                        }))
                // Ajout d'un log pour le type de contenu de la r√©ponse
                .bodyToMono(MediaApiResponseDto.class)
                .flatMap(apiResponse -> {
                    UploadMediaResponse responseForApp = new UploadMediaResponse();
                    responseForApp.setId(apiResponse.getId());
                    responseForApp.setResourceId(targetResourceId);
                    responseForApp.setUri(apiResponse.getUri());
                    responseForApp.setUrl(apiResponse.getPublicUrl(this.mediaServiceBaseUrl));
                    
                    log.info("‚úÖ [ADAPTED] Upload r√©ussi. URL publique g√©n√©r√©e : {}", responseForApp.getUrl());
                    return Mono.just(responseForApp);
                });
    }

    // ==============================================================================
    //                       M√âTHODE deleteFile SIMPLIFI√âE
    // ==============================================================================
    @Override
    public Mono<Void> deleteFile(String mediaUrl) {
        log.info("[ADAPTED & SIMPLIFIED] Appel √† la NOUVELLE API publique pour suppression.");

        if (mediaUrl == null || mediaUrl.isBlank()) {
            return Mono.error(new IllegalArgumentException("L'URL du m√©dia ne peut pas √™tre nulle."));
        }

        try {
            String[] segments = mediaUrl.split("/");
            String mediaId = segments[segments.length - 1];
            UUID.fromString(mediaId);
            
            log.info("[ADAPTER] ID du m√©dia extrait pour suppression : {}", mediaId);

            return externalMediaServiceWebClient.delete()
                    .uri("/media/{id}", mediaId)
                    // SUPPRESSION : Plus besoin de header d'autorisation
                    .retrieve()
                    .onStatus(HttpStatusCode::isError, response -> response.bodyToMono(String.class)
                            .flatMap(errorBody -> {
                                log.error("‚ùå Erreur de la NOUVELLE API (delete) : {}", errorBody);
                                return Mono.error(new RuntimeException("√âchec de la suppression : " + errorBody));
                            }))
                    .bodyToMono(Void.class)
                    .doOnSuccess(v -> log.info("‚úÖ [ADAPTER] Fichier avec ID {} supprim√© via la nouvelle API.", mediaId));

        } catch (Exception e) {
            log.error("‚ùå Impossible d'extraire l'ID du m√©dia depuis l'URL '{}'.", mediaUrl);
            return Mono.error(new IllegalArgumentException("Format d'URL de m√©dia invalide: " + mediaUrl));
        }
    }
}// END OF FILE: src/main/java/com/freelance/driver_backend/service/internal/ExternalMediaStorageService.java

//---> PATH: /home/mbogneng-junior/freelance-driver_Sylladb/backend/src/main/java/com/freelance/driver_backend/service/internal/ResourceServiceLocalImpl.java

package com.freelance.driver_backend.service.internal;

import com.freelance.driver_backend.dto.CreateProductRequest;
import com.freelance.driver_backend.model.Product;
import com.freelance.driver_backend.service.ResourceService;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.context.annotation.Profile;
import org.springframework.stereotype.Service;
import org.springframework.web.reactive.function.client.WebClient;
import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;
import java.util.UUID;





@Service
@Slf4j
public class ResourceServiceLocalImpl implements ResourceService {
    private final WebClient localApiClient;

    public ResourceServiceLocalImpl(@Qualifier("localApiWebClient") WebClient localApiClient) {
        this.localApiClient = localApiClient;
    }

    @Override
    public Mono<Product> createProduct(UUID organizationId, CreateProductRequest request, String bearerToken, String publicKey) {
        log.warn("[LOCAL-IMPL] Appel de MockProductController pour cr√©er un produit/adresse.");
        return localApiClient.post()
                .uri("/api/mock-products/{organizationId}", organizationId)
                .header("Authorization", bearerToken)
                .bodyValue(request)
                .retrieve()
                .bodyToMono(Product.class);
    }

    @Override
    public Flux<Product> getProductsByCategory(UUID organizationId, UUID categoryId, String bearerToken, String publicKey) {
        log.warn("[LOCAL-IMPL] Appel de MockProductController pour lister les produits/adresses.");
        return localApiClient.get()
                .uri(uriBuilder -> uriBuilder
                        .path("/api/mock-products/{organizationId}")
                        .queryParam("categoryId", categoryId)
                        .build(organizationId))
                .header("Authorization", bearerToken)
                .retrieve()
                .bodyToFlux(Product.class);
    }

    @Override
    public Mono<Product> updateProduct(UUID organizationId, UUID productId, CreateProductRequest request, String bearerToken, String publicKey) {
        log.warn("[LOCAL-IMPL] Appel de MockProductController pour mettre √† jour le produit/adresse {}.", productId);
        return localApiClient.put()
                .uri("/api/mock-products/{organizationId}/{productId}", organizationId, productId)
                .header("Authorization", bearerToken)
                .bodyValue(request)
                .retrieve()
                .bodyToMono(Product.class);
    }

    @Override
    public Mono<Void> deleteProduct(UUID organizationId, UUID productId, String bearerToken, String publicKey) {
        log.warn("[LOCAL-IMPL] Appel de MockProductController pour supprimer le produit/adresse {}.", productId);
        return localApiClient.delete()
                .uri("/api/mock-products/{organizationId}/{productId}", organizationId, productId)
                .header("Authorization", bearerToken)
                .retrieve()
                .bodyToMono(Void.class);
    }
}// END OF FILE: src/main/java/com/freelance/driver_backend/service/internal/ResourceServiceLocalImpl.java

//---> PATH: /home/mbogneng-junior/freelance-driver_Sylladb/backend/src/main/java/com/freelance/driver_backend/service/JwtService.java

package com.freelance.driver_backend.service;

import com.freelance.driver_backend.model.mock.MockUser;
import lombok.RequiredArgsConstructor;
import org.springframework.security.oauth2.jwt.JwtClaimsSet;
import org.springframework.security.oauth2.jwt.JwtEncoder;
import org.springframework.security.oauth2.jwt.JwtEncoderParameters;
import org.springframework.stereotype.Service;

import java.time.Instant;
import java.time.temporal.ChronoUnit;
import java.util.HashMap;
import java.util.Map;

@Service
@RequiredArgsConstructor
public class JwtService {

    private final JwtEncoder jwtEncoder;

    public String generateToken(MockUser user) {
        Instant now = Instant.now();
        Instant expiration = now.plus(1, ChronoUnit.HOURS);

        // Cr√©er le claim "user" compatible avec votre JwtUtil
        Map<String, Object> userClaim = new HashMap<>();
        userClaim.put("id", user.getId().toString());
        userClaim.put("username", user.getUsername());
        userClaim.put("email", user.getEmail());
        userClaim.put("firstName", user.getFirstName());
        userClaim.put("lastName", user.getLastName());

        JwtClaimsSet claims = JwtClaimsSet.builder()
                .issuer("freelance-driver-app")
                .issuedAt(now)
                .expiresAt(expiration)
                .subject(user.getUsername())
                .claim("user", userClaim)
                .build();

        return jwtEncoder.encode(JwtEncoderParameters.from(claims)).getTokenValue();
    }
}// END OF FILE: src/main/java/com/freelance/driver_backend/service/JwtService.java

//---> PATH: /home/mbogneng-junior/freelance-driver_Sylladb/backend/src/main/java/com/freelance/driver_backend/service/LoginService.java


/* package com.freelance.driver_backend.service;

import com.freelance.driver_backend.dto.external.ChatUserLoginPayload;
import com.freelance.driver_backend.dto.external.ChatUserLoginResponse;
import com.freelance.driver_backend.dto.external.LoginRequest;
import com.freelance.driver_backend.dto.external.LoginResponse;
import com.freelance.driver_backend.dto.onboarding.ChatSessionInfo;
import com.freelance.driver_backend.dto.onboarding.OnboardingResponse;
import com.freelance.driver_backend.repository.ClientProfileRepository;
import com.freelance.driver_backend.repository.DriverProfileRepository;
import com.freelance.driver_backend.service.external.AuthService;
import com.freelance.driver_backend.service.external.ChatService;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Service;
import reactor.core.publisher.Mono;

import java.util.Collections;
import java.util.List;
import java.util.UUID;

@Service
@RequiredArgsConstructor
@Slf4j
public class LoginService {

    private final AuthService authService;
    private final ChatService chatService;
    private final DriverProfileRepository driverProfileRepository;
    private final ClientProfileRepository clientProfileRepository;
    private final ProfileService profileService;

    @Value("${freelancedriver.oauth2.client-id}")
    private String oauthClientId;
    @Value("${freelancedriver.oauth2.client-secret}")
    private String oauthClientSecret;

    public Mono<OnboardingResponse> loginAndGetContext(LoginRequest loginRequest) {
        log.info("Login process started for user: {}", loginRequest.getUsername());

        return authService.getClientCredentialsToken(oauthClientId, oauthClientSecret)
                .flatMap(m2mToken -> authService.loginUser(loginRequest, "Bearer " + m2mToken.getAccessToken()))
                .flatMap(loginResponse -> {
                    if (loginResponse.getUser() == null || loginResponse.getUser().getId() == null) {
                        return Mono.error(new RuntimeException("Incomplete login response from auth service."));
                    }

                    log.info("User {} successfully logged in. Chat login temporarily disabled.", loginResponse.getUser().getUsername());

                    String userBearerToken = "Bearer " + loginResponse.getAccessToken().getToken();

                    return profileService.getUserSessionContext(loginResponse.getUser().getId(), userBearerToken, null)
                            .flatMap(userContextDto -> {
                                if (userContextDto == null) {
                                    return Mono.error(new RuntimeException("No local profile context found for user " + loginResponse.getUser().getId()));
                                }

                                // MODIFI√â : Utilise getRoles() qui retourne une List<UserRole>
                                log.info("Profile context found for user {}. Roles: {}", loginResponse.getUser().getUsername(), userContextDto.getRoles());

                                return Mono.just(OnboardingResponse.builder()
                                        .token(loginResponse.getAccessToken().getToken())
                                        .profile(userContextDto)
                                        .chatSession(null)
                                        .build());
                            });
                });
    }
}

*/



package com.freelance.driver_backend.service;

import com.freelance.driver_backend.dto.external.ChatUserLoginPayload;
import com.freelance.driver_backend.dto.external.ChatUserLoginResponse;
import com.freelance.driver_backend.dto.external.LoginRequest;
import com.freelance.driver_backend.dto.external.LoginResponse;
import com.freelance.driver_backend.dto.onboarding.ChatSessionInfo;
import com.freelance.driver_backend.dto.onboarding.OnboardingResponse;
import com.freelance.driver_backend.repository.ClientProfileRepository;
import com.freelance.driver_backend.repository.DriverProfileRepository;
import com.freelance.driver_backend.service.external.AuthService;
import com.freelance.driver_backend.service.external.ChatService;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Service;
import reactor.core.publisher.Mono;

import java.util.Collections;
import java.util.List;
import java.util.UUID;

@Service
@RequiredArgsConstructor
@Slf4j
public class LoginService {

    private final AuthService authService;
    private final ChatService chatService;
    private final DriverProfileRepository driverProfileRepository;
    private final ClientProfileRepository clientProfileRepository;
    private final ProfileService profileService;

    @Value("${freelancedriver.oauth2.client-id}")
    private String oauthClientId;
    @Value("${freelancedriver.oauth2.client-secret}")
    private String oauthClientSecret;

    public Mono<OnboardingResponse> loginAndGetContext(LoginRequest loginRequest) {
        log.info("Login process started for user: {}", loginRequest.getUsername());

        return authService.loginUser(loginRequest, "Bearer hhdjdeiieeueuue" )
                .flatMap(loginResponse -> {
                    if (loginResponse.getUser() == null || loginResponse.getUser().getId() == null) {
                        return Mono.error(new RuntimeException("Incomplete login response from auth service."));
                    }

                    log.info("User {} successfully logged in. Chat login temporarily disabled.", loginResponse.getUser().getUsername());

                    String userBearerToken = "Bearer " + loginResponse.getAccessToken().getToken();

                    return profileService.getUserSessionContext(loginResponse.getUser().getId(), userBearerToken, null)
                            .flatMap(userContextDto -> {
                                if (userContextDto == null) {
                                    return Mono.error(new RuntimeException("No local profile context found for user " + loginResponse.getUser().getId()));
                                }

                                // MODIFI√â : Utilise getRoles() qui retourne une List<UserRole>
                                log.info("Profile context found for user {}. Roles: {}", loginResponse.getUser().getUsername(), userContextDto.getRoles());

                                return Mono.just(OnboardingResponse.builder()
                                        .token(loginResponse.getAccessToken().getToken())
                                        .profile(userContextDto)
                                        .chatSession(null)
                                        .build());
                            });
                });
    }
}
// END OF FILE: src/main/java/com/freelance/driver_backend/service/LoginService.java

//---> PATH: /home/mbogneng-junior/freelance-driver_Sylladb/backend/src/main/java/com/freelance/driver_backend/service/MockUserService.java

package com.freelance.driver_backend.service;

import com.freelance.driver_backend.dto.external.*;
import com.freelance.driver_backend.model.mock.MockUser;
import com.freelance.driver_backend.repository.mock.MockUserRepository;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Service;
import reactor.core.publisher.Mono;

import java.time.OffsetDateTime;
import java.util.List;
import java.util.UUID;

@Service
@RequiredArgsConstructor
public class MockUserService {
    
   private final MockUserRepository mockUserRepository;
    private final JwtService jwtService;

    public Mono<UserDto> register(RegistrationRequest request) {
        return mockUserRepository.findByEmail(request.getEmail())
                .hasElement()
                .flatMap(emailExists -> {
                    if (emailExists) {
                        return Mono.error(new RuntimeException("Email d√©j√† utilis√©"));
                    }
                    return mockUserRepository.findByUsername(request.getUsername()).hasElement();
                })
                .flatMap(usernameExists -> {
                    if (usernameExists) {
                        return Mono.error(new RuntimeException("Username d√©j√† utilis√©"));
                    }
                    
                    MockUser user = new MockUser();
                    user.setId(UUID.randomUUID());
                    user.setUsername(request.getUsername());
                    user.setPassword(request.getPassword());
                    user.setEmail(request.getEmail());
                    user.setFirstName(request.getFirstName());
                    user.setLastName(request.getLastName());
                    user.setPhoneNumber(request.getPhoneNumber());
                    // Supprimer cette ligne si RegistrationRequest n'a pas organisationId
                    // user.setOrganisationId(request.getOrganisationId()); 
                    //user.setOrganisationId(null); // Ou d√©finir une valeur par d√©faut

                    return mockUserRepository.save(user);
                })
                .map(this::convertToUserDto);
    }

    

    public Mono<LoginResponse> login(LoginRequest request) {
        return mockUserRepository.findByUsername(request.getUsername())
                .switchIfEmpty(Mono.error(new RuntimeException("Identifiants invalides")))
                .filter(user -> user.getPassword().equals(request.getPassword()))
                .switchIfEmpty(Mono.error(new RuntimeException("Identifiants invalides")))
                .map(user -> {
                    // JwtService est maintenant synchrone
                    String token = jwtService.generateToken(user);
                    return createLoginResponse(user, token);
                });
    }

    private LoginResponse createLoginResponse(MockUser user, String jwtToken) {
        LoginResponse response = new LoginResponse();
        
        // Access Token avec vrai JWT
        LoginResponse.AccessToken accessToken = new LoginResponse.AccessToken();
        accessToken.setToken(jwtToken);
        accessToken.setType("Bearer");
        accessToken.setExpiresIn(3600);
        response.setAccessToken(accessToken);
        
        // User Info
        LoginResponse.UserInfo userInfo = new LoginResponse.UserInfo();
        userInfo.setId(user.getId());
        userInfo.setFirstName(user.getFirstName());
        userInfo.setLastName(user.getLastName());
        userInfo.setUsername(user.getUsername());
        userInfo.setEmail(user.getEmail());
        userInfo.setPhoneNumber(user.getPhoneNumber());
        userInfo.setEmailVerified(false);
        userInfo.setPhoneNumberVerified(false);
        response.setUser(userInfo);
        
        response.setRoles(List.of("USER"));
        response.setPermissions(List.of("READ_PROFILE", "UPDATE_PROFILE"));
        
        return response;
    }

    private UserDto convertToUserDto(MockUser user) {
        UserDto dto = new UserDto();
        dto.setId(user.getId());
        dto.setUsername(user.getUsername());
        dto.setEmail(user.getEmail());
        dto.setFirstName(user.getFirstName());
        dto.setLastName(user.getLastName());
        dto.setPhoneNumber(user.getPhoneNumber());
        dto.setEmailVerified(false);
        dto.setPhoneNumberVerified(false);
        dto.setEnabled(true);
        dto.setCreatedAt(OffsetDateTime.now());
        dto.setUpdatedAt(OffsetDateTime.now());
        return dto;
    }
}// END OF FILE: src/main/java/com/freelance/driver_backend/service/MockUserService.java

//---> PATH: /home/mbogneng-junior/freelance-driver_Sylladb/backend/src/main/java/com/freelance/driver_backend/service/NotificationTriggerService.java



package com.freelance.driver_backend.service;

import com.freelance.driver_backend.dto.external.NotificationRequest;
import com.freelance.driver_backend.model.ClientProfile;
import com.freelance.driver_backend.model.DeviceToken;
import com.freelance.driver_backend.model.DriverProfile;
import com.freelance.driver_backend.model.Product;
import com.freelance.driver_backend.repository.ClientProfileRepository;
import com.freelance.driver_backend.repository.DeviceTokenRepository;
import com.freelance.driver_backend.repository.DriverProfileRepository;
import com.freelance.driver_backend.service.external.NotificationService;
import io.github.cdimascio.dotenv.Dotenv;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;
import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;

import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.UUID;
import java.util.stream.Collectors;

@Service
@RequiredArgsConstructor
@Slf4j
public class NotificationTriggerService {

    private final ClientProfileRepository clientProfileRepository;
    private final DriverProfileRepository driverProfileRepository;
    private final DeviceTokenRepository deviceTokenRepository;
    private final NotificationService notificationService;
    private final Dotenv dotenv;

    /**
     * Notifie un client qu'un chauffeur a postul√© √† son annonce.
     */
    public Mono<Void> notifyClientOfAcceptedAnnouncement(Product announcement, DriverProfile driverProfile) {
        UUID targetClientId = announcement.getClientId();
        if (targetClientId == null) return Mono.empty();
        
        log.info("D√©clenchement de la notification pour le client {} (postulation par chauffeur {}) pour l'annonce {}.", targetClientId, driverProfile.getUserId(), announcement.getName());

        return deviceTokenRepository.findByUserId(targetClientId)
            .map(DeviceToken::getToken)
            .collectList()
            .flatMap(tokens -> {
                if (tokens.isEmpty()) {
                    log.warn("Aucun token d'appareil trouv√© pour le client {}.", targetClientId);
                    return Mono.empty();
                }
                
                UUID templateId = UUID.fromString(dotenv.get("TEMPLATE_PUSH_ANNOUNCEMENT_ACCEPTED_ID"));
                
                Map<String, String> dataPayload = new HashMap<>();
                dataPayload.put("screen", "DriverDetails");
                dataPayload.put("driverId", driverProfile.getUserId().toString());
                dataPayload.put("announcementId", announcement.getId().toString());
                dataPayload.put("source", "notification");
                
                NotificationRequest request = NotificationRequest.builder()
                    .templateId(templateId)
                    .recipients(tokens)
                    .metadata(Map.of(
                        "driverName", driverProfile.getFirstName() + " " + driverProfile.getLastName(),
                        "tripTitle", announcement.getName(),
                        "driverId", driverProfile.getUserId().toString() 
                    ))
                    .data(dataPayload)
                    .build();
                
                return notificationService.sendPushNotification(announcement.getOrganizationId(), request, null, null);
            })
            .then();
    }

    /**
     * Notifie un chauffeur que sa postulation a √©t√© accept√©e par le client.
     */
    public Mono<Void> notifyDriverOfConfirmedAnnouncement(Product announcement, DriverProfile driverProfile) {
        UUID targetDriverId = driverProfile.getUserId();
        if (targetDriverId == null) return Mono.empty();

        log.info("D√©clenchement de la notification pour le chauffeur {} (postulation ACCEPT√âE) pour l'annonce {}.", targetDriverId, announcement.getName());

        return deviceTokenRepository.findByUserId(targetDriverId)
            .map(DeviceToken::getToken)
            .collectList()
            .flatMap(tokens -> {
                if (tokens.isEmpty()) {
                    log.warn("Aucun token d'appareil trouv√© pour le chauffeur {}.", targetDriverId);
                    return Mono.empty();
                }

                UUID templateId = UUID.fromString(dotenv.get("TEMPLATE_PUSH_ANNOUNCEMENT_CONFIRMED_ID")); 
                
                return clientProfileRepository.findByUserId(announcement.getClientId())
                    .flatMap(clientProfile -> {
                        Map<String, String> dataPayload = new HashMap<>();
                        dataPayload.put("screen", "MyAcceptedRides"); 
                        dataPayload.put("tripId", announcement.getId().toString());
                        dataPayload.put("source", "notification");

                        NotificationRequest request = NotificationRequest.builder()
                            .templateId(templateId)
                            .recipients(tokens)
                            .metadata(Map.of(
                                "clientName", clientProfile.getFirstName() + " " + clientProfile.getLastName(),
                                "tripTitle", announcement.getName(),
                                "tripId", announcement.getId().toString()
                            ))
                            .data(dataPayload)
                            .build();
                        return notificationService.sendPushNotification(announcement.getOrganizationId(), request, null, null);
                    })
                    .then();
            })
            .then();
    }

    /**
     * Notifie le client qu'un chauffeur a annul√© sa postulation.
     */
    public Mono<Void> notifyClientOfCancelledPostulation(Product announcement, DriverProfile driverProfile) {
        UUID targetClientId = announcement.getClientId();
        if (targetClientId == null) return Mono.empty();

        log.info("D√©clenchement de la notification pour le client {} (postulation ANNUL√âE par chauffeur {}) pour l'annonce {}.", targetClientId, driverProfile.getUserId(), announcement.getName());

        return deviceTokenRepository.findByUserId(targetClientId)
            .map(DeviceToken::getToken)
            .collectList()
            .flatMap(tokens -> {
                if (tokens.isEmpty()) {
                    log.warn("Aucun token d'appareil trouv√© pour le client {}.", targetClientId);
                    return Mono.empty();
                }

                UUID templateId = UUID.fromString(dotenv.get("TEMPLATE_PUSH_POSTULATION_CANCELLED_ID")); 
                
                Map<String, String> dataPayload = new HashMap<>();
                dataPayload.put("screen", "MyAnnouncements"); 
                dataPayload.put("announcementId", announcement.getId().toString());
                dataPayload.put("source", "notification");

                NotificationRequest request = NotificationRequest.builder()
                    .templateId(templateId)
                    .recipients(tokens)
                    .metadata(Map.of(
                        "driverName", driverProfile.getFirstName() + " " + driverProfile.getLastName(),
                        "tripTitle", announcement.getName()
                    ))
                    .data(dataPayload)
                    .build();
                return notificationService.sendPushNotification(announcement.getOrganizationId(), request, null, null);
            })
            .then();
    }
    
    /**
     * NOUVEAU : Notifie le CHAUFFEUR qu'un client a DEMAND√â √† r√©server son planning.
     */
    public Mono<Void> notifyDriverOfPlanningBookingRequest(Product planning, ClientProfile clientProfile) {
        UUID targetDriverId = planning.getClientId(); // L'auteur du planning est le chauffeur
        if (targetDriverId == null) return Mono.empty();

        log.info("D√©clenchement de la notification pour le chauffeur {} (demande de r√©servation de planning par client {}) pour le planning {}.", targetDriverId, clientProfile.getUserId(), planning.getName());

        return deviceTokenRepository.findByUserId(targetDriverId)
            .map(DeviceToken::getToken)
            .collectList()
            .flatMap(tokens -> {
                if (tokens.isEmpty()) {
                    log.warn("Aucun token d'appareil trouv√© pour le chauffeur {}.", targetDriverId);
                    return Mono.empty();
                }

                UUID templateId = UUID.fromString(dotenv.get("TEMPLATE_PUSH_PLANNING_BOOKING_REQUESTED_TO_DRIVER_ID"));
                
                Map<String, String> dataPayload = new HashMap<>();
                dataPayload.put("screen", "MyPlannings"); // √âcran o√π le chauffeur voit ses plannings ou demandes
                dataPayload.put("planningId", planning.getId().toString());
                dataPayload.put("clientId", clientProfile.getUserId().toString()); // Pour que le chauffeur puisse confirmer
                dataPayload.put("source", "notification");

                NotificationRequest request = NotificationRequest.builder()
                    .templateId(templateId)
                    .recipients(tokens)
                    .metadata(Map.of(
                        "clientName", clientProfile.getFirstName() + " " + clientProfile.getLastName(),
                        "tripTitle", planning.getName()
                    ))
                    .data(dataPayload)
                    .build();
                return notificationService.sendPushNotification(planning.getOrganizationId(), request, null, null);
            })
            .then();
    }

    /**
     * NOUVEAU : Notifie le CLIENT qu'un chauffeur a ACCEPT√â sa demande de r√©servation de planning.
     */
    public Mono<Void> notifyClientOfPlanningBookingAccepted(Product planning, DriverProfile driverProfile) {
        UUID targetClientId = planning.getReservedByDriverId(); // C'est le client qui avait initi√© la r√©servation
        if (targetClientId == null) return Mono.empty();

        log.info("D√©clenchement de la notification pour le client {} (r√©servation de planning ACCEPT√âE par chauffeur {}) pour le planning {}.", targetClientId, driverProfile.getUserId(), planning.getName());

        return deviceTokenRepository.findByUserId(targetClientId)
            .map(DeviceToken::getToken)
            .collectList()
            .flatMap(tokens -> {
                if (tokens.isEmpty()) {
                    log.warn("Aucun token d'appareil trouv√© pour le client {}.", targetClientId);
                    return Mono.empty();
                }

                UUID templateId = UUID.fromString(dotenv.get("TEMPLATE_PUSH_PLANNING_BOOKING_ACCEPTED_TO_CLIENT_ID"));
                
                Map<String, String> dataPayload = new HashMap<>();
                dataPayload.put("screen", "MyReservations"); // √âcran o√π le client voit ses r√©servations
                dataPayload.put("planningId", planning.getId().toString());
                dataPayload.put("driverId", driverProfile.getUserId().toString()); // Infos du chauffeur si besoin
                dataPayload.put("source", "notification");

                NotificationRequest request = NotificationRequest.builder()
                    .templateId(templateId)
                    .recipients(tokens)
                    .metadata(Map.of(
                        "driverName", driverProfile.getFirstName() + " " + driverProfile.getLastName(),
                        "tripTitle", planning.getName()
                    ))
                    .data(dataPayload)
                    .build();
                return notificationService.sendPushNotification(planning.getOrganizationId(), request, null, null);
            })
            .then();
    }

    /**
     * NOUVEAU : Notifie le CHAUFFEUR qu'un client a ANNUL√â sa r√©servation ou sa demande de r√©servation de planning.
     */
    public Mono<Void> notifyDriverOfCancelledPlanningReservation(Product planning, ClientProfile clientProfile) {
        UUID targetDriverId = planning.getClientId(); // L'auteur du planning est le chauffeur
        if (targetDriverId == null) return Mono.empty();

        log.info("D√©clenchement de la notification pour le chauffeur {} (r√©servation/demande ANNUL√âE par client {}) pour le planning {}.", targetDriverId, clientProfile.getUserId(), planning.getName());

        return deviceTokenRepository.findByUserId(targetDriverId)
            .map(DeviceToken::getToken)
            .collectList()
            .flatMap(tokens -> {
                if (tokens.isEmpty()) {
                    log.warn("Aucun token d'appareil trouv√© pour le chauffeur {}.", targetDriverId);
                    return Mono.empty();
                }

                UUID templateId = UUID.fromString(dotenv.get("TEMPLATE_PUSH_PLANNING_RESERVATION_CANCELLED_ID"));
                
                Map<String, String> dataPayload = new HashMap<>();
                dataPayload.put("screen", "MyPlannings"); // √âcran o√π le chauffeur voit ses plannings
                dataPayload.put("planningId", planning.getId().toString());
                dataPayload.put("source", "notification");

                NotificationRequest request = NotificationRequest.builder()
                    .templateId(templateId)
                    .recipients(List.copyOf(tokens))
                    .metadata(Map.of(
                        "clientName", clientProfile.getFirstName() + " " + clientProfile.getLastName(),
                        "tripTitle", planning.getName()
                    ))
                    .data(dataPayload)
                    .build();
                return notificationService.sendPushNotification(planning.getOrganizationId(), request, null, null);
            })
            .then();
    }
    
    /**
     * Notifie TOUS les clients de la publication d'un nouveau planning par un chauffeur.
     */
    public Mono<Void> notifyAllClientsOfNewPlanning(Product planning) {
        log.info("D√©clenchement des notifications √† tous les clients pour le nouveau planning: {}", planning.getName());
        
        UUID templateId = UUID.fromString(dotenv.get("TEMPLATE_PUSH_NEW_PLANNING_ID"));
        
        return clientProfileRepository.findAll()
            .map(client -> client.getUserId())
            .collectList()
            .flatMap(clientIds -> this.sendBroadcastNotification(
                clientIds, 
                templateId, 
                planning.getOrganizationId(), 
                Map.of(
                    "driverName", planning.getClientName(),
                    "destination", planning.getDropoffLocation(),
                    "cost", planning.getDefaultSellPrice() != null ? planning.getDefaultSellPrice().toString() : "0"
                )
            )).then();
    }

    /**
     * Notifie TOUS les chauffeurs de la publication d'une nouvelle annonce par un client.
     */
    public Mono<Void> notifyAllDriversOfNewAnnouncement(Product announcement) {
        log.info("D√©clenchement des notifications √† tous les chauffeurs pour la nouvelle annonce: {}", announcement.getName());
        
        UUID templateId = UUID.fromString(dotenv.get("TEMPLATE_PUSH_NEW_ANNOUNCEMENT_ID"));
        
        return driverProfileRepository.findAll()
            .map(driver -> driver.getUserId())
            .collectList()
            .flatMap(driverIds -> this.sendBroadcastNotification(
                driverIds, 
                templateId, 
                announcement.getOrganizationId(), 
                Map.of("tripTitle", announcement.getName())
            )).then();
    }
    
    /**
     * M√©thode utilitaire priv√©e pour envoyer une notification √† une liste d'utilisateurs.
     */
    private Mono<Boolean> sendBroadcastNotification(List<UUID> userIds, UUID templateId, UUID organizationId, Map<String, String> metadata) {
        if (userIds.isEmpty()) {
            log.warn("La liste d'utilisateurs √† notifier est vide. Annulation.");
            return Mono.just(true);
        }
        return Flux.fromIterable(userIds)
            .flatMap(deviceTokenRepository::findByUserId)
            .map(DeviceToken::getToken)
            .collect(Collectors.toSet())
            .flatMap(tokens -> {
                if (tokens.isEmpty()) {
                    log.warn("Aucun token d'appareil trouv√© pour la liste d'utilisateurs.");
                    return Mono.just(true);
                }
                log.info("Envoi de la notification (template {}) √† {} appareils.", templateId, tokens.size());
                NotificationRequest request = NotificationRequest.builder()
                    .templateId(templateId)
                    .recipients(List.copyOf(tokens))
                    .metadata(metadata)
                    .build();
                // Assurez-vous que sendPushNotification peut prendre le dataPayload si n√©cessaire
                return notificationService.sendPushNotification(organizationId, request, null, null); 
            });
    }
}// END OF FILE: src/main/java/com/freelance/driver_backend/service/NotificationTriggerService.java

//---> PATH: /home/mbogneng-junior/freelance-driver_Sylladb/backend/src/main/java/com/freelance/driver_backend/service/OnboardingService.java

package com.freelance.driver_backend.service;

import com.freelance.driver_backend.dto.external.*;
import com.freelance.driver_backend.dto.onboarding.ClientOnboardingRequest;
import com.freelance.driver_backend.dto.onboarding.DriverOnboardingRequest;
import com.freelance.driver_backend.dto.onboarding.OnboardingResponse;
import com.freelance.driver_backend.dto.UserSessionContextDto; // Importez la nouvelle structure
import com.freelance.driver_backend.model.ClientProfile;
import com.freelance.driver_backend.model.DriverProfile;
import com.freelance.driver_backend.repository.ClientProfileRepository;
import com.freelance.driver_backend.repository.DriverProfileRepository;
import com.freelance.driver_backend.repository.OtpVerificationRepository;
import com.freelance.driver_backend.service.external.AuthService;
import com.freelance.driver_backend.service.external.OrganisationService;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Service;
import reactor.core.publisher.Mono;

import java.time.Instant;
import java.util.Collections;
import java.util.UUID;

@Service
@Slf4j
public class OnboardingService {

    // --- Structures internes pour la clart√© ---
    private record AllInfo(LoginResponse.UserInfo user, OrganisationDto organisation, LoginResponse loginResponse) {}

    // --- D√©pendances ---
    private final AuthService authService;
    private final OrganisationService organisationService;
    private final DriverProfileRepository driverProfileRepository;
    private final ClientProfileRepository clientProfileRepository;
    private final ProfileService profileService;
    private final OtpVerificationRepository otpVerificationRepository;
    private final String publicKey;
    private final String oauthClientId;
    private final String oauthClientSecret;

    public OnboardingService(
            AuthService authService,
            OrganisationService organisationService,
            DriverProfileRepository driverProfileRepository,
            ClientProfileRepository clientProfileRepository,
            ProfileService profileService,
            OtpVerificationRepository otpVerificationRepository,
            @Value("${freelancedriver.api.public-key}") String publicKey,
            @Value("${freelancedriver.oauth2.client-id}") String oauthClientId,
            @Value("${freelancedriver.oauth2.client-secret}") String oauthClientSecret
    ) {
        this.authService = authService;
        this.organisationService = organisationService;
        this.driverProfileRepository = driverProfileRepository;
        this.clientProfileRepository = clientProfileRepository;
        this.profileService = profileService;
        this.otpVerificationRepository = otpVerificationRepository;
        this.publicKey = publicKey;
        this.oauthClientId = oauthClientId;
        this.oauthClientSecret = oauthClientSecret;
    }

    /**
     * Orchestre la cr√©ation compl√®te d'un compte Chauffeur (Auth + Organisation + DriverProfile).
     * Utilis√© pour la premi√®re inscription.
     */
    public Mono<OnboardingResponse> createDriverAccount(DriverOnboardingRequest dto) {
        return verifyOtp(dto.getEmail(), dto.getOtp())
            .then(createAuthUserAndOrganization(dto.getEmail(), dto.getPassword(), dto.getFirstName(), dto.getLastName(), dto.getPhoneNumber(), dto.getCompanyName(), dto.getCompanyDescription()))
            .flatMap(allInfo -> {
                log.info("√âtape 5/6 (Driver): Sauvegarde du profil Driver pour l'utilisateur ID: {}", allInfo.user().getId());
                return createDriverProfile(allInfo.user().getId(), allInfo.organisation().getOrganizationId(), dto, allInfo.user())
                    .then(buildFinalResponse(allInfo.loginResponse()));
            });
    }

    /**
     * Orchestre la cr√©ation compl√®te d'un compte Client (Auth + Organisation + ClientProfile).
     * Utilis√© pour la premi√®re inscription.
     */
    public Mono<OnboardingResponse> createClientAccount(ClientOnboardingRequest dto) {
        return verifyOtp(dto.getEmail(), dto.getOtp())
            .then(createAuthUserAndOrganization(dto.getEmail(), dto.getPassword(), dto.getFirstName(), dto.getLastName(), dto.getPhoneNumber(), dto.getCompanyName(), dto.getCompanyDescription()))
            .flatMap(allInfo -> {
                log.info("√âtape 5/6 (Client): Sauvegarde du profil Client pour l'utilisateur ID: {}", allInfo.user().getId());
                return createClientProfile(allInfo.user().getId(), allInfo.organisation().getOrganizationId(), dto, allInfo.user())
                    .then(buildFinalResponse(allInfo.loginResponse()));
            });
    }

    /**
     * Cr√©e un profil Driver pour un utilisateur **EXISTANT**.
     * R√©utilise l'organisation principale de l'utilisateur ou en cr√©e une par d√©faut si aucune n'existe.
     * @param userId L'ID de l'utilisateur existant.
     * @param dto Les donn√©es du profil chauffeur.
     * @param userBearerToken Le token JWT de l'utilisateur.
     * @return Le DriverProfile cr√©√©.
     */
    public Mono<DriverProfile> createDriverProfileForExistingUser(UUID userId, DriverOnboardingRequest dto, String userBearerToken) {
        log.info("Cr√©ation du profil Driver pour un utilisateur existant: {}", userId);
        // R√©cup√©rer le contexte utilisateur existant pour trouver l'organisation ID
        return profileService.getUserSessionContext(userId, userBearerToken, publicKey)
            .flatMap(context -> {
                UUID organizationId = context.getOrganisation() != null ? context.getOrganisation().getOrganizationId() : null;
                if (organizationId == null) {
                    log.warn("L'utilisateur {} n'a pas d'organisation existante. Cr√©ation d'une organisation par d√©faut pour le nouveau profil chauffeur.", userId);
                    OrganisationCreationRequest orgRequest = OrganisationCreationRequest.builder()
                        .longName(dto.getFirstName() + " " + dto.getLastName() + "'s Driving Services")
                        .email(dto.getEmail()) // Utiliser l'email du DTO pour l'organisation
                        .build();
                    // N√©cessite un token M2M pour appeler le service d'organisation
                    return authService.getClientCredentialsToken(oauthClientId, oauthClientSecret)
                        .flatMap(m2mToken -> organisationService.createOrganisation(orgRequest, "Bearer " + m2mToken.getAccessToken(), publicKey))
                        .map(OrganisationDto::getOrganizationId);
                }
                return Mono.just(organizationId);
            })
            .flatMap(orgId -> {
                // Cr√©er un UserInfo factice pour la cr√©ation de profil, car l'utilisateur existe d√©j√†
                LoginResponse.UserInfo dummyUser = new LoginResponse.UserInfo();
                dummyUser.setId(userId);
                dummyUser.setFirstName(dto.getFirstName());
                dummyUser.setLastName(dto.getLastName());
                dummyUser.setPhoneNumber(dto.getPhoneNumber()); // Utiliser le num√©ro du DTO
                dummyUser.setEmail(dto.getEmail());

                return createDriverProfile(userId, orgId, dto, dummyUser);
            });
    }

    /**
     * Cr√©e un profil Client pour un utilisateur **EXISTANT**.
     * R√©utilise l'organisation principale de l'utilisateur ou en cr√©e une par d√©faut si aucune n'existe.
     * @param userId L'ID de l'utilisateur existant.
     * @param dto Les donn√©es du profil client.
     * @param userBearerToken Le token JWT de l'utilisateur.
     * @return Le ClientProfile cr√©√©.
     */
    public Mono<ClientProfile> createClientProfileForExistingUser(UUID userId, ClientOnboardingRequest dto, String userBearerToken) {
        log.info("Cr√©ation du profil Client pour un utilisateur existant: {}", userId);
        return profileService.getUserSessionContext(userId, userBearerToken, publicKey)
            .flatMap(context -> {
                UUID organizationId = context.getOrganisation() != null ? context.getOrganisation().getOrganizationId() : null;
                if (organizationId == null) {
                     log.warn("L'utilisateur {} n'a pas d'organisation existante. Cr√©ation d'une organisation par d√©faut pour le nouveau profil client.", userId);
                    OrganisationCreationRequest orgRequest = OrganisationCreationRequest.builder()
                        .longName(dto.getCompanyName().isEmpty() ? (dto.getFirstName() + " " + dto.getLastName() + "'s Client Account") : dto.getCompanyName())
                        .email(dto.getEmail()) // Utiliser l'email du DTO pour l'organisation
                        .build();
                     return authService.getClientCredentialsToken(oauthClientId, oauthClientSecret)
                        .flatMap(m2mToken -> organisationService.createOrganisation(orgRequest, "Bearer " + m2mToken.getAccessToken(), publicKey))
                        .map(OrganisationDto::getOrganizationId);
                }
                return Mono.just(organizationId);
            })
            .flatMap(orgId -> {
                LoginResponse.UserInfo dummyUser = new LoginResponse.UserInfo();
                dummyUser.setId(userId);
                dummyUser.setFirstName(dto.getFirstName());
                dummyUser.setLastName(dto.getLastName());
                dummyUser.setPhoneNumber(dto.getPhoneNumber()); // Utiliser le num√©ro du DTO
                dummyUser.setEmail(dto.getEmail());

                return createClientProfile(userId, orgId, dto, dummyUser);
            });
    }


    /**
     * Helper priv√© pour cr√©er un DriverProfile dans la DB.
     */
    private Mono<DriverProfile> createDriverProfile(UUID userId, UUID organizationId, DriverOnboardingRequest dto, LoginResponse.UserInfo user) {
        DriverProfile profile = new DriverProfile();
        profile.setId(UUID.randomUUID());
        profile.setUserId(userId);
        profile.setOrganisationId(organizationId);
        profile.setFirstName(user.getFirstName());
        profile.setLastName(user.getLastName());
        profile.setPhoneNumber(user.getPhoneNumber());
        profile.setLicenseNumber(dto.getLicenseNumber());
        profile.setVehicleDetails(dto.getVehicleDetails());
        return driverProfileRepository.save(profile);
    }

    /**
     * Helper priv√© pour cr√©er un ClientProfile dans la DB.
     */
    private Mono<ClientProfile> createClientProfile(UUID userId, UUID organizationId, ClientOnboardingRequest dto, LoginResponse.UserInfo user) {
        ClientProfile profile = new ClientProfile();
        profile.setId(UUID.randomUUID());
        profile.setUserId(userId);
        profile.setOrganisationId(organizationId);
        profile.setFirstName(dto.getFirstName());
        profile.setLastName(dto.getLastName());
        profile.setCompanyName(dto.getCompanyName());
        profile.setContactEmail(dto.getEmail());
        profile.setPhoneNumber(user.getPhoneNumber()); // Utiliser le t√©l√©phone de l'utilisateur Auth pour la coh√©rence
        return clientProfileRepository.save(profile);
    }


    /**
     * M√©thode priv√©e pour v√©rifier la validit√© d'un OTP. (Inchang√©e)
     */
    private Mono<Void> verifyOtp(String email, String otp) {
        log.info("‚ñ∂Ô∏è √âtape 1/6: V√©rification de l'OTP {} pour l'email {}", otp, email);

        return otpVerificationRepository.findById(email)
            .switchIfEmpty(
                Mono.defer(() -> {
                    log.error("‚ùå Aucune demande de v√©rification trouv√©e pour l'email : {}", email);
                    return Mono.error(new IllegalStateException("Aucune demande de v√©rification trouv√©e pour cet email."));
                })
            )
            .flatMap(verification -> {
                if (verification.getExpiresAt().isBefore(Instant.now())) {
                    log.warn("‚ùå Tentative avec un OTP expir√© pour {}", email);
                    return otpVerificationRepository.delete(verification)
                        .then(Mono.error(new IllegalStateException("Le code de v√©rification a expir√©.")));
                }
                if (!verification.getOtpCode().equals(otp)) {
                    log.warn("‚ùå Tentative avec un OTP invalide pour {}", email);
                    return Mono.error(new IllegalStateException("Le code de v√©rification est invalide."));
                }

                log.info("‚úÖ OTP valid√© pour {}. Suppression de l'entr√©e.", email);
                return otpVerificationRepository.delete(verification);
            });
    }

    /**
     * G√®re la connexion de l'utilisateur (d√©j√† cr√©√© √† l'√©tape /api/register)
     * et la cr√©ation de son organisation via l'API externe r√©elle. (Inchang√©e)
     */

    
    //Version originale
    /*private Mono<AllInfo> createAuthUserAndOrganization(String email, String password, String firstName, String lastName, String phoneNumber, String companyName, String companyDescription) {
        LoginRequest loginRequest = new LoginRequest(email, password);

        return authService.getClientCredentialsToken(oauthClientId, oauthClientSecret)
            .doOnSuccess(tokenResponse -> log.info("√âtape 2/6: Token de service M2M obtenu."))
            .flatMap(m2mTokenResponse -> {
                String m2mBearerToken = "Bearer " + m2mTokenResponse.getAccessToken();

                //On commentes l'utilisation de m2mBearerToken
                
                return authService.loginUser(loginRequest, m2mBearerToken)
                    .switchIfEmpty(Mono.error(new RuntimeException("√âchec de la connexion de l'utilisateur d√©j√† enregistr√© pour " + email + ". V√©rifiez les identifiants.")))
                    .doOnSuccess(loginResponse -> log.info("√âtape 3/6: Connexion de l'utilisateur {} r√©ussie. (ID: {})", loginResponse.getUser().getUsername(), loginResponse.getUser().getId()))
                    .flatMap(loginResponse -> {
                        LoginResponse.UserInfo registeredUser = loginResponse.getUser();
                        String userBearerToken = "Bearer " + loginResponse.getAccessToken().getToken();

                        String finalCompanyName = companyName.trim().isEmpty() ?
                                                    (firstName.trim() + " " + lastName.trim() + "'s Business") :
                                                    companyName.trim();
                        String finalCompanyDescription = companyDescription.trim().isEmpty() ?
                                                    ("Freelance services for " + (finalCompanyName.contains("'s Business") ? firstName : finalCompanyName)) :
                                                    companyDescription.trim();

                        OrganisationCreationRequest orgRequest = OrganisationCreationRequest.builder()
                                .longName(finalCompanyName)
                                .shortName(generateShortName(finalCompanyName))
                                .description(finalCompanyDescription)
                                .email(email)
                                .build();

                        log.info("√âtape 4/6: Cr√©ation de l'organisation pour l'utilisateur {} via l'API externe.", email);
                        return organisationService.createOrganisation(orgRequest, userBearerToken, publicKey)
                            .map(createdOrg -> {
                                log.info("‚úÖ Organisation '{}' (provenance: {}) cr√©√©e. Donn√©es: {}",
                                    createdOrg.getLongName(),
                                    organisationService.getClass().getSimpleName(),
                                    createdOrg);
                                return new AllInfo(registeredUser, createdOrg, loginResponse);
                            });
                    });
            });
    }
    */



    //On commentes l'utilisation de m2mBearerToken

    private Mono<AllInfo> createAuthUserAndOrganization(String email, String password, String firstName, String lastName, String phoneNumber, String companyName, String companyDescription) {
        LoginRequest loginRequest = new LoginRequest(email, password);

                return authService.loginUser(loginRequest, "jdjdjdkdke")
                    .switchIfEmpty(Mono.error(new RuntimeException("√âchec de la connexion de l'utilisateur d√©j√† enregistr√© pour " + email + ". V√©rifiez les identifiants.")))
                    .doOnSuccess(loginResponse -> log.info("√âtape 3/6: Connexion de l'utilisateur {} r√©ussie. (ID: {})", loginResponse.getUser().getUsername(), loginResponse.getUser().getId()))
                    .flatMap(loginResponse -> {
                        LoginResponse.UserInfo registeredUser = loginResponse.getUser();
                        String userBearerToken = "Bearer " + loginResponse.getAccessToken().getToken();

                        String finalCompanyName = companyName.trim().isEmpty() ?
                                                    (firstName.trim() + " " + lastName.trim() + "'s Business") :
                                                    companyName.trim();
                        String finalCompanyDescription = companyDescription.trim().isEmpty() ?
                                                    ("Freelance services for " + (finalCompanyName.contains("'s Business") ? firstName : finalCompanyName)) :
                                                    companyDescription.trim();

                        OrganisationCreationRequest orgRequest = OrganisationCreationRequest.builder()
                                .longName(finalCompanyName)
                                .shortName(generateShortName(finalCompanyName))
                                .description(finalCompanyDescription)
                                .email(email)
                                .build();

                        log.info("√âtape 4/6: Cr√©ation de l'organisation pour l'utilisateur {} via l'API externe.", email);
                        return organisationService.createOrganisation(orgRequest, userBearerToken, publicKey)
                            .map(createdOrg -> {
                                log.info("‚úÖ Organisation '{}' (provenance: {}) cr√©√©e. Donn√©es: {}",
                                    createdOrg.getLongName(),
                                    organisationService.getClass().getSimpleName(),
                                    createdOrg);
                                return new AllInfo(registeredUser, createdOrg, loginResponse);
                            });
                    });
            
    }
    
    /**
     * Construit la r√©ponse finale √† envoyer au frontend. (Inchang√©e)
     */
    private Mono<OnboardingResponse> buildFinalResponse(LoginResponse loginResponse) {
        UUID userId = loginResponse.getUser().getId();
        String userBearerToken = "Bearer " + loginResponse.getAccessToken().getToken();
        log.info("√âtape 6/6: Construction du contexte de session final pour l'utilisateur ID: {}", userId);

        return profileService.getUserSessionContext(userId, userBearerToken, null)
            .map(userContext -> {
                log.info("Backend DEBUG: Final UserContext before sending to frontend. Roles: {}", userContext.getRoles());
                return OnboardingResponse.builder()
                    .token(loginResponse.getAccessToken().getToken())
                    .profile(userContext)
                    .chatSession(null)
                    .build();
            });
    }

    private String generateShortName(String longName) { // (Inchang√©e)
        if (longName == null || longName.trim().isEmpty()) return "NA";
        String cleanedName = longName.trim();
        StringBuilder initials = new StringBuilder();
        for (String s : cleanedName.split("\\s+")) {
            if (!s.isEmpty()) initials.append(s.charAt(0));
        }
        String shortName = initials.toString().toUpperCase();
        return shortName.length() < 2 ? cleanedName.substring(0, Math.min(cleanedName.length(), 3)).toUpperCase() : shortName;
    }
}// END OF FILE: src/main/java/com/freelance/driver_backend/service/OnboardingService.java

//---> PATH: /home/mbogneng-junior/freelance-driver_Sylladb/backend/src/main/java/com/freelance/driver_backend/service/ProfileService.java



package com.freelance.driver_backend.service;

import com.freelance.driver_backend.dto.UserSessionContextDto;
import com.freelance.driver_backend.dto.external.OrganisationDto;
import com.freelance.driver_backend.model.ClientProfile;
import com.freelance.driver_backend.model.DriverProfile;
import com.freelance.driver_backend.repository.ClientProfileRepository;
import com.freelance.driver_backend.repository.DriverProfileRepository;
import com.freelance.driver_backend.service.external.OrganisationService;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;
import reactor.core.publisher.Mono;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.UUID;
import java.net.URI;
import java.net.URISyntaxException;

@Service
@Slf4j
@RequiredArgsConstructor
public class ProfileService {

    private final DriverProfileRepository driverProfileRepository;
    private final ClientProfileRepository clientProfileRepository;
    private final OrganisationService organisationService;
    private final StorageService storageService;

    public Mono<UserSessionContextDto> getUserSessionContext(UUID userId, String userBearerToken, String publicKey) {
        log.info("ProfileService: Recherche du contexte pour l'utilisateur ID: {}", userId);

        Mono<DriverProfile> driverProfileMono = driverProfileRepository.findByUserId(userId)
                .doOnNext(
                        dp -> log.info("DEBUG_CONTEXT: findByUserId(DRIVER) a retourn√© un profil. ID: {}", dp.getId()))
                .switchIfEmpty(Mono.defer(() -> {
                    log.warn("DEBUG_CONTEXT: findByUserId(DRIVER) a retourn√© vide. Retourne DriverProfile vide.");
                    return Mono.just(new DriverProfile());
                }));

        Mono<ClientProfile> clientProfileMono = clientProfileRepository.findByUserId(userId)
                .doOnNext(
                        cp -> log.info("DEBUG_CONTEXT: findByUserId(CLIENT) a retourn√© un profil. ID: {}", cp.getId()))
                .switchIfEmpty(Mono.defer(() -> {
                    log.warn("DEBUG_CONTEXT: findByUserId(CLIENT) a retourn√© vide. Retourne ClientProfile vide.");
                    return Mono.just(new ClientProfile());
                }));

        return Mono.zip(driverProfileMono, clientProfileMono)
                .flatMap(tuple -> {
                    DriverProfile driverProfile = tuple.getT1();
                    ClientProfile clientProfile = tuple.getT2();

                    List<UserSessionContextDto.UserRole> roles = new ArrayList<>();
                    OrganisationDto primaryOrganisation = null;

                    log.info("DEBUG_CONTEXT: driverProfile.getId() obtenu dans tuple: {}", driverProfile.getId());
                    log.info("DEBUG_CONTEXT: clientProfile.getId() obtenu dans tuple: {}", clientProfile.getId());

                    if (driverProfile != null && driverProfile.getId() != null) {
                        roles.add(UserSessionContextDto.UserRole.DRIVER);
                        if (driverProfile.getOrganisationId() != null) {
                            primaryOrganisation = createMockOrganisationDto(driverProfile.getOrganisationId(),
                                    driverProfile.getFirstName() + "'s Driving Business");
                        }
                    }
                    if (clientProfile != null && clientProfile.getId() != null) {
                        roles.add(UserSessionContextDto.UserRole.CLIENT);
                        if (primaryOrganisation == null && clientProfile.getOrganisationId() != null) {
                            primaryOrganisation = createMockOrganisationDto(clientProfile.getOrganisationId(),
                                    clientProfile.getCompanyName());
                        }
                    }

                    if (roles.isEmpty()) {
                        roles.add(UserSessionContextDto.UserRole.NO_PROFILE);
                        log.warn(
                                "ProfileService: Aucun profil (driver ou client) trouv√© pour l'utilisateur {}. Renvoi du statut NO_PROFILE.",
                                userId);
                    } else {
                        log.info("ProfileService: Profil(s) trouv√©(s) pour l'utilisateur {}. R√¥les: {}", userId, roles);
                    }

                    return Mono.just(UserSessionContextDto.builder()
                            .userId(userId)
                            .roles(roles)
                            .driverProfile(
                                    driverProfile != null && driverProfile.getId() != null ? driverProfile : null)
                            .clientProfile(
                                    clientProfile != null && clientProfile.getId() != null ? clientProfile : null)
                            .organisation(primaryOrganisation)
                            .build());
                });
    }

    private OrganisationDto createMockOrganisationDto(UUID orgId, String name) {
        OrganisationDto orgDto = new OrganisationDto();
        orgDto.setOrganizationId(orgId);
        orgDto.setLongName(name);
        orgDto.setStatus("ACTIVE");
        return orgDto;
    }

    public Mono<UUID> findOrganisationIdByUserId(UUID userId) {
        log.info("Recherche de l'ID d'organisation pour l'utilisateur ID: {}", userId);
        return driverProfileRepository.findByUserId(userId)
                .map(DriverProfile::getOrganisationId)
                .switchIfEmpty(Mono.defer(() -> clientProfileRepository.findByUserId(userId)
                        .map(ClientProfile::getOrganisationId)))
                .switchIfEmpty(Mono.error(new RuntimeException(
                        "Aucun profil (conducteur ou client) trouv√© pour l'utilisateur " + userId)));
    }

    public Mono<DriverProfile> findDriverById(UUID driverId) {
        log.info("Recherche du profil pour le chauffeur ID: {}", driverId);
        return driverProfileRepository.findByUserId(driverId)
                .doOnNext(dp -> log.info("‚úÖ Profil DRIVER trouv√© par findDriverById pour userId: {}. D√©tails: {}",
                        driverId, dp))
                .doOnError(e -> log.error("‚ùå Erreur lors de la recherche du profil DRIVER pour userId {}: {}", driverId,
                        e.getMessage()))
                .switchIfEmpty(Mono.defer(() -> {
                    log.warn("‚ö†Ô∏è Aucun profil DRIVER trouv√© par findDriverById pour userId: {}. (Mono.empty)",
                            driverId);
                    return Mono.empty();
                }));
    }

    public Mono<ClientProfile> findClientById(UUID clientId) {
        log.info("Recherche du profil pour le client ID: {}", clientId);
        return clientProfileRepository.findByUserId(clientId)
                .doOnNext(cp -> log.info("‚úÖ Profil CLIENT trouv√© par findClientById pour userId: {}. D√©tails: {}",
                        clientId, cp))
                .doOnError(e -> log.error("‚ùå Erreur lors de la recherche du profil CLIENT pour userId {}: {}", clientId,
                        e.getMessage()))
                .switchIfEmpty(Mono.defer(() -> {
                    log.warn("‚ö†Ô∏è Aucun profil CLIENT trouv√© par findClientById pour userId: {}. (Mono.empty)",
                            clientId);
                    return Mono.empty();
                }));
    }

    // --- LOGIQUE DE MISE √Ä JOUR POUR LES CHAMPS COMMUNS ---
    private <T extends DriverProfile> Mono<T> updateCommonDriverFields(T existingProfile, DriverProfile updatedData) {
        if (updatedData.getFirstName() != null)
            existingProfile.setFirstName(updatedData.getFirstName());
        if (updatedData.getLastName() != null)
            existingProfile.setLastName(updatedData.getLastName());
        if (updatedData.getPhoneNumber() != null)
            existingProfile.setPhoneNumber(updatedData.getPhoneNumber());
        if (updatedData.getNickname() != null)
            existingProfile.setNickname(updatedData.getNickname());
        if (updatedData.getBirthDate() != null)
            existingProfile.setBirthDate(updatedData.getBirthDate());
        if (updatedData.getNationality() != null)
            existingProfile.setNationality(updatedData.getNationality());
        if (updatedData.getGender() != null)
            existingProfile.setGender(updatedData.getGender());
        if (updatedData.getLanguage() != null)
            existingProfile.setLanguage(updatedData.getLanguage());
        // Note: profileImageUrl est g√©r√© par updateAvatarUrl, pas ici directement.
        return Mono.just(existingProfile);
    }

    private <T extends ClientProfile> Mono<T> updateCommonClientFields(T existingProfile, ClientProfile updatedData) {
        if (updatedData.getFirstName() != null)
            existingProfile.setFirstName(updatedData.getFirstName());
        if (updatedData.getLastName() != null)
            existingProfile.setLastName(updatedData.getLastName());
        if (updatedData.getPhoneNumber() != null)
            existingProfile.setPhoneNumber(updatedData.getPhoneNumber());
        if (updatedData.getNickname() != null)
            existingProfile.setNickname(updatedData.getNickname());
        if (updatedData.getBirthDate() != null)
            existingProfile.setBirthDate(updatedData.getBirthDate());
        if (updatedData.getNationality() != null)
            existingProfile.setNationality(updatedData.getNationality());
        if (updatedData.getGender() != null)
            existingProfile.setGender(updatedData.getGender());
        if (updatedData.getLanguage() != null)
            existingProfile.setLanguage(updatedData.getLanguage());
        // Note: profileImageUrl est g√©r√© par updateAvatarUrl, pas ici directement.
        // contactEmail, companyName sont sp√©cifiques au Client, et d√©j√† g√©r√©s dans
        // updateClientProfile
        return Mono.just(existingProfile);
    }

    public Mono<UserSessionContextDto> updateDriverProfile(UUID userId, DriverProfile updatedData) {
        return driverProfileRepository.findByUserId(userId)
                .flatMap(existingDriverProfile -> {
                    log.info("Mise √† jour du profil DRIVER pour l'utilisateur ID: {}", userId);

                    // 1. Mettre √† jour les champs communs dans le DriverProfile existant
                    // Puis mettre √† jour les champs sp√©cifiques au Driver
                    return updateCommonDriverFields(existingDriverProfile, updatedData)
                            .flatMap(profile -> {
                                if (updatedData.getBiography() != null)
                                    profile.setBiography(updatedData.getBiography());
                                if (updatedData.getVehicleDetails() != null)
                                    profile.setVehicleDetails(updatedData.getVehicleDetails());
                                if (updatedData.getLicenseNumber() != null)
                                    profile.setLicenseNumber(updatedData.getLicenseNumber());
                                return driverProfileRepository.save(profile)
                                        .doOnSuccess(
                                                dp -> log.info("‚úÖ DriverProfile mis √† jour pour userId: {}", userId))
                                        .doOnError(e -> log.error(
                                                "‚ùå √âchec de la mise √† jour du DriverProfile pour userId {}: {}", userId,
                                                e.getMessage()));
                            })
                            // 2. Synchroniser les champs communs vers le ClientProfile (s'il existe)
                            .then(clientProfileRepository.findByUserId(userId)
                                    .flatMap(existingClientProfile -> updateCommonClientFields(existingClientProfile,
                                            new ClientProfile() {
                                                { // Cr√©e un ClientProfile "factice" avec les donn√©es de updatedData
                                                  // pour la synchronisation
                                                    setFirstName(updatedData.getFirstName());
                                                    setLastName(updatedData.getLastName());
                                                    setPhoneNumber(updatedData.getPhoneNumber());
                                                    setNickname(updatedData.getNickname());
                                                    setBirthDate(updatedData.getBirthDate());
                                                    setNationality(updatedData.getNationality());
                                                    setGender(updatedData.getGender());
                                                    setLanguage(updatedData.getLanguage());
                                                }
                                            })
                                            .flatMap(profile -> clientProfileRepository.save(profile))
                                            .doOnSuccess(cp -> log.info(
                                                    "‚úÖ ClientProfile synchronis√© depuis DriverProfile pour userId: {}",
                                                    userId))
                                            .doOnError(e -> log.error(
                                                    "‚ùå √âchec de la synchronisation du ClientProfile depuis DriverProfile pour userId {}: {}",
                                                    userId, e.getMessage())))
                                    .then() // Transformer en Mono<Void>
                                    .switchIfEmpty(Mono.defer(() -> {
                                        log.info("Pas de ClientProfile √† synchroniser pour l'utilisateur {}.", userId);
                                        return Mono.empty();
                                    })))
                            // 3. Apr√®s toutes les mises √† jour, r√©cup√©rer le contexte complet
                            .then(Mono.defer(() -> getUserSessionContext(userId, null, null)));
                })
                .switchIfEmpty(Mono.defer(() -> { // G√©rer le cas o√π aucun DriverProfile n'est trouv√©
                    log.warn("Tentative de mise √† jour DriverProfile pour userId {} mais aucun DriverProfile trouv√©.",
                            userId);
                    return Mono
                            .error(new IllegalStateException("DriverProfile non trouv√© pour l'utilisateur " + userId));
                }));
    }

    public Mono<UserSessionContextDto> updateClientProfile(UUID userId, ClientProfile updatedData) { // Changement du
                                                                                                     // type de retour
        return clientProfileRepository.findByUserId(userId)
                .flatMap(existingClientProfile -> {
                    log.info("Mise √† jour du profil CLIENT pour l'utilisateur ID: {}", userId);

                    // 1. Mettre √† jour les champs communs dans le ClientProfile existant
                    // Puis mettre √† jour les champs sp√©cifiques au Client
                    return updateCommonClientFields(existingClientProfile, updatedData)
                            .flatMap(profile -> {
                                if (updatedData.getCompanyName() != null)
                                    profile.setCompanyName(updatedData.getCompanyName());
                                if (updatedData.getContactEmail() != null)
                                    profile.setContactEmail(updatedData.getContactEmail());
                                return clientProfileRepository.save(profile)
                                        .doOnSuccess(
                                                cp -> log.info("‚úÖ ClientProfile mis √† jour pour userId: {}", userId))
                                        .doOnError(e -> log.error(
                                                "‚ùå √âchec de la mise √† jour du ClientProfile pour userId {}: {}", userId,
                                                e.getMessage()));
                            })
                            // 2. Synchroniser les champs communs vers le DriverProfile (s'il existe)
                            .then(driverProfileRepository.findByUserId(userId)
                                    .flatMap(existingDriverProfile -> updateCommonDriverFields(existingDriverProfile,
                                            new DriverProfile() {
                                                { // Cr√©e un DriverProfile "factice" avec les donn√©es de updatedData
                                                  // pour la synchronisation
                                                    setFirstName(updatedData.getFirstName());
                                                    setLastName(updatedData.getLastName());
                                                    setPhoneNumber(updatedData.getPhoneNumber());
                                                    setNickname(updatedData.getNickname());
                                                    setBirthDate(updatedData.getBirthDate());
                                                    setNationality(updatedData.getNationality());
                                                    setGender(updatedData.getGender());
                                                    setLanguage(updatedData.getLanguage());
                                                }
                                            })
                                            .flatMap(profile -> driverProfileRepository.save(profile))
                                            .doOnSuccess(dp -> log.info(
                                                    "‚úÖ DriverProfile synchronis√© depuis ClientProfile pour userId: {}",
                                                    userId))
                                            .doOnError(e -> log.error(
                                                    "‚ùå √âchec de la synchronisation du DriverProfile depuis ClientProfile pour userId {}: {}",
                                                    userId, e.getMessage())))
                                    .then() // Transformer en Mono<Void>
                                    .switchIfEmpty(Mono.defer(() -> {
                                        log.info("Pas de DriverProfile √† synchroniser pour l'utilisateur {}.", userId);
                                        return Mono.empty();
                                    })))
                            // 3. Apr√®s toutes les mises √† jour, r√©cup√©rer le contexte complet
                            .then(Mono.defer(() -> getUserSessionContext(userId, null, null)));
                })
                .switchIfEmpty(Mono.defer(() -> { // G√©rer le cas o√π aucun ClientProfile n'est trouv√©
                    log.warn("Tentative de mise √† jour ClientProfile pour userId {} mais aucun ClientProfile trouv√©.",
                            userId);
                    return Mono
                            .error(new IllegalStateException("ClientProfile non trouv√© pour l'utilisateur " + userId));
                }));
    }

    /**
     * Met √† jour l'URL de l'avatar pour TOUS les profils (Driver et Client) de
     * l'utilisateur sp√©cifi√©,
     * S'ILS EXISTENT.
     * Si un ancien avatar existe (sur n'importe quel profil), il est supprim√© du
     * stockage externe.
     *
     * @param userId       L'ID de l'utilisateur.
     * @param newAvatarUrl L'URL publique du nouvel avatar.
     * @return Un Mono<UserSessionContextDto> contenant le contexte mis √† jour de
     *         l'utilisateur.
     */
    public Mono<UserSessionContextDto> updateAvatarUrl(UUID userId, String newAvatarUrl) {
        // √âtape 1: D√©terminer l'ancienne URI de l'avatar pour la suppression (peut
        // provenir de n'importe quel profil)
        Mono<Void> deleteOldAvatarAction = findProfileByUserId(userId) // Obtient le premier profil trouv√©
                .flatMap(profile -> {
                    String oldUrl = getAvatarUrlFromProfile(profile);
                    if (oldUrl != null && !oldUrl.isEmpty() && !oldUrl.equals(newAvatarUrl)) {
                        log.info("Ancien avatar trouv√© pour suppression : {}", oldUrl);
                        String oldUri = extractUriFromUrl(oldUrl); // Assurez-vous que oldUri est le bon chemin pour la
                                                                   // suppression
                        if (oldUri != null) {
                            return storageService.deleteFile(oldUri)
                                    .onErrorResume(e -> {
                                        log.error("√âchec de la suppression de l'ancien avatar {}: {}", oldUri,
                                                e.getMessage());
                                        return Mono.empty(); // Ne pas bloquer la mise √† jour si la suppression √©choue
                                    });
                        }
                    }
                    return Mono.empty(); // Pas d'ancien avatar ou le m√™me avatar, pas de suppression n√©cessaire
                })
                .then(); // Attendre la fin de l'action de suppression (peut √™tre vide)

        // √âtape 2: Mettre √† jour le DriverProfile (s'il existe)
        Mono<Void> updateDriverAvatarMono = driverProfileRepository.findByUserId(userId)
                .flatMap(driverProfile -> {
                    driverProfile.setProfileImageUrl(newAvatarUrl);
                    return driverProfileRepository.save(driverProfile)
                            .doOnSuccess(dp -> log.info("‚úÖ DriverProfile.profileImageUrl mis √† jour pour userId: {}",
                                    userId))
                            .doOnError(e -> log.error(
                                    "‚ùå √âchec de la mise √† jour DriverProfile.profileImageUrl pour userId {}: {}",
                                    userId, e.getMessage()))
                            .then(); // Transformer en Mono<Void>
                })
                .switchIfEmpty(Mono.defer(() -> { // S'il n'y a pas de DriverProfile, renvoyer un Mono<Void> vide
                    log.info(
                            "Pas de DriverProfile trouv√© pour l'utilisateur {}. Pas de mise √† jour de l'avatar Driver.",
                            userId);
                    return Mono.empty();
                }));

        // √âtape 3: Mettre √† jour le ClientProfile (s'il existe)
        Mono<Void> updateClientAvatarMono = clientProfileRepository.findByUserId(userId)
                .flatMap(clientProfile -> {
                    clientProfile.setProfileImageUrl(newAvatarUrl);
                    return clientProfileRepository.save(clientProfile)
                            .doOnSuccess(cp -> log.info("‚úÖ ClientProfile.profileImageUrl mis √† jour pour userId: {}",
                                    userId))
                            .doOnError(e -> log.error(
                                    "‚ùå √âchec de la mise √† jour ClientProfile.profileImageUrl pour userId {}: {}",
                                    userId, e.getMessage()))
                            .then(); // Transformer en Mono<Void>
                })
                .switchIfEmpty(Mono.defer(() -> { // S'il n'y a pas de ClientProfile, renvoyer un Mono<Void> vide
                    log.info(
                            "Pas de ClientProfile trouv√© pour l'utilisateur {}. Pas de mise √† jour de l'avatar Client.",
                            userId);
                    return Mono.empty();
                }));

        // √âtape 4: Ex√©cuter la suppression et les mises √† jour de profils en parall√®le
        // Puis, r√©cup√©rer le contexte complet
        return deleteOldAvatarAction
                .then(Mono.when(updateDriverAvatarMono, updateClientAvatarMono)) // Ex√©cute les deux mises √† jour en
                                                                                 // parall√®le
                .then(Mono.defer(() -> { // Utilise Mono.defer pour s'assurer que getUserSessionContext est appel√© apr√®s
                                         // les mises √† jour
                    log.info(
                            "‚úÖ Avatar mis √† jour pour l'utilisateur ID: {}. R√©cup√©ration du contexte de session mis √† jour.",
                            userId);
                    return getUserSessionContext(userId, null, null); // userBearerToken et publicKey ne sont pas
                                                                      // n√©cessaires pour getUserSessionContext si les
                                                                      // appels sous-jacents g√®rent leur propre auth (ou
                                                                      // mock)
                }))
                .switchIfEmpty(Mono.error(new IllegalStateException(
                        "Aucun profil (Driver ou Client) trouv√© ou mis √† jour pour l'utilisateur ID: " + userId)))
                .doOnError(e -> log.error("‚ùå Erreur finale dans updateAvatarUrl pour userId {}: {}", userId,
                        e.getMessage()));
    }

    public String extractUriFromUrl(String fullUrl) {
        try {
            URI uri = new URI(fullUrl);
            String path = uri.getPath();

            String mediaServiceSegment = "/media-service";
            int servicePathIndex = path.indexOf(mediaServiceSegment);
            if (servicePathIndex != -1) {
                return path.substring(servicePathIndex + mediaServiceSegment.length());
            } else {
                log.warn(
                        "L'URL '{}' ne semble pas provenir du service de m√©dias externe. La suppression ne sera pas tent√©e via l'API externe.",
                        fullUrl);
                return null;
            }
        } catch (URISyntaxException e) {
            log.error("URL invalide, impossible d'extraire l'URI: {}", fullUrl, e);
            return null;
        }
    }

    public Mono<Object> findProfileByUserId(UUID userId) {
        return driverProfileRepository.findByUserId(userId)
                .cast(Object.class)
                .switchIfEmpty(Mono.defer(() -> clientProfileRepository.findByUserId(userId).cast(Object.class)));
    }

    public String getAuthorFirstNameFromProfile(Object profile) {
        if (profile instanceof DriverProfile) {
            return ((DriverProfile) profile).getFirstName();
        } else if (profile instanceof ClientProfile) {
            return ((ClientProfile) profile).getFirstName();
        }
        return "Utilisateur";
    }

    public String getAuthorLastNameFromProfile(Object profile) {
        if (profile instanceof DriverProfile) {
            return ((DriverProfile) profile).getLastName();
        } else if (profile instanceof ClientProfile) {
            return ((ClientProfile) profile).getLastName();
        }
        return "Anonyme";
    }

    public String getAvatarUrlFromProfile(Object profile) {
        if (profile instanceof DriverProfile) {
            return ((DriverProfile) profile).getProfileImageUrl();
        } else if (profile instanceof ClientProfile) {
            return ((ClientProfile) profile).getProfileImageUrl();
        }
        return null;
    }

    /**
     * Met √† jour l'URL de l'avatar pour TOUS les profils (Driver et Client) de
     * l'utilisateur sp√©cifi√©,
     * S'ILS EXISTENT.
     * Si un ancien avatar existe (sur n'importe quel profil), il est supprim√© du
     * stockage externe.
     *
     * @param userId       L'ID de l'utilisateur.
     * @param newAvatarUrl L'URL publique du nouvel avatar.
     * @return Un Mono<UserSessionContextDto> contenant le contexte mis √† jour de
     *         l'utilisateur.
     */

}// END OF FILE: src/main/java/com/freelance/driver_backend/service/ProfileService.java

//---> PATH: /home/mbogneng-junior/freelance-driver_Sylladb/backend/src/main/java/com/freelance/driver_backend/service/resource/MockResourceServiceImpl.java

package com.freelance.driver_backend.service.resource;

import com.freelance.driver_backend.model.Resource;
import com.freelance.driver_backend.model.ResourceKey;
import com.freelance.driver_backend.repository.ClientProfileRepository;
import com.freelance.driver_backend.repository.ResourceRepository;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.context.annotation.Profile;
import org.springframework.stereotype.Service;
import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;
import java.time.Instant;
import java.util.Map;
import java.util.UUID;


@Service
@RequiredArgsConstructor
@Slf4j
public class MockResourceServiceImpl implements ResourceService {

    private final ResourceRepository resourceRepository;
     private final ClientProfileRepository clientProfileRepository; 

     @Override
     public Mono<Resource> createResource(Resource resourceFromController) {
         log.warn("[MOCK] Creating new resource. Data received from controller: {}", resourceFromController.getName());
         
         // ==============================================================================
         //                         LA CORRECTION FINALE EST ICI
         // ==============================================================================
         // On s'assure de copier TOUS les champs pertinents de l'objet re√ßu du contr√¥leur
         // avant de le sauvegarder.
         
         Resource resourceToSave = new Resource();
         
         // Copie de la cl√© et des IDs
         resourceToSave.setKey(resourceFromController.getKey());
         
         // Copie des champs principaux
         resourceToSave.setName(resourceFromController.getName());
         resourceToSave.setStorageCondition(resourceFromController.getStorageCondition());
         resourceToSave.setLongDescription(resourceFromController.getLongDescription());
         resourceToSave.setShortDescription(resourceFromController.getShortDescription());
         resourceToSave.setBasePrice(resourceFromController.getBasePrice());
         resourceToSave.setSkuCode(resourceFromController.getSkuCode());
         resourceToSave.setExpiresAt(resourceFromController.getExpiresAt());
 
         // Copie des m√©tadonn√©es (LE PLUS IMPORTANT)
         resourceToSave.setMetadata(resourceFromController.getMetadata());
 
         // Logique du Mock : on force le statut √† "publi√©e"
         resourceToSave.setState("AVAILABLE");
         log.warn("[MOCK] Forcing resource state to 'AVAILABLE'.");
         
         // Timestamps
         resourceToSave.setCreatedAt(Instant.now());
         resourceToSave.setUpdatedAt(Instant.now());
 
         log.warn("[MOCK] Final object being saved to DB: {}", resourceToSave);
         
         return resourceRepository.save(resourceToSave);
     }
 

    // Le reste des m√©thodes est inchang√© et fonctionnera correctement
    // car le service lira depuis la m√™me base de donn√©es "mock" (Cassandra/ScyllaDB en l'occurrence).
    
   
    @Override
    public Flux<Resource> getResourcesByCategory(String categoryId) {
        log.warn("[MOCK] Fetching all resources for category {} and starting enrichment process.", categoryId);
        return resourceRepository.findByKeyCategoryId(categoryId)
                .flatMap(this::enrichResourceWithClientDetails);
    }
    
    private Mono<Resource> enrichResourceWithClientDetails(Resource resource) {
        if (resource.getMetadata() == null || resource.getMetadata().get("clientId") == null) {
            log.warn("!!!! [ENRICH] Annonce ID {} - √âCHEC : Pas de clientId dans les m√©tadonn√©es.", resource.getResourceId());
            return Mono.just(resource);
        }

        try {
            String clientIdStr = resource.getMetadata().get("clientId");
            UUID clientId = UUID.fromString(clientIdStr);
            log.info(">>>> [ENRICH] Annonce ID {} - Trouv√© clientId : {}. Recherche du profil client...", resource.getResourceId(), clientId);
            
            // On cherche le profil et on loggue ce qu'on trouve (ou pas)
            return clientProfileRepository.findByUserId(clientId)
                .flatMap(clientProfile -> {
                    // ==============================================================================
                    //                         LOG DE V√âRIFICATION
                    // ==============================================================================
                    log.info(">>>> [ENRICH] Annonce ID {} - SUCC√àS : Profil trouv√© pour clientId {}. Num√©ro de t√©l√©phone en BDD : '{}'", resource.getResourceId(), clientId, clientProfile.getPhoneNumber());
                    // ==============================================================================
                    
                    Map<String, String> metadata = resource.getMetadata();
                    metadata.put("clientName", clientProfile.getCompanyName());
                    metadata.put("clientPhoneNumber", clientProfile.getPhoneNumber());
                    resource.setMetadata(metadata);
                    return Mono.just(resource);
                })
                // Ce bloc est ex√©cut√© si `findByUserId` ne trouve RIEN
                .defaultIfEmpty(resource)
                .doOnSuccess(result -> {
                    // Ce log s'ex√©cutera que le profil soit trouv√© ou non.
                    // Il nous montrera si le num√©ro a √©t√© ajout√©.
                    if (result.getMetadata().get("clientPhoneNumber") == null || result.getMetadata().get("clientPhoneNumber").isEmpty()) {
                        log.warn("!!!! [ENRICH] Annonce ID {} - FIN : Enrichissement termin√©, MAIS le num√©ro de t√©l√©phone est TOUJOURS manquant. Le profil n'a probablement pas √©t√© trouv√© en BDD.", resource.getResourceId());
                    }
                });

        } catch (IllegalArgumentException e) {
            log.error("!!!! [ENRICH] Le clientId '{}' pour l'annonce {} n'est pas un UUID valide.", resource.getMetadata().get("clientId"), resource.getResourceId());
            return Mono.just(resource);
        }
    }
    // On fait de m√™me pour la recherche par organisation
    @Override
    public Flux<Resource> getResourcesByOrganisationAndCategory(UUID organisationId, String categoryId) {
        log.warn("[MOCK] Fetching resources for org {} and category {} and ENRICHING them.", organisationId, categoryId);
        return resourceRepository.findByKeyOrganizationIdAndKeyCategoryId(organisationId, categoryId)
                .flatMap(this::enrichResourceWithClientDetails);
    }

    /**
     * M√©thode priv√©e (copi√©e du contr√¥leur) pour enrichir une ressource.
     * C'est maintenant le R√îLE du service de le faire.
     */
    


    @Override
    public Mono<Resource> getResourceById(ResourceKey key) {
        log.warn("[MOCK] Fetching resource by composite key: {}", key);
        return resourceRepository.findById(key);
    }

    @Override
    public Mono<Resource> updateResource(ResourceKey key, Resource updatedResource) {
        log.warn("[MOCK] Updating resource with key: {}", key);
        return resourceRepository.findById(key)
                .flatMap(existingResource -> {
                    existingResource.setName(updatedResource.getName());
                    // ... mettez √† jour les autres champs si n√©cessaire
                    existingResource.setState(updatedResource.getState());
                    existingResource.setUpdatedAt(Instant.now());
                    return resourceRepository.save(existingResource);
                });
    }

    @Override
    public Mono<Void> deleteResource(ResourceKey key) {
        log.warn("[MOCK] Deleting resource with key: {}", key);
        return resourceRepository.deleteById(key);
    }
}// END OF FILE: src/main/java/com/freelance/driver_backend/service/resource/MockResourceServiceImpl.java

//---> PATH: /home/mbogneng-junior/freelance-driver_Sylladb/backend/src/main/java/com/freelance/driver_backend/service/resource/ResourceService.java

package com.freelance.driver_backend.service.resource;

import com.freelance.driver_backend.model.Resource;
import com.freelance.driver_backend.model.ResourceKey; // <-- Nouvel import
import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;
import java.util.UUID;

public interface ResourceService {

    // Ces m√©thodes ne changent pas car elles filtrent sur des listes
    Flux<Resource> getResourcesByOrganisationAndCategory(UUID organisationId, String categoryId);
    Flux<Resource> getResourcesByCategory(String categoryId);

    // Cette m√©thode ne change pas car elle ne concerne que la cr√©ation
    Mono<Resource> createResource(Resource resource);

    // --- MODIFICATIONS ICI ---
    // Pour trouver, mettre √† jour ou supprimer une ressource sp√©cifique, on a besoin de sa cl√© compl√®te
    Mono<Resource> getResourceById(ResourceKey key);
    Mono<Resource> updateResource(ResourceKey key, Resource resource);
    Mono<Void> deleteResource(ResourceKey key);
}// END OF FILE: src/main/java/com/freelance/driver_backend/service/resource/ResourceService.java

//---> PATH: /home/mbogneng-junior/freelance-driver_Sylladb/backend/src/main/java/com/freelance/driver_backend/service/ResourceService.java

package com.freelance.driver_backend.service;

import com.freelance.driver_backend.dto.CreateProductRequest;
import com.freelance.driver_backend.model.Product;
import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;
import java.util.UUID;

public interface ResourceService {
    Mono<Product> createProduct(UUID organizationId, CreateProductRequest request, String bearerToken, String publicKey);
    Flux<Product> getProductsByCategory(UUID organizationId, UUID categoryId, String bearerToken, String publicKey);
    Mono<Product> updateProduct(UUID organizationId, UUID productId, CreateProductRequest request, String bearerToken, String publicKey);
    Mono<Void> deleteProduct(UUID organizationId, UUID productId, String bearerToken, String publicKey);
}// END OF FILE: src/main/java/com/freelance/driver_backend/service/ResourceService.java

//---> PATH: /home/mbogneng-junior/freelance-driver_Sylladb/backend/src/main/java/com/freelance/driver_backend/service/SocketIOService.java

// src/main/java/com/freelance/driver_backend/service/SocketIOService.java

package com.freelance.driver_backend.service;

import com.corundumstudio.socketio.SocketIOServer;
import jakarta.annotation.PostConstruct;
import jakarta.annotation.PreDestroy;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;

@Service
@Slf4j
@RequiredArgsConstructor
public class SocketIOService {

    private final SocketIOServer server;

    // Cette m√©thode est appel√©e automatiquement par Spring apr√®s la cr√©ation du bean.
    @PostConstruct
    private void startServer() {
        server.start();
        log.info("‚úÖ Serveur Socket.IO d√©marr√© sur le port {}.", server.getConfiguration().getPort());
    }

    // Cette m√©thode est appel√©e lorsque l'application s'arr√™te.
    @PreDestroy
    private void stopServer() {
        server.stop();
        log.info("üõë Serveur Socket.IO arr√™t√©.");
    }
    
    // Vous pouvez ajouter ici des m√©thodes pour envoyer des √©v√©nements si vous le souhaitez,
    // mais il est souvent plus simple d'injecter directement le SocketIOServer dans les contr√¥leurs.
}// END OF FILE: src/main/java/com/freelance/driver_backend/service/SocketIOService.java

//---> PATH: /home/mbogneng-junior/freelance-driver_Sylladb/backend/src/main/java/com/freelance/driver_backend/service/StorageService.java

package com.freelance.driver_backend.service;

import com.freelance.driver_backend.dto.external.UploadMediaResponse;
import org.springframework.http.codec.multipart.FilePart;
import reactor.core.publisher.Mono;
import java.util.UUID;

/**
 * Interface d√©finissant les op√©rations pour un service de stockage de fichiers.
 */
public interface StorageService {

    /**
     * Sauvegarde un fichier et renvoie la r√©ponse compl√®te du service de m√©dias, y compris son URL publique et son URI interne.
     * Le service g√©rera l'obtention de son propre token d'authentification M2M.
     *
     * @param serviceContext     Le contexte de service pour l'API externe (ex: "product", "resource").
     * @param frontendLogicalType Le type logique du frontend (ex: "avatars", "vehicles", "documents").
     * @param uploaderUserId     L'ID de l'utilisateur qui t√©l√©verse le fichier (utilis√© pour la structuration du chemin).
     * @param targetResourceId   L'ID de la ressource √† laquelle ce fichier est associ√© (ex: l'ID de l'utilisateur, l'ID du v√©hicule).
     * @param originalFileName   Le nom de fichier original.
     * @param file               Le fichier √† sauvegarder.
     * @return Un Mono contenant l'objet UploadMediaResponse avec l'URL publique et l'URI interne du fichier sauvegard√©.
     */
    Mono<UploadMediaResponse> saveFile(String serviceContext, String frontendLogicalType, UUID uploaderUserId, UUID targetResourceId, String originalFileName, FilePart file);

    /**
     * Supprime un fichier en utilisant son URI interne retourn√© par le service de m√©dias.
     * Le service g√©rera l'obtention de son propre token d'authentification M2M.
     *
     * @param mediaUri           L'URI interne du fichier (ex: "/product/image/avatars/user-id/filename.jpg").
     * @return Un Mono<Void> qui se termine lorsque la suppression est termin√©e.
     */
    Mono<Void> deleteFile(String mediaUri);
}// END OF FILE: src/main/java/com/freelance/driver_backend/service/StorageService.java

//---> PATH: /home/mbogneng-junior/freelance-driver_Sylladb/backend/src/main/java/com/freelance/driver_backend/util/JwtUtil.java

package com.freelance.driver_backend.util;

import org.springframework.security.oauth2.jwt.Jwt;
import java.util.Map;
import java.util.UUID;

public class JwtUtil {

    public static UUID getUserIdFromToken(Jwt jwt) {
        if (jwt == null) {
            throw new IllegalArgumentException("JWT token cannot be null");
        }
        
        Map<String, Object> userClaim = jwt.getClaim("user");
        if (userClaim == null) {
            throw new IllegalStateException("User claim is missing from the token.");
        }
        
        String userIdString = (String) userClaim.get("id");
        if (userIdString == null) {
            throw new IllegalStateException("User ID is missing from the user claim.");
        }
        
        return UUID.fromString(userIdString);
    }
}// END OF FILE: src/main/java/com/freelance/driver_backend/util/JwtUtil.java

//---> PATH: /home/mbogneng-junior/freelance-driver_Sylladb/backend/src/main/resources/application.properties

# ===============================================
# IDENTIFICATION DE L'APPLICATION
# ===============================================
spring.application.name=driver-backend

# ===============================================
# CONFIGURATION DU SERVEUR WEB
# ===============================================
server.port=8080

# ===============================================
# PROFIL ACTIF
# ===============================================


# ===============================================
# CONFIGURATION DES MICROSERVICES EXTERNES
# ===============================================
# ==============================
# MICROSERVICES URLS
# ==============================
microservices.auth-service.url=${MICROSERVICES_AUTH_SERVICE_URL:https://gateway.yowyob.com/auth-service}
microservices.organisation-service.url=${MICROSERVICES_ORGANISATION_SERVICE_URL:https://gateway.yowyob.com/organization-service}
microservices.chat-service.url=${MICROSERVICES_CHAT_SERVICE_URL:http://88.198.150.195:8613}
microservices.notification-service.url=${MICROSERVICES_NOTIFICATION_SERVICE_URL:https://gateway.yowyob.com/notification-service}
microservices.resource-service.url=${MICROSERVICES_RESOURCE_SERVICE_URL:https://gateway.yowyob.com/resource-service}
microservices.media-service.url=${MICROSERVICES_MEDIA_SERVICE_URL:http://media-service.pynfi.com}
# ==============================
# FREELANCE DRIVER CONFIG
# ==============================
freelancedriver.api.public-key=${FREELANCE_DRIVER_API_PUBLIC_KEY:api_1752647119025_8d6e5340.ieGsWPxnE9eY0xBQ7n8htlTiQP3n4009}
freelancedriver.chat.project-id=${FREELANCE_DRIVER_CHAT_PROJECT_ID:25cf4dfd-e847-4b59-91c7-034aa5afc200}

# ==============================
# OAUTH2 CLIENT CONFIG
# ==============================
freelancedriver.oauth2.client-id=${FREELANCE_DRIVER_OAUTH2_CLIENT_ID:test-client}
freelancedriver.oauth2.client-secret=${FREELANCE_DRIVER_OAUTH2_CLIENT_SECRET:secret}
freelancedriver.oauth2.token-url=${FREELANCE_DRIVER_OAUTH2_TOKEN_URL:${MICROSERVICES_AUTH_SERVICE_URL:https://gateway.yowyob.com/auth-service}/oauth/token}

# ==============================
# OAUTH2 RESOURCE SERVER
# ==============================
spring.security.oauth2.resourceserver.jwt.jwk-set-uri=${SPRING_SECURITY_OAUTH2_RESOURCESERVER_JWK_URI:${MICROSERVICES_AUTH_SERVICE_URL:https://gateway.yowyob.com/auth-service}/openid/.well-known/jwks.json}

# ==============================
# DEVTOOLS
# ==============================
spring.devtools.restart.enabled=${SPRING_DEVTOOLS_RESTART_ENABLED:true}

# ==============================
# CASSANDRA CONFIG
# ==============================
spring.data.cassandra.request.timeout=${SPRING_DATA_CASSANDRA_REQUEST_TIMEOUT:20s}
spring.data.cassandra.connection.connect-timeout=${SPRING_DATA_CASSANDRA_CONNECTION_CONNECT_TIMEOUT:20s}
spring.data.cassandra.connection.init-query-timeout=${SPRING_DATA_CASSANDRA_CONNECTION_INIT_QUERY_TIMEOUT:20s}
spring.data.cassandra.contact-points=${SPRING_DATA_CASSANDRA_CONTACT_POINTS:127.0.0.1}
spring.data.cassandra.port=${SPRING_DATA_CASSANDRA_PORT:9042}
spring.data.cassandra.datacenter:${SPRING_DATA_CASSANDRA_DATACENTER:datacenter1}
spring.data.cassandra.keyspace:${SPRING_DATA_CASSANDRA_KEYSPACE:freelancebd}

# ==============================
# MAIL CONFIG
# ==============================
spring.mail.host=${SPRING_MAIL_HOST:smtp.gmail.com}
spring.mail.port=${SPRING_MAIL_PORT:587}
spring.mail.username=${SPRING_MAIL_USERNAME:mbognengj@gmail.com}
spring.mail.password=${SPRING_MAIL_PASSWORD:fmpjyadvpepfvcws}
spring.mail.properties.mail.smtp.auth=${SPRING_MAIL_PROPERTIES_MAIL_SMTP_AUTH:true}
spring.mail.properties.mail.smtp.starttls.enable=${SPRING_MAIL_PROPERTIES_MAIL_SMTP_STARTTLS_ENABLE:true}
spring.mail.properties.mail.debug=${SPRING_MAIL_PROPERTIES_MAIL_DEBUG:true}

# ==============================
# MINIO CONFIG
# ==============================
minio.endpoint=${MINIO_ENDPOINT:http://192.168.43.204:9000}
minio.access-key=${MINIO_ACCESS_KEY:junioradmin}
minio.secret-key=${MINIO_SECRET_KEY:YourStrongPassword2025}
minio.bucket-name=${MINIO_BUCKET_NAME:freelance-driver}

# ==============================
# SOCKET.IO CONFIG
# ==============================
socketio.server.host=${SOCKETIO_SERVER_HOST:0.0.0.0}
socketio.server.port=${SOCKETIO_SERVER_PORT:8080}
# Protocole WebSocket (ws ou wss)
socketio.server.protocol=${SOCKETIO_SERVER_PROTOCOL:ws}
freelancedriver.firebase.project-id=${FREELANCE_DRIVER_FIREBASE_PROJECT_ID:freelance-driver-app}// END OF FILE: src/main/resources/application.properties

//---> PATH: /home/mbogneng-junior/freelance-driver_Sylladb/backend/src/main/resources/firebase-service-account-key .example

{
  "type": "service_account",
  "project_id": "freelance-driver-app",
  "private_key_id": "076ad5670c7bb359ad16b5ba0c7db9f943c98abb",
  "private_key": "-----BEGIN PRIVATE KEY-----\nMIIEvAIBADANBgkqhkiG9w0BAQEFAASCBKYwggSiAgEAAoIBAQCsMuciyPPHLxSj\noOMn5cePlVib5toOdJC0udSBCsealLXLjDKMdkmTiVsfjmPPt2dgUt0tDqH2C8xj\nR5nvRJZiHBJWDhSzSlrCDZR4xTJ71kxQy5EeqR2JjM2zK4QevzGImNYSfTh8daHD\nE+dTc/yGRxW3VREsMNRfBp12oPF/yW7Sakk0Y5eQIKnRWxiB2OJVfJkhPwejLrEK\nAhVaGpclaVqqCYufIwXOmfVqTCSEmXmxhr8DfeZFRZkEB6fXSaVC+2+FwjEHwvJt\nmSnnV7dsI+XGXLaIaKhXfY4UBnOZYIQmImpu55TrRjJ3JSlktEkln3DBdIopUc4A\niGWIt9NXAgMBAAECggEAHjm7H3x1adeGQGh7puOq4TWePZNKYDIuukJKHjJ1sdj7\nhhSARO54YLjB8WqNc4bmUt6IqyF/5U/R2vVU/E4mNWdnAorrMENTZe97Sa2XfGwz\nrhTlTqPxptS7wIDZaoo12Bu3q7wmH5aIQ9UpDBl2UF2G3szEPGT/ygQ/vHRon3zC\nfoySBq+4Pxuwe3AVGYgmSq/sdMXSWgT+vyO3UB7JM1+0mLGE6bxhOBt6G48/4AjY\n9oeYyEQu0fVDMrOAwwjqOzUOdkASsYcmYpILk06o25Nyj7BKryvmpAh3Ir8Scp3c\n0LOto6XBwmD6T8jroX9ccv7mpY5f7PAqXSadwMGS/QKBgQDmCiZssITBqNncj5OJ\nFR6m8K0jXSmfDYErhdllkDrHWTp0b8eh/BED0fb3TCKlBBeBZ9VdTHmMiv0LCJy+\n6/MKSMTcc1ucjbgdtBjXVMHKUy8c7yrmkaXadY1Aj8K9FhYuri5184sES2sbqT0x\nS+VwCtPt00D37ntjkLmNZjLI1QKBgQC/obsNesNXlPXIourPVgAf+vnq6xPnU0Zm\nuYZsB0saSiS62G/gSNtaSpl8QNN3FWeniqa55lor50HRvEoV+6WI5KoxH/EI/F2j\n8FCNBrl8CptMOctskRozQzhYwBFY/F41UjLy4iqsX01y2kCCSRl9T0javwACRbIO\nlkknqaaBewKBgCZckPXVJf5pmxM1+kOE+xyZzDW2hodYqC7K3msad0LhNWdPcLop\nn+jELewljS15ljXlS+aIJ0jxsKsTX5hTHq+bXQDqV9+unoKNkwrtvndwEc5AcCYN\nKdxZeBnJH4+KzF4ye9r9pzQrI4x0V5kN8BAULi1d6lquMXN0Ig1beqKVAoGAKSiX\ngGGpqxn3YEx9mmKiTDwfiXFMKRcdu9qFIJbAbrkWAnuSK936Hv5+0M0rnhwe00FY\nZf0vyNY2sNF8KBSQjUJvu3Vc081AX4GyC1gyZo3wpQKUypCvy+rYI1e9YhtyMImj\nH7+r4rHldJGj4VfJ/bwVrcXwPoyxnahxte8eMBkCgYAS4gfwXi5qM3hryMLLdaLl\nCHeRKuqRj/Ug5DPMcdffIp8GDK6xhzbNFTytScx29wlgaE0g7Dm9bmS7N+0RpnWs\ngQeO2NFnhHot0yvslC2l0EaLAkMkHV8gkUFVXaqycHS1z+rl62S1upEdLUnNI8M9\nhjD59wE6MIzTmVanSjt/+g==\n-----END PRIVATE KEY-----\n",
  "client_email": "firebase-adminsdk-fbsvc@freelance-driver-app.iam.gserviceaccount.com",
  "client_id": "104451789079889408455",
  "auth_uri": "https://accounts.google.com/o/oauth2/auth",
  "token_uri": "https://oauth2.googleapis.com/token",
  "auth_provider_x509_cert_url": "https://www.googleapis.com/oauth2/v1/certs",
  "client_x509_cert_url": "https://www.googleapis.com/robot/v1/metadata/x509/firebase-adminsdk-fbsvc%40freelance-driver-app.iam.gserviceaccount.com",
  "universe_domain": "googleapis.com"
}
// END OF FILE: src/main/resources/firebase-service-account-key .example

//---> PATH: /home/mbogneng-junior/freelance-driver_Sylladb/backend/src/main/resources/firebase-service-account-key.example

{
  "type": "service_account",
  "project_id": "freelance-driver-app",
  "private_key_id": "076ad5670c7bb359ad16b5ba0c7db9f943c98abb",
  "private_key": "-----BEGIN PRIVATE KEY-----\nMIIEvAIBADANBgkqhkiG9w0BAQEFAASCBKYwggSiAgEAAoIBAQCsMuciyPPHLxSj\noOMn5cePlVib5toOdJC0udSBCsealLXLjDKMdkmTiVsfjmPPt2dgUt0tDqH2C8xj\nR5nvRJZiHBJWDhSzSlrCDZR4xTJ71kxQy5EeqR2JjM2zK4QevzGImNYSfTh8daHD\nE+dTc/yGRxW3VREsMNRfBp12oPF/yW7Sakk0Y5eQIKnRWxiB2OJVfJkhPwejLrEK\nAhVaGpclaVqqCYufIwXOmfVqTCSEmXmxhr8DfeZFRZkEB6fXSaVC+2+FwjEHwvJt\nmSnnV7dsI+XGXLaIaKhXfY4UBnOZYIQmImpu55TrRjJ3JSlktEkln3DBdIopUc4A\niGWIt9NXAgMBAAECggEAHjm7H3x1adeGQGh7puOq4TWePZNKYDIuukJKHjJ1sdj7\nhhSARO54YLjB8WqNc4bmUt6IqyF/5U/R2vVU/E4mNWdnAorrMENTZe97Sa2XfGwz\nrhTlTqPxptS7wIDZaoo12Bu3q7wmH5aIQ9UpDBl2UF2G3szEPGT/ygQ/vHRon3zC\nfoySBq+4Pxuwe3AVGYgmSq/sdMXSWgT+vyO3UB7JM1+0mLGE6bxhOBt6G48/4AjY\n9oeYyEQu0fVDMrOAwwjqOzUOdkASsYcmYpILk06o25Nyj7BKryvmpAh3Ir8Scp3c\n0LOto6XBwmD6T8jroX9ccv7mpY5f7PAqXSadwMGS/QKBgQDmCiZssITBqNncj5OJ\nFR6m8K0jXSmfDYErhdllkDrHWTp0b8eh/BED0fb3TCKlBBeBZ9VdTHmMiv0LCJy+\n6/MKSMTcc1ucjbgdtBjXVMHKUy8c7yrmkaXadY1Aj8K9FhYuri5184sES2sbqT0x\nS+VwCtPt00D37ntjkLmNZjLI1QKBgQC/obsNesNXlPXIourPVgAf+vnq6xPnU0Zm\nuYZsB0saSiS62G/gSNtaSpl8QNN3FWeniqa55lor50HRvEoV+6WI5KoxH/EI/F2j\n8FCNBrl8CptMOctskRozQzhYwBFY/F41UjLy4iqsX01y2kCCSRl9T0javwACRbIO\nlkknqaaBewKBgCZckPXVJf5pmxM1+kOE+xyZzDW2hodYqC7K3msad0LhNWdPcLop\nn+jELewljS15ljXlS+aIJ0jxsKsTX5hTHq+bXQDqV9+unoKNkwrtvndwEc5AcCYN\nKdxZeBnJH4+KzF4ye9r9pzQrI4x0V5kN8BAULi1d6lquMXN0Ig1beqKVAoGAKSiX\ngGGpqxn3YEx9mmKiTDwfiXFMKRcdu9qFIJbAbrkWAnuSK936Hv5+0M0rnhwe00FY\nZf0vyNY2sNF8KBSQjUJvu3Vc081AX4GyC1gyZo3wpQKUypCvy+rYI1e9YhtyMImj\nH7+r4rHldJGj4VfJ/bwVrcXwPoyxnahxte8eMBkCgYAS4gfwXi5qM3hryMLLdaLl\nCHeRKuqRj/Ug5DPMcdffIp8GDK6xhzbNFTytScx29wlgaE0g7Dm9bmS7N+0RpnWs\ngQeO2NFnhHot0yvslC2l0EaLAkMkHV8gkUFVXaqycHS1z+rl62S1upEdLUnNI8M9\nhjD59wE6MIzTmVanSjt/+g==\n-----END PRIVATE KEY-----\n",
  "client_email": "firebase-adminsdk-fbsvc@freelance-driver-app.iam.gserviceaccount.com",
  "client_id": "104451789079889408455",
  "auth_uri": "https://accounts.google.com/o/oauth2/auth",
  "token_uri": "https://oauth2.googleapis.com/token",
  "auth_provider_x509_cert_url": "https://www.googleapis.com/oauth2/v1/certs",
  "client_x509_cert_url": "https://www.googleapis.com/robot/v1/metadata/x509/firebase-adminsdk-fbsvc%40freelance-driver-app.iam.gserviceaccount.com",
  "universe_domain": "googleapis.com"
}
// END OF FILE: src/main/resources/firebase-service-account-key.example

//---> PATH: /home/mbogneng-junior/freelance-driver_Sylladb/backend/src/main/resources/firebase-service-account-key.json

{
  "type": "service_account",
  "project_id": "freelance-driver-app",
  "private_key_id": "076ad5670c7bb359ad16b5ba0c7db9f943c98abb",
  "private_key": "-----BEGIN PRIVATE KEY-----\nMIIEvAIBADANBgkqhkiG9w0BAQEFAASCBKYwggSiAgEAAoIBAQCsMuciyPPHLxSj\noOMn5cePlVib5toOdJC0udSBCsealLXLjDKMdkmTiVsfjmPPt2dgUt0tDqH2C8xj\nR5nvRJZiHBJWDhSzSlrCDZR4xTJ71kxQy5EeqR2JjM2zK4QevzGImNYSfTh8daHD\nE+dTc/yGRxW3VREsMNRfBp12oPF/yW7Sakk0Y5eQIKnRWxiB2OJVfJkhPwejLrEK\nAhVaGpclaVqqCYufIwXOmfVqTCSEmXmxhr8DfeZFRZkEB6fXSaVC+2+FwjEHwvJt\nmSnnV7dsI+XGXLaIaKhXfY4UBnOZYIQmImpu55TrRjJ3JSlktEkln3DBdIopUc4A\niGWIt9NXAgMBAAECggEAHjm7H3x1adeGQGh7puOq4TWePZNKYDIuukJKHjJ1sdj7\nhhSARO54YLjB8WqNc4bmUt6IqyF/5U/R2vVU/E4mNWdnAorrMENTZe97Sa2XfGwz\nrhTlTqPxptS7wIDZaoo12Bu3q7wmH5aIQ9UpDBl2UF2G3szEPGT/ygQ/vHRon3zC\nfoySBq+4Pxuwe3AVGYgmSq/sdMXSWgT+vyO3UB7JM1+0mLGE6bxhOBt6G48/4AjY\n9oeYyEQu0fVDMrOAwwjqOzUOdkASsYcmYpILk06o25Nyj7BKryvmpAh3Ir8Scp3c\n0LOto6XBwmD6T8jroX9ccv7mpY5f7PAqXSadwMGS/QKBgQDmCiZssITBqNncj5OJ\nFR6m8K0jXSmfDYErhdllkDrHWTp0b8eh/BED0fb3TCKlBBeBZ9VdTHmMiv0LCJy+\n6/MKSMTcc1ucjbgdtBjXVMHKUy8c7yrmkaXadY1Aj8K9FhYuri5184sES2sbqT0x\nS+VwCtPt00D37ntjkLmNZjLI1QKBgQC/obsNesNXlPXIourPVgAf+vnq6xPnU0Zm\nuYZsB0saSiS62G/gSNtaSpl8QNN3FWeniqa55lor50HRvEoV+6WI5KoxH/EI/F2j\n8FCNBrl8CptMOctskRozQzhYwBFY/F41UjLy4iqsX01y2kCCSRl9T0javwACRbIO\nlkknqaaBewKBgCZckPXVJf5pmxM1+kOE+xyZzDW2hodYqC7K3msad0LhNWdPcLop\nn+jELewljS15ljXlS+aIJ0jxsKsTX5hTHq+bXQDqV9+unoKNkwrtvndwEc5AcCYN\nKdxZeBnJH4+KzF4ye9r9pzQrI4x0V5kN8BAULi1d6lquMXN0Ig1beqKVAoGAKSiX\ngGGpqxn3YEx9mmKiTDwfiXFMKRcdu9qFIJbAbrkWAnuSK936Hv5+0M0rnhwe00FY\nZf0vyNY2sNF8KBSQjUJvu3Vc081AX4GyC1gyZo3wpQKUypCvy+rYI1e9YhtyMImj\nH7+r4rHldJGj4VfJ/bwVrcXwPoyxnahxte8eMBkCgYAS4gfwXi5qM3hryMLLdaLl\nCHeRKuqRj/Ug5DPMcdffIp8GDK6xhzbNFTytScx29wlgaE0g7Dm9bmS7N+0RpnWs\ngQeO2NFnhHot0yvslC2l0EaLAkMkHV8gkUFVXaqycHS1z+rl62S1upEdLUnNI8M9\nhjD59wE6MIzTmVanSjt/+g==\n-----END PRIVATE KEY-----\n",
  "client_email": "firebase-adminsdk-fbsvc@freelance-driver-app.iam.gserviceaccount.com",
  "client_id": "104451789079889408455",
  "auth_uri": "https://accounts.google.com/o/oauth2/auth",
  "token_uri": "https://oauth2.googleapis.com/token",
  "auth_provider_x509_cert_url": "https://www.googleapis.com/oauth2/v1/certs",
  "client_x509_cert_url": "https://www.googleapis.com/robot/v1/metadata/x509/firebase-adminsdk-fbsvc%40freelance-driver-app.iam.gserviceaccount.com",
  "universe_domain": "googleapis.com"
}
// END OF FILE: src/main/resources/firebase-service-account-key.json

//---> PATH: /home/mbogneng-junior/freelance-driver_Sylladb/backend/src/test/java/com/freelance/driver_backend/DriverBackendApplicationTests.java

package com.freelance.driver_backend;

import org.junit.jupiter.api.Test;
import org.springframework.boot.test.context.SpringBootTest;

@SpringBootTest
class DriverBackendApplicationTests {

	@Test
	void contextLoads() {
	}

}
// END OF FILE: src/test/java/com/freelance/driver_backend/DriverBackendApplicationTests.java

